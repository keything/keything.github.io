<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Keything的日志</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Keything的日志">
<meta property="og:url" content="http://keything.github.io/page/8/index.html">
<meta property="og:site_name" content="Keything的日志">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Keything的日志">
  
    <link rel="alternate" href="/atom.xml" title="Keything的日志" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Keything的日志</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://keything.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-nginx-location匹配" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/04/nginx-location匹配/" class="article-date">
  <time datetime="2016-05-04T10:00:01.000Z" itemprop="datePublished">2016-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/04/nginx-location匹配/">nginx-location匹配</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这篇文字是对官方文档中location[1]:<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#location" target="_blank" rel="noopener">http://nginx.org/en/docs/http/ngx_http_core_module.html#location</a> 的解读。</p>
<h2 id="一-语法"><a href="#一-语法" class="headerlink" title="一. 语法"></a>一. 语法</h2><pre><code>Syntax:

location [ = | ~ | ~* | ^~ ] uri { ... }
location @name { ... }

Default:

—

Context:

server, location
</code></pre><h2 id="二-解释"><a href="#二-解释" class="headerlink" title="二. 解释"></a>二. 解释</h2><p>根据请求URI进行配置。</p>
<p>与归一化的URI进行匹配。 归一化包括：1）将已经编码为%XX格式的URI解码为普通格式; 2）解析references到相对路径. 和..; 3）将多个连接的斜杠/ 变为单个斜杠/。</p>
<ol>
<li>一个location可以是前缀字符串，也可以是正则表达式。</li>
<li>正则表达式由 ~*（大小写不敏感） 或 ~（大小写敏感）指定。</li>
<li>为了找到与给定请求相匹配的location，nginx首先检查<code>前缀字符串（前缀location）</code>定义的location。在这些前缀字符串中，选择<code>最长匹配的前缀</code>并将其记住。</li>
<li>之后检查<code>`正则表达式</code>，检查正则表达式是按照其在配置文件中的顺序检查，当正则表达式第一次匹配后，就停止正则表达式的匹配，对应的正则的location的配置就会被使用。 </li>
<li>如果没有与正则表达式相匹配的location，那么最长前缀location就被使用。</li>
<li>如果最长匹配前缀location有^~的修饰符，那么就不会检查正则表达式。</li>
<li>同时，可以使用=修饰符，该修饰符定义了URI和location的准确匹配。如果一个准确的match被找到，那么搜索停止。</li>
</ol>
<p>location检查的策略：</p>
<pre><code>1. 首先检查指定了前缀的location块 普通的location块。
2. 其次检查带正则的location块 顺序匹配，一旦匹配到第一个就停止后面的匹配。
对于匹配正则location并不是所有情况都进行，有两种情况是例外：
1）普通location前面指定了^~ 告诉nginx只要普通location一旦匹配上，则不需要继续正则匹配。匹配上了普通location就不进行正则匹配。
2）普通location恰好严格匹配上，不是最大前缀匹配，则不再继续匹配正则。

   简要概述：
    正则 location 匹配让步普通 location 的严格精确匹配结果；但覆盖普通 location 的最大前缀匹配结果
如下图所示：
</code></pre><p><img src="/images/nginx_location_match.png" alt="location_match"></p>
<p>举例说明：</p>
<pre><code>location = / {
    [ configuration A ]
}

location / {
    [ configuration B ]
}

location /documents/ {
    [ configuration C ]
}

location ^~ /images/ {
    [ configuration D ]
}

location ~* \.(gif|jpg|jpeg)$ {
    [ configuration E ]
}

请求/ 匹配配置A，/index.html匹配配置B，/documents匹配配置C，/images/1.gif匹配配置D，/documents/1.jpg匹配配置E
</code></pre><p>注意：@前缀定义了一个命名location。这样一个location不是用于正则请求处理，而是用于请求的重定向。他们不能嵌套在location中，也不能包含嵌套的location。</p>
<p>参考文章</p>
<p><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#location" target="_blank" rel="noopener">http://nginx.org/en/docs/http/ngx_http_core_module.html#location</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/05/04/nginx-location匹配/" data-id="ckw1x5qbt003p3mnur8j8rbq0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-nginx配置-最小配置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/04/nginx配置-最小配置/" class="article-date">
  <time datetime="2016-05-04T10:00:01.000Z" itemprop="datePublished">2016-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/04/nginx配置-最小配置/">nginx配置-最小配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><p>很多时候都会提到最小模块。对于Nginx的配置，当然也要有最小配置呢。当然下面的配置也不是最小配置，因为里面有很多配置都是有默认值的。大家可以查看一下nginx.org上的文档说明。</p>
<h2 id="主配置文件nginx-conf详细说明"><a href="#主配置文件nginx-conf详细说明" class="headerlink" title="主配置文件nginx.conf详细说明"></a>主配置文件nginx.conf详细说明</h2><p>在nginx.conf中包括了事件模块events{}, http模块http{}。并没有看到预想的虚拟主机server{}。因为我们通过include host/*.conf将虚拟主机的配置放在了vhost文件夹中。类似C语言中include。</p>
<pre><code>##nginx.conf
error_log  /usr/local/var/log/nginx/error.log  info;
pid        /usr/local/var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    include vhost/*.conf;
}
</code></pre><h2 id="普通HTTP虚拟主机配置"><a href="#普通HTTP虚拟主机配置" class="headerlink" title="普通HTTP虚拟主机配置"></a>普通HTTP虚拟主机配置</h2><p>vhost/basic.conf<br>     basic.conf配置中必要的配置是listen，root，location /, location ~ .php$ {}.<br>其中location ~.php${}的作用是将以php结尾的文件转向FastCGI服务器。</p>
<pre><code># vhost/basic.conf
server {
    listen       80 default;
    server_name  localhost;
    access_log  /usr/local/var/log/nginx/access.log;

    charset utf8;

    root   /Users/xx/Documents/Study/nginx/learn_conf;
    location / {
        index  index.php index.html index.htm;
    }

    error_page 404 404.php;
    fastcgi_intercept_errors on;
    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
    location ~ \.php$ {
        fastcgi_pass   localhost:9000;
        fastcgi_index  index.php;
        include        fastcgi.conf;
    }
}
</code></pre><h2 id="加密HTTPS虚拟主机配置"><a href="#加密HTTPS虚拟主机配置" class="headerlink" title="加密HTTPS虚拟主机配置"></a>加密HTTPS虚拟主机配置</h2><p>加密HTTPS与普通HTTP虚拟主机的区别在于：<br>1）端口号后加 ssl<br>2）加入ssl_certificate   ssl_certificate_key两个指令</p>
<p>其他方面二者相同：比如端口号改变，server_name更改</p>
<pre><code>server {
    listen 443 ssl;
    server_name learn.ssl1;

    ssl_certificate /Users/Documents/GitLibrary/nginx/nginx_conf/vhost/33iq.crt;
    ssl_certificate_key /Users/Documents/GitLibrary/nginx/nginx_conf/vhost/33iq_nopass.key;

    root /Users/Documents/Study/nginx/learn_ssl2;
    location / {
        index index.php index.html index.htm;
    }

    error_page 404 404.php;
    fastcgi_intercept_errors on;
    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
    location ~ \.php$ {
        fastcgi_pass   localhost:9000;
        fastcgi_index  index.php;
        include        fastcgi.conf;
    }
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/05/04/nginx配置-最小配置/" data-id="ckw1x5qbw003x3mnul1ab3irf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-unix-inode-学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/28/unix-inode-学习/" class="article-date">
  <time datetime="2016-04-28T10:00:01.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/unix-inode-学习/">Unix/Linux文件系统--目录，inode，硬链接</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-简介：文件和Inodes"><a href="#1-简介：文件和Inodes" class="headerlink" title="1. 简介：文件和Inodes"></a>1. 简介：文件和Inodes</h2><p>在Unix/Linux中，文件是没有结构的一个字节序列。文件中控制数据的程序（比如mysql）会添加任何所需要的结构。linux自己并不需要知道数据库文件的内部结构，对于linux而言只需要返回字节（bytes）</p>
<h3 id="1-1-甚至硬件设备都有文件名"><a href="#1-1-甚至硬件设备都有文件名" class="headerlink" title="1.1 甚至硬件设备都有文件名"></a>1.1 甚至硬件设备都有文件名</h3><p>Unix/Linux尽可能的将每个设备都当做一系列字节。因此包括网卡、硬盘驱动、键盘、打印机、文件在内，一切都被当做文件。</p>
<pre><code>你的电脑内存是 /dev/mem
你的第一块硬盘是 /dev/sda
你的终端是 /dev/tty1
...
</code></pre><p>举例</p>
<pre><code>$ ls -li /dev/mem /dev/sda /dev/tty1
5792 crw-r----- 1 root kmem 1, 1 Oct 13 02:30 /dev/mem
 888 brw-rw---- 1 root disk 8, 0 Oct 13 02:30 /dev/sda
5808 crw-rw---- 1 root tty  4, 1 Oct 13 02:31 /dev/tty1
</code></pre><p>在Linux中大多数的输入输出设备和目录都被看做文件。如果你有足够的权限，你可以使用它们的文件系统的名字来读取这些设备。</p>
<h3 id="1-2-Index-Nodes-inodes"><a href="#1-2-Index-Nodes-inodes" class="headerlink" title="1.2 Index Nodes = inodes"></a>1.2 Index Nodes = inodes</h3><p>文件系统的内容都不是以名字的形式存储，而是以数字的形式存储。Linux是以序号化结构来存储每个硬盘对象（disk object, 如文件或目录）的数据和信息。这个序号化的结构称之为index node或inode。</p>
<p>每个inode都是由唯一的inode number来标识，可以使用ls -i选项查看。</p>
<pre><code>$ ls -l -i /usr/bin/perl*
266327 -rwxr-xr-x 2 root root 10376 Mar 18  2013 /usr/bin/perl
266327 -rwxr-xr-x 2 root root 10376 Mar 18  2013 /usr/bin/perl5.14.2
266331 -rwxr-xr-x 2 root root 45183 Mar 18  2013 /usr/bin/perlbug
266328 -rwxr-xr-x 1 root root   224 Mar 18  2013 /usr/bin/perldoc
</code></pre><p>Unix的目录将文件系统的名字与inode number进行关联。正如上面例子，/usr/bin/perl与inode number 266327关联。当你到达perl程序的时候，系统将会在目录中找到perl这个名字，与perl名字相关联的inode number是266327，这个inode存有真正的数据，系统通过inode找到真正的数据。文件数据与inode number关联，而不是与名字关联。</p>
<p>在目录中，每个文件有自己名字和与之关联的inode number。每个文件名字可以映射到一个inode number，但是一个inode number可以有多个名字。</p>
<p>Inode numbers are specific to a file system inside a disk partition. Every file on a file system (in that partition) has a unique inode number. Numbering is done separately for each file system, so different disk partitions may have file system objects with the same inode numbers.</p>
<p>每个文件系统初始化的时候会有大量可用的inodes，可以使用<code>df -i</code>列出可用的inodes。</p>
<h2 id="2-文件系统示意图"><a href="#2-文件系统示意图" class="headerlink" title="2. 文件系统示意图"></a>2. 文件系统示意图</h2><p>大多数关于文件系统的示意图都是错误的，下面是真相。<br>inodes的名字（如文件、目录、设备等的名字）是在目录中存储的。目录中只存储了名字和inodenumber的关联关系。文件中数据的真正存储的硬盘空间是在inode中，而不是在目录中。目录中保存的是名字和inode number，名字不会与数据有关联。</p>
<p>目录中，每个名字有一个inode number，inode number指出了存储数据的硬盘空间的位置。通过<code>ls -i</code>看到名字和inode对应关系。</p>
<pre><code>$ ls -i /usr/bin/perl*
266327 /usr/bin/perl        266329 /usr/bin/perldoc.stub
266327 /usr/bin/perl5.14.2  266330 /usr/bin/perlivp
266331 /usr/bin/perlbug     266331 /usr/bin/perlthanks
266328 /usr/bin/perldoc
</code></pre><p>最重要的事情是知道名字和数据真正存储的位置是分开的。大多数示意图都会把ROOT的名字搞成命名的。这会造成对unix/linux文件和目录的误解。</p>
<pre><code>WRONG - names on things      RIGHT - names above things
=======================      ==========================

    R O O T            ---&gt;         [etc,bin,home]   &lt;-- ROOT directory
   /   |   \                         /    |      \
etc   bin   home       ---&gt;  [passwd]  [ls,rm]  [abcd0001]
 |   /   \    \                 |      /    \       |
 |  ls   rm  abcd0001  ---&gt;     |  &lt;data&gt;  &lt;data&gt;  [.bashrc]
 |               |              |                   |
passwd       .bashrc   ---&gt;  &lt;data&gt;                &lt;data&gt;
</code></pre><p>目录是名字和数字的列表，右侧示意图以中括号的方式列出，在示意图中忽略了innode number。目录中每一个对象（文件、目录、特殊文件等）的名字与真正的存储空间是分开的。这就允许一个inode可以有多个名字和多个目录。使用相同的inode number，所有的名字指向相同的存储空间。</p>
<p>右侧示意图中，树中目录有自己的名字。右侧最顶层目录是ROOT目录的inode，包含了etc,bin,home..的名字列表。因为在ROOT目录上面没有目录，因此ROOT目录是没有名字的。</p>
<p>ROOT目录下的名字bin与之关联的inodenumber是一个目录的inodenumber，包含了在bin目录下的names的列表，names列表包含名字ls和rm。从bin目录下的ls往下走就是文件/bin/ls的数据节点了。数据节点中不会包含文件的名字，名字在文件的目录中保存。</p>
<p>ROOT节点没有名字，因为ROOT节点上面没有目录了。其他目录有名字是因为在这些目录上面还有目录，上层目录包含了其名字。</p>
<h2 id="3-Inodes-Manage-disk-blocks"><a href="#3-Inodes-Manage-disk-blocks" class="headerlink" title="3 Inodes Manage disk blocks"></a>3 Inodes Manage disk blocks</h2><p>每个Uninx文件或目录储存在硬盘的真正数据是由序号化的硬盘数据结构进行管理的，序号化的硬盘数据结构称为Inodes。每个文件和每个目录都分配一个inode。</p>
<p>Unix节点管理每个文件或目录的硬盘存储空间。inode中包含了一系列指针，指向属于那个文件或目录的硬盘块（disk blocks）。文件或目录越大，inode中需要的硬盘块指针就越多。inode还存储文件或目录的属性（权限、所有者、group、size，access/modify times, etc.) ，唯独没有文件或目录的名字。Inodes只有数字、属性和硬盘块–没有名字。名字分开存储，在目录中进行保存。</p>
<h2 id="4-目录节点保存所有的名字"><a href="#4-目录节点保存所有的名字" class="headerlink" title="4. 目录节点保存所有的名字"></a>4. 目录节点保存所有的名字</h2><p>文件有硬盘块用于包含文件数据，目录同样有硬盘块，保存的是名字和inode number的对应关系。</p>
<p>像大多数其他的节点，目录节点也包含了节点的属性信息（权限、所有者等等）和一个或多个硬盘块指针用来存储数据。但是，目录的硬盘块存储的不是文件数据而是目录的数据：名字和inode numbers。</p>
<h2 id="5-多个名字–硬连接"><a href="#5-多个名字–硬连接" class="headerlink" title="5. 多个名字–硬连接"></a>5. 多个名字–硬连接</h2><p>因为</p>
<pre><code>1. 一个唯一数字的inode管理一个文件
2. inode中不会保存文件的名字
3. 目录中保存文件的名字和inodenumber对应关系
</code></pre><p>因此</p>
<pre><code>一个unix文件可以在一个或多个目录中有多个name-and-inode对，从而有多个名字。
</code></pre><h3 id="5-1-Link-Counts-count-names"><a href="#5-1-Link-Counts-count-names" class="headerlink" title="5.1 Link Counts count names"></a>5.1 Link Counts count names</h3><p>硬链接hardlinks：相同inode有多个名字。<br><code>ln</code>命令为目录中已经存在的节点创建一个新的名字。系统在每个inode中维持一个<code>link count</code>的字段，用于对inode指向的names进行计数。<code>rm</code>命令从目录中删除一个名字（hark link），并减少link count。当一个inode的link count减为0以后，inode就没有名字了，inode就会被回收，所有与inode关联的存储和数据都被释放了。</p>
<p>rm命令不是删除文件，而是删除文件的名字。当所有的名字都没有了，系统会删除文件并且释放空间</p>
<h2 id="6-Tracing-Inodes-in-Pathnames"><a href="#6-Tracing-Inodes-in-Pathnames" class="headerlink" title="6. Tracing Inodes in Pathnames"></a>6. Tracing Inodes in Pathnames</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://teaching.idallen.com/cst8207/13w/notes/450_file_system.html" target="_blank" rel="noopener">http://teaching.idallen.com/cst8207/13w/notes/450_file_system.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/04/28/unix-inode-学习/" data-id="ckw1x5qc8004s3mnu0235fa94" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础知识/">基础知识</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Lvs学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/26/Lvs学习笔记/" class="article-date">
  <time datetime="2016-04-26T09:02:01.000Z" itemprop="datePublished">2016-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/26/Lvs学习笔记/">Lvs学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在使用lvs的过程中，我一直担心一个问题：lvs能够抗住最大的并发是多少？当并发非常大的时候，lvs这一台机器的性能会不会变得很差？</p>
<p>我去查看了章文嵩的文章<a href="http://www.linuxvirtualserver.org/zh/lvs1.html" target="_blank" rel="noopener">http://www.linuxvirtualserver.org/zh/lvs1.html</a><br>发现以下几个点：</p>
<h2 id="1-lvs是基于ip层和基于内容请求分发的负载平衡调度。基于ip层和基于内容请求分发两种方式"><a href="#1-lvs是基于ip层和基于内容请求分发的负载平衡调度。基于ip层和基于内容请求分发两种方式" class="headerlink" title="1. lvs是基于ip层和基于内容请求分发的负载平衡调度。基于ip层和基于内容请求分发两种方式"></a>1. lvs是基于ip层和基于内容请求分发的负载平衡调度。基于ip层和基于内容请求分发两种方式</h2><h2 id="2-IP负载均衡技术有三种：VS-NAT，-VS-TUN，VS-DR。"><a href="#2-IP负载均衡技术有三种：VS-NAT，-VS-TUN，VS-DR。" class="headerlink" title="2. IP负载均衡技术有三种：VS/NAT， VS/TUN，VS/DR。"></a>2. IP负载均衡技术有三种：VS/NAT， VS/TUN，VS/DR。</h2><p>基于IP负载调度技术中，当一个TCP连接的初始SYN报文到达时，调度器就选择一台服务器，将报文转发给它。此后通过查发报文的IP和TCP报文头地址，保证此连接的后继报文被转发到该服务器。这样，IPVS无法检查到请求的内容再选择服务器，这就要求后端服务器组提供相同的服务，不管请求被发送到哪 一台服务器，返回结果都是一样的</p>
<h2 id="3-VS-NT-virtual-server-via-Network-Address-Translation"><a href="#3-VS-NT-virtual-server-via-Network-Address-Translation" class="headerlink" title="3. VS/NT virtual server via Network Address Translation"></a>3. VS/NT virtual server via Network Address Translation</h2><p>通过网络地址转换，调度器重写请求报文的目标地址，根据预设的调度算法，将请求分派给后端的真实服务器；真实服务器的响应报文通过调度器时，报文的源地址被重写，再返回给客户，完成整个负载调度过程。</p>
<p>假如结构如下图所示，client要与服务器端建立连接，在lvs层ip包的目的地址被改为node1，那么该TCP连接的初始SYN报文送到node1，node1返回ACK报文给lvs层，lvs将ACK报文的源地址修改为lvs。以后通过查找发报文的IP和TCP报文头地址，保证此连接的后续报文被转发到node1。 如果我们在client通过tcpdump抓包的话，看到的都是client和lvs之间的交互。</p>
<pre><code>                 _ _ _ node1
                /
client---&gt; lvs ------  node2
                \_ _ _ _ node3
</code></pre><h2 id="4-LVS集群的性能"><a href="#4-LVS集群的性能" class="headerlink" title="4. LVS集群的性能"></a>4. LVS集群的性能</h2><p>LVS服务器集群系统具有良好的伸缩性，可支持几百万个并发连接。配置100M网卡，采用VS/TUN或VS/DR调度技术，集群系统的吞吐量可高达1Gbits/s；如配置千兆网卡，则系统的最大吞吐量可接近10Gbits/s。</p>
<p>因为工作在IP层，只用作分发，因此没有流量产生，内存和CPU资源消耗很低，IO性能不会受到大流量的影响</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/04/26/Lvs学习笔记/" data-id="ckw1x5qal000l3mnux5wz7cy0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础知识/">基础知识</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-memcache获取所有的key及value" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/18/memcache获取所有的key及value/" class="article-date">
  <time datetime="2016-04-18T01:32:56.000Z" itemprop="datePublished">2016-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/18/memcache获取所有的key及value/">6. memcache获取所有的key及value</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="0-特别注意："><a href="#0-特别注意：" class="headerlink" title="0. 特别注意："></a>0. 特别注意：</h2><pre><code>通过cachedump命令只能获取1M的数据，无法获取更多的数据。
</code></pre><h2 id="1-命令行来查看memcache的key及取值"><a href="#1-命令行来查看memcache的key及取值" class="headerlink" title="1. 命令行来查看memcache的key及取值"></a>1. 命令行来查看memcache的key及取值</h2><ol>
<li><p>stats slabs  查看有哪些slab</p>
<p> STAT 18:chunk_size 4544<br> STAT 18:chunks_per_page 230<br> STAT 18:total_pages 1<br> STAT 18:total_chunks 230<br> STAT 18:used_chunks 0<br> STAT 18:free_chunks 7<br> STAT 18:free_chunks_end 223<br> STAT 18:mem_requested 18446744073709551411<br> STAT 18:get_hits 777<br> STAT 18:cmd_set 103<br> STAT 18:delete_hits 0<br> STAT 18:incr_hits 0<br> STAT 18:decr_hits 0<br> STAT 18:cas_hits 0<br> STAT 18:cas_badval 0</p>
</li>
<li><p>stats cachedump slab_id limit</p>
<p> 将slab为slab_id的数据展示出来。 limit是展示的个数，如果取值为0， 则不作限制（其实是限制了1m）</p>
</li>
</ol>
<p><a href="http://blog.elijaa.org/2010/12/24/understanding-memcached-stats-cachedump-command/" target="_blank" rel="noopener">http://blog.elijaa.org/2010/12/24/understanding-memcached-stats-cachedump-command/</a><br><a href="http://blog.elijaa.org/2010/05/21/memcached-telnet-command-summary/#slabs_stats" target="_blank" rel="noopener">http://blog.elijaa.org/2010/05/21/memcached-telnet-command-summary/#slabs_stats</a></p>
<h2 id="2-php代码来获取"><a href="#2-php代码来获取" class="headerlink" title="2. php代码来获取"></a>2. php代码来获取</h2><pre><code>&lt;?php
$mcobj = new Memcache();
$mcobj-&gt;addServer(&apos;xxx&apos;,9150);

$to_mcobj = new Memcache();
$to_mcobj-&gt;addServer(&apos;xxx&apos;, 21212);

$allSlabs = $mcobj-&gt;getExtendedStats(&apos;slabs&apos;);
$items    = $mcobj-&gt;getExtendedStats(&apos;items&apos;);
foreach ($allSlabs as $server =&gt; $slabs) {
    foreach ($slabs as $slabId =&gt; $slabMeta) {
        $cdump = $mcobj-&gt;getExtendedStats(&apos;cachedump&apos;, (int)$slabId, 0);
        foreach ($cdump as $keys =&gt; $vals) {
            foreach ((array)$vals as $k =&gt; $v) {
                $real_val = $mcobj-&gt;get($k);
                $set_res = $to_mcobj-&gt;set($k, $real_val);
                error_log(&apos;|slabId=&apos;.$slabId.&apos;set--&apos;.&apos;|key=&apos;.$k.&apos;|val=&apos;.json_encode($real_val).&apos;|res=&apos;.$set_res.&quot;\n&quot;,3,&apos;/tmp/yk.log&apos;);
            }
        }
   }
                                                                                            }
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/04/18/memcache获取所有的key及value/" data-id="ckw1x5qbq003k3mnuswpb98ou" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/memcache/">memcache</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nosql/">nosql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-memcache参考文章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/17/memcache参考文章/" class="article-date">
  <time datetime="2016-04-17T10:00:01.000Z" itemprop="datePublished">2016-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/memcache参考文章/">5. Memcache好的文章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>火丁笔记 Memcache <a href="http://huoding.com/2012/12/30/205" target="_blank" rel="noopener">http://huoding.com/2012/12/30/205</a></li>
<li>mc基础讲解 <a href="http://charlee.li/memcached-001.html" target="_blank" rel="noopener">http://charlee.li/memcached-001.html</a></li>
<li>twemcache <a href="https://github.com/twitter/twemcache" target="_blank" rel="noopener">https://github.com/twitter/twemcache</a></li>
<li>当我谈缓存的时候 我谈些什么 <a href="http://www.tuicool.com/wx/nMfmaeb" target="_blank" rel="noopener">http://www.tuicool.com/wx/nMfmaeb</a></li>
<li>缓存系列无底洞 <a href="http://www.tuicool.com/wx/BjeIJzE" target="_blank" rel="noopener">http://www.tuicool.com/wx/BjeIJzE</a></li>
<li>关于redis与Memcached的一点澄清 <a href="http://www.tuicool.com/wx/bmQFNjm" target="_blank" rel="noopener">http://www.tuicool.com/wx/bmQFNjm</a></li>
<li>PHP使用Memcached扩展的一个坑 <a href="http://www.tuicool.com/articles/qaAnUz" target="_blank" rel="noopener">http://www.tuicool.com/articles/qaAnUz</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/04/17/memcache参考文章/" data-id="ckw1x5qbn003b3mnuusyy22qa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/memcache/">memcache</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nosql/">nosql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-memcache常见问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/17/memcache常见问题/" class="article-date">
  <time datetime="2016-04-17T07:00:01.000Z" itemprop="datePublished">2016-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/memcache常见问题/">4. Memcached常见问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="关于Mc的零散的问题"><a href="#关于Mc的零散的问题" class="headerlink" title="关于Mc的零散的问题"></a>关于Mc的零散的问题</h2><ol>
<li><p>如何实现cas的<br> 很简单，全局维持一个64位的静态变量</p>
<pre><code>uint64_t get_cas_id(void) {
   static uint64_t cas_id = 0;
   return ++cas_id;
}
</code></pre></li>
<li><p>Mc启动时-m指定的最大内存maxMem</p>
<ol>
<li>并不是一启动，就开始分配内存，而是在需要的时候才进行内存分配</li>
<li>所指定的最大内存并不是其最大限制，也就是说mc所分配的内存大于maxMem</li>
</ol>
</li>
<li><p>一开始大量使用某一大小A的chunk，占据大量的内存，那么当大量使用某一个大小B的chunk时，就会导致B chunk所使用的内存很小，极有可能只有一个slab（默认1m）的内存。那么数据就会不断被覆盖，从而导致mc存储的内容频繁失效。</p>
</li>
<li>分配给大小A的内存，不可以给其他大小的chunk使用。这也导致了上面3的问题</li>
<li>memcached对item的过期时间有什么限制？<br> item对象的过期时间最长可以达到30天。memcached把传入的过期时间（时间段）解释成时间点后，一旦到了这个时间点，memcached就把item置为失效状态，这是一个简单但obscure的机制</li>
<li><p>memcached最大能存储多大的单个item？</p>
<p> memcached能存储最大1MB的单个item。如果需要被缓存的数据大于1MB，可以考虑在客户端压缩或拆分到多个key中。</p>
</li>
<li><p>使用不同的客户端库，可以访问到memcached中相同的数据吗？</p>
<p> 从技术上说，是可以的。但是可能会遇到下面三个问题：</p>
<p> 1）不同的库采用不同的方式序列化数据</p>
<p> 举个例子，perl的Cache::Memcached使用Storable来序列化结构复杂的数据（比如hash references, objects等）。其他语言的客户端库很可能不能读取这种格式的数据。如果您要存储复杂的数据并且想被多种客户端库读取，那么您应该以简单的string格式来存储，并且这种格式可以被JSON、XML等外部库解析。</p>
<p> 2）从某个客户端来的数据被压缩了，从另一个客户端来的却没被压缩。</p>
<p> 3）各个客户端库可能使用不同的哈希算法（阶段一哈希）。在连接到多个memcached服务器端的情况下，客户端库根据自身实现的哈希算法把key映射到某台memcached上。正是因为不同的客户端库使用不同的哈希算法，所以被Perl客户端库映射到memcached A的key，可能又会被Python客户端库映射到memcached B，等等。Perl客户端库还允许为每台memcached指定不同的权重（weight），这也是导致这个问题的一个因素</p>
</li>
</ol>
<h2 id="博客中常见问题"><a href="#博客中常见问题" class="headerlink" title="博客中常见问题"></a>博客中常见问题</h2><p><a href="http://huoding.com/2012/12/30/205" target="_blank" rel="noopener">http://huoding.com/2012/12/30/205</a></p>
<ol>
<li>Cache失效后的拥堵问题<ol>
<li>首先，我们可以主动更新Cache。前端程序里不涉及重建Cache的职责，所有相关逻辑都由后端独立的程序（比如CRON脚本）来完成，但此方法并不适应所有的需求。</li>
<li>好在我们还有Gearman这根救命稻草。当需要更新Cache的时候，我们不再直接查询数据库，而是把任务抛给Gearman来处理，当并发量比较大的时候，Gearman内部的优化可以保证相同的请求只查询一次后端数据库，以PHP为例，伪代码大致如下：</li>
</ol>
</li>
</ol>
<pre><code>    &lt;?php

    function query()
    {
        $data = $cache-&gt;get($key);

        if ($cache-&gt;getResultCode() == Memcached::RES_NOTFOUND) {
            $data = $gearman-&gt;do($function, $workload, $unique);
            $cache-&gt;set($key, $data, $expiration);
        }

        return $data;
    }

    ?&gt;

说明：如果多个并发请求的$unique参数一样，那么实际上Gearman只会请求一次。
</code></pre><ol start="2">
<li><p>Multiget的无底洞问题</p>
<p> Facebook在Memcached的实际应用中，发现了Multiget无底洞问题，具体表现为：出于效率的考虑，很多Memcached应用都已Multiget操作为主，随着访问量的增加，系统负载捉襟见肘，遇到此类问题，直觉通常都是通过增加服务器来提升系统性能，但是在实际操作中却发现问题并不简单，新加的服务器好像被扔到了无底洞里一样毫无效果。</p>
</li>
<li><p>客户端的Hash算法<br><a href="http://www.last.fm/user/RJ/journal/2007/04/10/rz_libketama_-_a_consistent_hashing_algo_for_memcache_clients" target="_blank" rel="noopener">http://www.last.fm/user/RJ/journal/2007/04/10/rz_libketama_-_a_consistent_hashing_algo_for_memcache_clients</a></p>
</li>
</ol>
<p>##适合Mc的业务场景</p>
<p>1）如果网站包含了访问量很大的动态网页，因而数据库的负载将会很高。由于大部分数据库请求都是读操作，那么memcached可以显著地减小数据库负载。</p>
<p>2）如果数据库服务器的负载比较低但CPU使用率很高，这时可以缓存计算好的结果（ computed objects ）和渲染后的网页模板（enderred templates）。</p>
<p>3）利用memcached可以缓存session数据、临时数据以减少对他们的数据库写操作。</p>
<p>4）缓存一些很小但是被频繁访问的文件。</p>
<p>5）缓存Web ‘services’（非IBM宣扬的Web Services）或RSS feeds的结果.。</p>
<h2 id="不适合Mc的业务场景"><a href="#不适合Mc的业务场景" class="headerlink" title="不适合Mc的业务场景"></a>不适合Mc的业务场景</h2><p>1）缓存对象的大小大于1MB</p>
<p>  Memcached本身就不是为了处理庞大的多媒体（large media）和巨大的二进制块（streaming huge blobs）而设计的。</p>
<p>2）key的长度大于250字符</p>
<p>3）虚拟主机不让运行memcached服务</p>
<p>  如果应用本身托管在低端的虚拟私有服务器上，像vmware, xen这类虚拟化技术并不适合运行memcached。Memcached需要接管和控制大块的内存，如果memcached管理的内存被OS或 hypervisor交换出去，memcached的性能将大打折扣。</p>
<p>4）应用运行在不安全的环境中</p>
<p>   Memcached 未提供任何安全策略，仅仅通过telnet就可以访问到memcached。如果应用运行在共享的系统上，需要着重考虑安全问题。</p>
<p>5）业务本身需要的是持久化数据或者说需要的应该是database的读数据</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://blog.mimvp.com/2015/01/memcache-cache-bulk-delete-scheme/" target="_blank" rel="noopener">http://blog.mimvp.com/2015/01/memcache-cache-bulk-delete-scheme/</a> mc的telnet操作 查看<br>客户端的一致性hash <a href="http://www.last.fm/user/RJ/journal/2007/04/10/rz_libketama_-_a_consistent_hashing_algo_for_memcache_clients" target="_blank" rel="noopener">http://www.last.fm/user/RJ/journal/2007/04/10/rz_libketama_-_a_consistent_hashing_algo_for_memcache_clients</a><br>火丁的mc <a href="http://huoding.com/2012/12/30/205" target="_blank" rel="noopener">http://huoding.com/2012/12/30/205</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/04/17/memcache常见问题/" data-id="ckw1x5qbp003f3mnuitdv681z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/memcache/">memcache</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nosql/">nosql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-memcached详细解释" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/17/memcached详细解释/" class="article-date">
  <time datetime="2016-04-17T06:00:01.000Z" itemprop="datePublished">2016-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/memcached详细解释/">3. Memcached详细解释</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h2><ol>
<li>数据存储：保存数据A到mc时，需要先分配空间Item给数据A。</li>
<li>数据查找：对于获取数据，通过Hash表进行查找。</li>
<li>数据过期：通过LRU队列进行过期处理</li>
</ol>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>为了解释是如何分配空间Item的，那么就要先讲一下Mc的整体结构。</p>
<p>Mc声明了一个slabclass_t的结构体类型，一个slabclass_t类型数组slabclass(全局变量）。数组的每一个元素是一个slab链表。每一个slab链表所分配的内存大小不同。</p>
<p>我们在启动的时候就还会看到这个</p>
<pre><code>memcached -p 11211 -m 44m -vv -f1.25
slab class   1: chunk size        96 perslab   10922
slab class   2: chunk size       120 perslab    8738
....
slab class  12: chunk size      1184 perslab     885
.... 
slab class  41: chunk size    771184 perslab       1
slab class  42: chunk size   1048576 perslab       1
</code></pre><p>如何分配</p>
<ol>
<li><p>在do_item_alloc中获取item</p>
<ol>
<li>首先根据LRU队列，选择过期的item，返回该item，使用该item</li>
<li>如果都没有过期，那么分配新的slab。实际上就是分配新的page，然后根据chunk size进行内存切割。选择一个item，返回该item。【注意】即使启动参数-m 44M限定的最大内存使用完毕，如果某一个slabclass没有slab，那么依然可以分配一个page，就会出现内存大于44m的情况。在do_slabs_newslab函数中</li>
<li><p>如果都没有过期，并且不能够分配新的slab，那么就会强行霸占没有过期的item。返回该item</p>
<p>有一篇大牛的文章（2009年）中提到了相同的问题。 <a href="http://timyang.net/data/Memcached-lru-evictions/" target="_blank" rel="noopener">http://timyang.net/data/Memcached-lru-evictions/</a> </p>
</li>
</ol>
</li>
<li><p>场景：<br> 我以下面的方式启动</p>
<pre><code>memcached -p 11211 -m 44m -vv -f1.25
</code></pre></li>
</ol>
<p>下面的方式写入数据</p>
<pre><code>for (i = 0; i &lt; 10922 * 44m; i++)
{
    set( i, &apos;1&apos;, 0); // 写入长度为1，0代表过期时间
}
</code></pre><p>这样的话44m空间全部用完。当我们再次写入长度为1000的，将会写入到 slab class 12中。但是我们知道44m空间，已经用完，但实际上我们发现slab class 12可以写入。这儿刚好验证了【注意】中的内容</p>
<p>##LRU队列：</p>
<p>上面讲述了如何分配item，那么分配以后的item如何进行管理和查找呢，就需要LRU队列和Hash表。LRU队列管理Item，LRU队列是一个双向链表，个数与subclass的个数相同。同一个subclass的所有item都归同一个LRU队列管理。</p>
<p>在item.c中</p>
<pre><code>static item *heads[LARGEST_ID];
static item *tails[LARGEST_ID];
static crawler crawlers[LARGEST_ID];
static itemstats_t itemstats[LARGEST_ID];
static unsigned int sizes[LARGEST_ID];
</code></pre><p>通过LRU队列的操作，可以更清楚明白LRU队列的作用：</p>
<ol>
<li>插入：插入到LRU队列的头部</li>
<li>更新：在LRU队列中，排的越靠后就认为越少被使用的item，那么其被淘汰的概率就越大，所以新的item（访问时间新）要排在不那么新的item前面，所以插入在头部是必须的。<br>do_item_update就是先把item从LRU队列中删除，再插入LRU队列，更新time字段（time表示最后访问时间）</li>
</ol>
<h2 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h2><ol>
<li>当item分配并赋值以后，需要注册到LRU队列和Hash表中。注册到Hash表以后，将方便我们进行查询。利用item的数据部分（data字段）和键长（nkey字段）进行hash。Hash表的结构是常见的拉链结构。</li>
<li>Hash表的扩展<br> Hash表的长度并不是不变的。当Hash表中的Item数量达到了Hash表长度的1.5倍时，那么就会扩展哈希表的长度，然后重新进行Hash<br> 由于这一步耗时，是通过专门的线程 迁移线程进行的。</li>
<li>Hash表与Item的关系<br> Item在分配以后，会通过do_item_link do_\item_unlink将Item注册到Hash表和LRU队列中</li>
</ol>
<h2 id="过期失效处理"><a href="#过期失效处理" class="headerlink" title="过期失效处理"></a>过期失效处理</h2><ol>
<li><p>一个item在两种情况下会过期失效</p>
<pre><code>item的expire时间戳到了
用户使用flush_all将全部item变成过期失效
</code></pre></li>
<li><p>懒惰删除<br> 只有在进行get时，才会进行判断，然后进行删除</p>
</li>
</ol>
<h2 id="重要原则："><a href="#重要原则：" class="headerlink" title="重要原则："></a>重要原则：</h2><ol>
<li>按照预定大小，将分配的slab分割成特定长度的块</li>
<li>分配给某个slab的内存不能给其他slab使用。已经分配出去的slab不会被回收或者重新分配，因为这种原理，也就出现了【注意】里面所描述的情况</li>
<li>item里面不仅仅存放缓存对象的value，还包括key，expire，time，flag等详细信息。其中time表示最后一次访问时间，expire表示过期时间。</li>
</ol>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>场景1：<br>    一开始大量长度为1kb，全部占用，之后存储大量10kb，只有一个slab，那么10kb大量访问，那么就会出现没到过期时间，数据全部失效。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/04/17/memcached详细解释/" data-id="ckw1x5qbm00393mnugpv35xxw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/memcache/">memcache</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nosql/">nosql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-memcache启动及telnet命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/17/memcache启动及telnet命令/" class="article-date">
  <time datetime="2016-04-17T05:00:01.000Z" itemprop="datePublished">2016-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/memcache启动及telnet命令/">2. Memcache启动及Telnet命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-Memcached启动选项"><a href="#1-Memcached启动选项" class="headerlink" title="1. Memcached启动选项"></a>1. Memcached启动选项</h2><ol>
<li>“p:”   小写p，memcached监听的tcp端口。默认端口为11211, 该选项的参数赋值给settings.port</li>
<li>“m:”  小写m。memcached能够使用的最大内存值，默认是64MB。参数单位为MB。该参数赋值给settings.maxbytes</li>
<li>“v”    小写v。输出memcached运行时的一些信息。-v -vv -vvv输出的信息依次增加。该选项会增加settings.verbose的值</li>
<li>“d”    以守护进程的形式运行memcached</li>
<li>“f:”    item的扩容因子。默认值为1.25。该选项的参数值可以是小数但必须大于1.0。该选项参数将赋值给settings.factor</li>
<li>“n:”   设置最小的item能存储多少字节的数据。该选项参数赋值给settings.chunk_size.</li>
<li>“C:”  大写C。memcached默认是使用CAS的，本选项是禁用CAS。本选项会将settings.use_cas赋值为false</li>
<li>“B:”  memcached支持文本协议和二进制协议。该选项的参数用于指定使用的协议。默认情况下是根据客户端的命令而自动判断(也叫协商)，参数只能取auto、binary、ascii这三个字符串值。将参数将赋值给settings.binding_protocol</li>
<li>“I:”   大写i。slab分配器中，每一个页的大小。这个选项的参数是一个数值表示页的大小。默认单位是B也可以在数值后面带K或者M(大小写都行)，表示KB和MB。页的大小小于1KB或者大于128MB都是不允许的。不推荐使用该选项。本选项参数会赋值给settings.item_size_max</li>
<li>“P:”  大写P。指定pid文件。存放当前mc进程的pid</li>
<li>“t:”    该选项的参数用于指定worker线程的个数，不建议超过64个。如果不设置该选项默认有4个线程。该参数会赋值给settings.num_threads</li>
<li>“c:”   小写c。最多允许多少个客户端同时在线(这个值不等价于listen函数的第二个参数)，该选项和后面的b选项有所不同。 默认值为1024个。该选项参数赋值给settings.maxconns。</li>
<li>“u:”  小写u。当以root用户启动memcached的时候需要指定memcached的所属用户，其他用户启动memcached不需要此选项</li>
</ol>
<p>举例</p>
<pre><code>memcached -d -p 11211 -P /var/run/memcached.pid -c 4096 -t 4 -m 1024 -u root -v
</code></pre><h2 id="2-一些高级telnet命令"><a href="#2-一些高级telnet命令" class="headerlink" title="2. 一些高级telnet命令"></a>2. 一些高级telnet命令</h2><p>stats slabs<br>查看 memcache的slab class的状态，能够知道数据分布的范围，每个slab有多少页</p>
<p>stats cachedump 1 0<br>第三个字段是slab的标识<br>第四个字段表示拉取的该slab下的数据，第四个字段0表示不受限制（但实际上只会拉取1M的数据， 并不会全拉）</p>
<h2 id="3-基础Memcached命令"><a href="#3-基础Memcached命令" class="headerlink" title="3. 基础Memcached命令"></a>3. 基础Memcached命令</h2><p>Memcached 有 4 种类型的命令:</p>
<pre><code>1. 存储命令(set/add /replace/append/prepend)
指示服务器储存一些由键值标识的 数据。客户端发送一行命令,后面跟着数据区块;然后,客户端等待接收服务器回传 的命令行,指示成功与否。
2. 读取命令(get/bget/gets)指示服务器返回与所给键值相符合的数据(一个请求中右 一个或多个键值)。客户端发送一行命令,包括所有请求的键值;服务器每找到一项内容,都会发送回客户端一行关于这项内容的信息,紧跟着是对应的数据区块;直到服务器以一行“END”回应命令结束。
3. 状态命令(stat)被用于查询服务器的运行状态和其他内部数据。 
4. 其他命令,如 flush_all,version,quit 等。


COMMAND    DESCRIPTION    EXAMPLE
get    Reads a value    get mykey
set    Set a key unconditionally    set mykey 0 60 5
add    Add a new key    add newkey 0 60 5
replace    Overwrite existing key    replace key 0 60 5
append    Append data to existing key    append key 0 60 15
prepend    Prepend data to existing key    prepend key 0 60 15
incr    Increments numerical key value by given number    incr mykey 2
decr    Decrements numerical key value by given number    decr mykey 5
delete    Deletes an existing key    delete mykey
flush_all    Invalidate specific items immediately    flush_all
Invalidate all items in n seconds    flush_all 900
stats    Prints general statistics    stats
Prints memory statistics    stats slabs
Prints memory statistics    stats malloc
Print higher level allocation statistics    stats items
stats detail
stats sizes
Resets statistics    stats reset
version    Prints server version.    version
verbosity    Increases log level    verbosity
quit    Terminate telnet session    quit
</code></pre><h3 id="stats命令详解"><a href="#stats命令详解" class="headerlink" title="stats命令详解"></a>stats命令详解</h3><pre><code>pid    memcache服务器的进程ID
uptime    服务器已经运行的秒数
time    服务器当前的unix时间戳
version    memcache版本
pointer_size    当前操作系统的指针大小（32位系统一般是32bit）
rusage_user    进程的累计用户时间
rusage_system    进程的累计系统时间
curr_items    服务器当前存储的items数量
total_items    从服务器启动以后存储的items总数量
bytes    当前服务器存储items占用的字节数
curr_connections    当前打开着的连接数
total_connections    从服务器启动以后曾经打开过的连接数
connection_structures    服务器分配的连接构造数
cmd_get    get命令（获取）总请求次数
cmd_set    set命令（保存）总请求次数
get_hits    总命中次数
get_misses    总未命中次数
evictions    为获取空闲内存而删除的items数（分配给memcache的空间用满后需要删除旧的items来得到空间分配给新的items）
bytes_read    总读取字节数（请求字节数）
bytes_written    总发送字节数（结果字节数）
limit_maxbytes    分配给memcache的内存大小（字节）
threads    当前线程数
</code></pre><p>参考文章<br><a href="http://blog.mimvp.com/2015/01/memcache-start-telnet-command-xiangjie/" target="_blank" rel="noopener">http://blog.mimvp.com/2015/01/memcache-start-telnet-command-xiangjie/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/04/17/memcache启动及telnet命令/" data-id="ckw1x5qbo003d3mnuenxglyfw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/memcache/">memcache</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nosql/">nosql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-memcache概述" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/17/memcache概述/" class="article-date">
  <time datetime="2016-04-17T04:00:01.000Z" itemprop="datePublished">2016-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/memcache概述/">1. memcache概述</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>memcached的特征<br> memcached 作为高速运行的分布式缓存服务器,具有以下的特点。<ol>
<li>协议简单</li>
<li>基于 libevent 的事件处理 </li>
<li>内置内存存储方式</li>
<li>memcached 不互相通信的分布式<br>mc是分布式缓存服务器，完全取决于客户端的实现</li>
</ol>
</li>
</ol>
<h2 id="Memcache的内存分配"><a href="#Memcache的内存分配" class="headerlink" title="Memcache的内存分配"></a>Memcache的内存分配</h2><ol>
<li>基本概念<ol>
<li>Page<br>分配给Slab的内存空间,默认是 1MB。<br>分配给Slab之后根据slab的大小切分成chunk。</li>
<li>Chunk 用于缓存记录的内存空间。 </li>
<li>Slab Class：特定大小的Chunk数组</li>
</ol>
</li>
<li>保存<br> memcached 根据收到的数据的大小,选择最适合数据大小的 slab。 memcached 中保存着 slab 内空闲 chunk 的列表,根据该列表选择 chunk, 然后 将数据缓存于其中。</li>
<li><p>调优<br> 使用Growth Factor进行调优，默认是1.25</p>
</li>
<li><p>小结</p>
<p> 将固定大小的内存（page）分割成各种尺寸的块（chunk）<br> 把尺寸相同的块分组，叫做slab classes</p>
</li>
</ol>
<h2 id="Memcache的过期"><a href="#Memcache的过期" class="headerlink" title="Memcache的过期"></a>Memcache的过期</h2><p> memcached不会释放已分配的内存。记录超时后,客户端就无法再 看见该记录(invisible,透明), 其存储空间即可重复使用。<br> Lazy Expiration<br> memcached 内部不会监视记录是否过期,而是在 get 时查看记录的时间戳,检查 记录是否过期。 这种技术被称为 lazy(惰性)expiration。因此,memcached 不会在过期监视上耗费 CPU 时间。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/04/17/memcache概述/" data-id="ckw1x5qbp003h3mnukzrhpxpv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/memcache/">memcache</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nosql/">nosql</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/7/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/9/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Laravel/">Laravel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/composer/">composer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/">cpp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp-lib/">cpp-lib</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/faiss/">faiss</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-source-code/">go.source.code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/laravel/">laravel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/">mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/machine-learning/">machine-learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memcache/">memcache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nosql/">nosql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/octave/">octave</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php源码学习/">php源码学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/">spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tcp/">tcp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thrift/">thrift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础知识/">基础知识</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Laravel/" style="font-size: 10px;">Laravel</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/composer/" style="font-size: 10px;">composer</a> <a href="/tags/cpp/" style="font-size: 12.22px;">cpp</a> <a href="/tags/cpp-lib/" style="font-size: 10px;">cpp-lib</a> <a href="/tags/elasticsearch/" style="font-size: 11.11px;">elasticsearch</a> <a href="/tags/faiss/" style="font-size: 10px;">faiss</a> <a href="/tags/git/" style="font-size: 12.22px;">git</a> <a href="/tags/go-source-code/" style="font-size: 10px;">go.source.code</a> <a href="/tags/golang/" style="font-size: 16.67px;">golang</a> <a href="/tags/laravel/" style="font-size: 11.11px;">laravel</a> <a href="/tags/linux/" style="font-size: 14.44px;">linux</a> <a href="/tags/mac/" style="font-size: 13.33px;">mac</a> <a href="/tags/machine-learning/" style="font-size: 10px;">machine-learning</a> <a href="/tags/memcache/" style="font-size: 15.56px;">memcache</a> <a href="/tags/mysql/" style="font-size: 13.33px;">mysql</a> <a href="/tags/nginx/" style="font-size: 13.33px;">nginx</a> <a href="/tags/nosql/" style="font-size: 18.89px;">nosql</a> <a href="/tags/octave/" style="font-size: 10px;">octave</a> <a href="/tags/php/" style="font-size: 20px;">php</a> <a href="/tags/php源码学习/" style="font-size: 17.78px;">php源码学习</a> <a href="/tags/redis/" style="font-size: 12.22px;">redis</a> <a href="/tags/spark/" style="font-size: 12.22px;">spark</a> <a href="/tags/tcp/" style="font-size: 10px;">tcp</a> <a href="/tags/thrift/" style="font-size: 13.33px;">thrift</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/基础知识/" style="font-size: 15.56px;">基础知识</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/11/16/Spark-DataSource-Hive Tables/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/11/14/分布式-事务/">分布式-事务</a>
          </li>
        
          <li>
            <a href="/2019/04/29/golang继承/">golang继承</a>
          </li>
        
          <li>
            <a href="/2019/04/28/spark-Quick-Start/">spark quick start</a>
          </li>
        
          <li>
            <a href="/2019/03/20/golang-包导入/">golang包导入</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Keything<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>