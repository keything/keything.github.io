<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Keything的日志</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Keything的日志">
<meta property="og:url" content="http://keything.github.io/page/4/index.html">
<meta property="og:site_name" content="Keything的日志">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Keything的日志">
  
    <link rel="alternate" href="/atom.xml" title="Keything的日志" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Keything的日志</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://keything.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-C-编译错误汇总" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/04/C-编译错误汇总/" class="article-date">
  <time datetime="2017-04-04T08:38:24.000Z" itemprop="datePublished">2017-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/04/C-编译错误汇总/">C++编译错误汇总</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>出现 undefined reference to <code>typeinfo for xxxx</code></li>
</ol>
<p>在定义抽象函数的时候 virtual函数的定义有问题。</p>
<p>You must either provide a definition for virtual functions in your base class or declare them pure：</p>
<pre><code>class Accel {
public:
    virtual void initialize(void) = 0;        //either pure virtual
    virtual void measure(void) = 0; 
    virtual void calibrate(void) {};          //or implementation 
    virtual const int getFlightData(byte) {};
};
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2017/04/04/C-编译错误汇总/" data-id="ckw1x5qab00093mnujhes1s1s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-自动化测试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/31/自动化测试/" class="article-date">
  <time datetime="2017-03-31T15:14:55.000Z" itemprop="datePublished">2017-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/31/自动化测试/">自动化测试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>在频繁迭代中，通过自动化测试可以减少代码bug，保证代码能够按照预期跑通。自动化测试一开始是帮你找bug，后续的角色是进行安全检查。</p>
<p>自动化测试需要包括哪些内容呢？我觉得需要包含单元测试、集成测试、接口测试。</p>
<h3 id="简要概括单元测试、集成测试、接口测试"><a href="#简要概括单元测试、集成测试、接口测试" class="headerlink" title="简要概括单元测试、集成测试、接口测试"></a>简要概括单元测试、集成测试、接口测试</h3><ul>
<li>单元测试：抛开所有外部依赖，验证单个函数的功能是否符合预期。</li>
<li>集成测试：在单元测试的基础上，测试多个函数组合起来是否按照预期。</li>
<li>接口测试：通过单元测试和集成测试验证了小功能，还需要通过接口测试验证整个链路是否按照预期执行。</li>
</ul>
<h2 id="自动化测试之单元测试"><a href="#自动化测试之单元测试" class="headerlink" title="自动化测试之单元测试"></a>自动化测试之单元测试</h2><h3 id="1-单元测试的FIRST准则"><a href="#1-单元测试的FIRST准则" class="headerlink" title="1. 单元测试的FIRST准则"></a>1. 单元测试的FIRST准则</h3><ul>
<li>Fast：测试不能每跑一次都要耗费大量的时间。</li>
<li>Independent： 测试与测试之间不应该存在依赖关系。</li>
<li>Repeatable： 测试应该在任何环境下都能运行，不论是生产环境、测试环境，或者是在家里的笔记本电脑上。</li>
<li>Self-Validating 测试的结果应该是显而易见的，不应该是靠人去查看它的输出才能判断测试的成功与失败，即使用断言来判断实际是否满足预期。</li>
<li>Timely： 测试需要在正式代码之前就写好。</li>
</ul>
<h3 id="2-单元测试的一些其他要求"><a href="#2-单元测试的一些其他要求" class="headerlink" title="2. 单元测试的一些其他要求"></a>2. 单元测试的一些其他要求</h3><ul>
<li>单元测试Case就是文档，因为说明了输入和输出</li>
<li>每个case只测试单一函数的单一行为</li>
<li>测试用例的名称要清晰表明测试目的，如TestCreateOrder_Failed_Pid_NotExist </li>
<li>在编写正式代码之前，必须写出其相对应的单元测试；<br>这就是说一定要先写出一个单元测试（因为还没有编写正式代码，所以它肯定会失败），再编写正式代码。</li>
<li>只要一个单元测试失败了，就不要再编写任何更多的单元测试了；<br>而是要去编写相应的的可以使之通过的正是代码，编译失败也算；</li>
<li>只要正式代码可以使单元测试通过，就不要再编写更多的正式代码了；<br>正式代码需要满足的唯一目标就是通过单元测试，只要通过单元测试，就表示我们此部分的代码已经写完了。</li>
</ul>
<h3 id="3-单元测试的三段式"><a href="#3-单元测试的三段式" class="headerlink" title="3. 单元测试的三段式"></a>3. 单元测试的三段式</h3><p>单元测试的三段式：</p>
<ul>
<li>准备测试数据。</li>
<li>对测试数据进行操作。</li>
<li>进行判定。</li>
</ul>
<h3 id="3-单元测试的三大模块"><a href="#3-单元测试的三大模块" class="headerlink" title="3. 单元测试的三大模块"></a>3. 单元测试的三大模块</h3><ul>
<li>驱动模块：相当于所测模块的主程序。它接收测试数据，把这些测试数据传送给被测模块，最后再输出实测结果。</li>
<li>桩模块。由被测模块调用，用以代替由被测单元所调用的模块的功能，返回适当的数据或进行适当的操作使被测单元能继续运行下去，同时还要进行一定的数据处理，如打印入口和返回等，以便检验被测模块与其下级模块的接口</li>
<li>被测系统 SUT （System Under Test）</li>
</ul>
<h3 id="4-测试替身-Test-Double"><a href="#4-测试替身-Test-Double" class="headerlink" title="4. 测试替身 Test Double"></a>4. 测试替身 Test Double</h3><p>前面提到了测试替身。</p>
<p>替身、依赖注入<br>+参数传入<br>+构造函数<br>+set函数</p>
<p>设计决定一切</p>
<p>测试替身有很多种：</p>
<ol>
<li>mock是测试替身的一种，复杂的一种</li>
<li>一般用mock来指定一个测试替身</li>
<li>为什么用mock object</li>
<li>返回一个数据</li>
<li>返回一个true/false 状态，可以使用一个测试替身</li>
<li>使用mock？是否按照预定顺序，是否执行？</li>
</ol>
<p>测试与实现的顺序：<br>先写测试在写实现</p>
<h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><h3 id="1-持续集成Continuous-integration"><a href="#1-持续集成Continuous-integration" class="headerlink" title="1. 持续集成Continuous integration"></a>1. 持续集成Continuous integration</h3><ul>
<li>定义：频繁地（一天多次）将代码集成到主干。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成</li>
</ul>
<h3 id="2-持续集成的整个过程分为几步："><a href="#2-持续集成的整个过程分为几步：" class="headerlink" title="2. 持续集成的整个过程分为几步："></a>2. 持续集成的整个过程分为几步：</h3><ul>
<li>代码提交</li>
<li>代码测试：代码仓库对commit操作配置钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。</li>
<li>构建：</li>
<li>第二轮测试：进行全面测试，包含单元测试、集成测试、全链路接口测试。以自动化为主，少数无法自动化的测试用例需要人工跑</li>
<li>部署</li>
<li>回滚</li>
</ul>
<p>参考：</p>
<p><a href="https://codeship.com/continuous-integration-essentials" target="_blank" rel="noopener">https://codeship.com/continuous-integration-essentials</a></p>
<p><a href="http://codecloud.net/10516.html" target="_blank" rel="noopener">http://codecloud.net/10516.html</a><br><a href="http://www.uml.org.cn/test/201107085.asp" target="_blank" rel="noopener">http://www.uml.org.cn/test/201107085.asp</a><br><a href="http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd" target="_blank" rel="noopener">http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2017/03/31/自动化测试/" data-id="ckw1x5qcf005e3mnuy8qrxprg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spark-learn" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/31/spark-learn/" class="article-date">
  <time datetime="2017-03-31T15:07:37.000Z" itemprop="datePublished">2017-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/31/spark-learn/">spark_learn</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="RDD介绍"><a href="#RDD介绍" class="headerlink" title="RDD介绍"></a>RDD介绍</h2><p>在Spark集群背后，有一个非常重要的分布式数据架构，即弹性分布式数据集（resilient distributed dataset, RDD)，它是逻辑集中的实体，在集群中的多台机器上进行数据分区。通过多台机器上不同RDD分区的控制，就能够减少机器之间的数据重排（data shuffling）。Spark提供了<code>partitionBy</code>运算符，能够通过集群中多台机器对原始RDD进行数据再分配来创建一个新的RDD。</p>
<p>RDD是Spark的核心数据结构，通过RDD的依赖关系形成Spark的调度顺序。通过对RDD的操作形成整个Spark程序。</p>
<p>###一、 RDD的两种创建方式</p>
<h4 id="1-代码中并行化一个已经存在的集合-Parallelized-Collections"><a href="#1-代码中并行化一个已经存在的集合-Parallelized-Collections" class="headerlink" title="1. 代码中并行化一个已经存在的集合(Parallelized Collections)"></a>1. 代码中并行化一个已经存在的集合(Parallelized Collections)</h4><pre><code>从已经存在集合中创建

    data = [1, 2, 3, 4, 5]
    distData = sc.parallelize(data)


集合并行化（parallel collections）的一个重要参数是：集合切分的分区数。Spark会为集群中每个分区运行一个任务。一般是集群中每个CPU有2-4个分区。通常，Spark会根据集群情况自动设置分区的数量。当然，你也可以手工输入一个数量，作为parallelize的第二个参数（如 `sc.parallelize(data, 10)`)
一旦创建以后，数据就可以并行处理了。
</code></pre><h4 id="2-从外部存储系统中创建。如共享文件系统，HDFS，HBASE，HIVE或其他提供Hadoop输入格式的数据来源"><a href="#2-从外部存储系统中创建。如共享文件系统，HDFS，HBASE，HIVE或其他提供Hadoop输入格式的数据来源" class="headerlink" title="2. 从外部存储系统中创建。如共享文件系统，HDFS，HBASE，HIVE或其他提供Hadoop输入格式的数据来源"></a>2. 从外部存储系统中创建。如共享文件系统，HDFS，HBASE，HIVE或其他提供Hadoop输入格式的数据来源</h4><p>可以使用SparkContext’s textFile方法创建文本文件RDDs。这个方法使用文件的URL（或者机器的本地文件, hdfs:://, s3n://等等），并作为行的集合进行读取。<br>从Hadoop获取的方式：</p>
<pre><code>sc.textFile(&quot;your_hdfs_path&quot;)
</code></pre><p>从Hive中获取：</p>
<pre><code>import org.apache.spark.sql.SQLContext
val hc = new org.apache.spark.sql.hive.HiveContext(sc)
val df = hc.sql(&quot;show databases&quot;)
df.show
</code></pre><p>####使用spark读取文件的注意事项：<br>如果使用本地文件系统，If using a path on the local filesystem, the file must also be accessible at the same path on worker nodes. Either copy the file to all workers or use a network-mounted shared file system.</p>
<p>所有spark的基于文件的输入方法，包含<code>textFile</code>，支持目录、压缩文件、wildcards等。例如，可以使用<code>textFile(&quot;/my/directory&quot;)</code>, <code>textFile(&quot;/my/directory/*.txt&quot;)</code>, <code>textFile(&quot;/my/directory/*.gz&quot;)</code>.</p>
<p><code>textFile</code>方法可以有第二个参数用于控制分区的个数。默认spark会为每一个文件block创建一个分区（hdfs中默认block是64MB），但是你可以传递更大的分区数。注意，分区数不能少于block数量。</p>
<p>除了<code>textFile</code>， spark的python api还支持许多其他格式：</p>
<ul>
<li><code>SparkContext.wholeTextFiles</code>,</li>
<li><code>RDD.saveAsPickleFile</code>, <code>SparkContext.pickleFil</code></li>
<li>SequenceFile and Hadoop Input/Output Formats</li>
</ul>
<p>###二、 RDD的操作<br>RDDs支持两种类型的操作：transformations（从已经存在的Rdd创建一个新的数据集合）和 actions（对数据集合运算后返回一个值）。例如：<code>map</code>是一个传入每个数据集合的元素并返回一个新的RDD的transformations。另一方面，<code>reduce</code>是一个action：使用一个函数对RDD中所有元素进行聚合，并返回一个最后结果。</p>
<p>在Spark中所有的transformations都是惰性的，并不会马上计算。它只是记录了在base dataset上应用了哪些transformations。只有在有actions的时候才会真的计算。这样的设计使得spark的运行更加高效。</p>
<p>默认，每次进行actions的时候，已经转换过的RDD还需要重新计算。当然，你可以使用<code>persist(or cache)</code>方法进行持久化。</p>
<ol>
<li>分类</li>
</ol>
<pre><code>+ Transformation和Action两个维度
+ 在Transformation维度会细分为：Value数据类型和Key-value对数据类型。Value类型封装在RDD类中直接使用，Key-Value对数据类型封装在PairRDDFunctions类中，用户需要引入`import org.apache.spark.SparkContext._`才能够使用。
</code></pre><h3 id="三、RDD的Value型Transformation操作详细说明"><a href="#三、RDD的Value型Transformation操作详细说明" class="headerlink" title="三、RDD的Value型Transformation操作详细说明"></a>三、RDD的Value型Transformation操作详细说明</h3><h4 id="输入分区与输出分区是一对一型"><a href="#输入分区与输出分区是一对一型" class="headerlink" title="输入分区与输出分区是一对一型"></a>输入分区与输出分区是一对一型</h4><ol>
<li><p>map</p>
<p> 将函数应用于Rdd的每个元素，并返回结果作为一个新的RDD。<br> Applies a transformation function on each item of the RDD and returns the result as a new RDD.</p>
</li>
</ol>
<pre><code>举例：


    &gt;&gt;&gt; data = [&quot;hello&quot;, &quot;world12&quot;, &quot;nihao&quot;]
    &gt;&gt;&gt; rdd = sc.parallelize(data)
    &gt;&gt;&gt; maprdd = rdd.map(lambda x: len(x))
    &gt;&gt;&gt; maprdd.collect()
        [5, 7, 5]
    &gt;&gt;&gt; total=maprdd.reduce(lambda a,b:a+b)

    &gt;&gt;&gt; print total
        17
</code></pre><p>   实例2：</p>
<pre><code>&gt;&gt;&gt; m = sc.parallelize([&quot;dog&quot;, &quot;tiger&quot;, &quot;lion&quot;])
&gt;&gt;&gt; n = m.map(lambda x: (x, 1))
&gt;&gt;&gt; n.collect()
[(&apos;dog&apos;, 1), (&apos;tiger&apos;, 1), (&apos;lion&apos;, 1)]
</code></pre><ol start="2">
<li><p>flatMap</p>
<p> 与map类似，但是允许在映射中释放多个元素。</p>
<p> 举例：</p>
<pre><code>&gt;&gt;&gt; data = [&quot;hello&quot;, &quot;world12&quot;, &quot;nihao&quot;]
&gt;&gt;&gt; rdd.map(lambda x: (x,x)).collect()
    [(&apos;hello&apos;, &apos;hello&apos;), (&apos;world12&apos;, &apos;world12&apos;), (&apos;nihao&apos;, &apos;nihao&apos;)]
&gt;&gt;&gt; rdd.flatMap(lambda x: (x,x)).collect()
    [&apos;hello&apos;, &apos;hello&apos;, &apos;world12&apos;, &apos;world12&apos;, &apos;nihao&apos;, &apos;nihao&apos;]
</code></pre></li>
<li><p>mapPartitions</p>
</li>
<li>glom</li>
</ol>
<h4 id="输入分区与输出分区多对一型"><a href="#输入分区与输出分区多对一型" class="headerlink" title="输入分区与输出分区多对一型"></a>输入分区与输出分区多对一型</h4><ol>
<li><p>union</p>
<p> 执行标准集合操作：A union B。并不进行去重操作，保存所有元素。如果想去重，可以使用distince()。</p>
<pre><code>&gt;&gt;&gt; datamm = sc.parallelize([1,2,3,4,5]).union(sc.parallelize([4,5,6,7,8]))
&gt;&gt;&gt; datamm.collect()
    [1, 2, 3, 4, 5, 4, 5, 6, 7, 8]
</code></pre></li>
<li><p>cartesian</p>
<p> 对两个RDD内所有元素进行笛卡尔积操作。<br> Computes the cartesian product between two RDDs </p>
</li>
</ol>
<h4 id="输入分区与输出分区多对多"><a href="#输入分区与输出分区多对多" class="headerlink" title="输入分区与输出分区多对多"></a>输入分区与输出分区多对多</h4><ol>
<li><p>groupBy：将元素按照函数生成相应的key，数据就转换为key-value格式，之后将key相同的元素分为一组。</p>
<pre><code>&gt;&gt;&gt; m = sc.parallelize([&quot;tiger&quot;, &quot;mmmmm&quot;, &quot;nnn&quot;, &quot;hhh&quot;])
&gt;&gt;&gt; n = m.groupBy(len)
&gt;&gt;&gt; n.collect()
[(5, &lt;pyspark.resultiterable.ResultIterable object at 0x106acbed0&gt;), (3, &lt;pyspark.resultiterable.ResultIterable object at 0x106acbb50&gt;)]
&gt;&gt;&gt; def tra(k_records):
...     k = k_records[0]
...     print &quot;k=&quot;,k
...     records = k_records[1]
...     for record in records:
...         print &quot;record:&quot;, record
...
&gt;&gt;&gt; o = n.map(tra)
&gt;&gt;&gt; o.collect()
k= 3
record: nnn
record: hhh
k= 5
record: tiger
record: mmmmm
[None, None]
</code></pre></li>
</ol>
<h4 id="输出分区为输入分区子类型"><a href="#输出分区为输入分区子类型" class="headerlink" title="输出分区为输入分区子类型"></a>输出分区为输入分区子类型</h4><ol>
<li><p>filter: 对元素进行过滤，对每个元素应用f函数，返回值为true的元素保留；反之，过滤。</p>
<pre><code>&gt;&gt;&gt; def tigerFilter(x):
...     if x == &quot;tiger&quot;:
...             return 0
...     else:
...             return 1
...
&gt;&gt;&gt; m = sc.parallelize([&quot;tiger&quot;, &quot;mmmmm&quot;, &quot;nnn&quot;, &quot;hhh&quot;])
&gt;&gt;&gt; m.filter(tigerFilter).collect()
[&apos;mmmmm&apos;, &apos;nnn&apos;, &apos;hhh&apos;]
</code></pre></li>
<li>distinct：将RDD中的元素进行去重操作。</li>
<li>subtract:相当于进行集合的差操作。         </li>
<li>sample</li>
<li>cache</li>
</ol>
<h3 id="Key-Value型Transformation算子"><a href="#Key-Value型Transformation算子" class="headerlink" title="Key-Value型Transformation算子"></a>Key-Value型Transformation算子</h3><ol>
<li>mapValues:针对(key, value)中的value进行操作，而不对key进行处理</li>
<li><p>对单个RDD或两个RDD聚集</p>
<ul>
<li>combineByKey</li>
<li>reduceByKey</li>
<li>partitionBy</li>
</ul>
</li>
<li><p>连接</p>
<ul>
<li>join</li>
<li>leftOutJoin</li>
</ul>
</li>
</ol>
<h2 id="Action算子"><a href="#Action算子" class="headerlink" title="Action算子"></a>Action算子</h2><ol>
<li>无输出 foreach</li>
<li><p>HDFS</p>
<ul>
<li>saveAsTextFile</li>
<li>saveAsObjectFile</li>
</ul>
</li>
<li><p>Scala集合和数据类型</p>
<ul>
<li>collect</li>
<li>collectAsMap</li>
<li>lookup</li>
<li>reduceByKeyLocally</li>
<li>count</li>
<li>top</li>
<li>reduce</li>
<li>fold</li>
<li>aggregate</li>
<li></li>
</ul>
</li>
</ol>
<h4 id="working-with-key-value-Pairs"><a href="#working-with-key-value-Pairs" class="headerlink" title="working with key-value Pairs"></a>working with key-value Pairs</h4><p>有一些特别的操作只能应用于k/v对。最常见的是分布式重排操作（distributed shuffle)，如通过key进行grouping, aggregating。</p>
<h2 id="Spark学习"><a href="#Spark学习" class="headerlink" title="Spark学习"></a>Spark学习</h2><h2 id="spark函数学习"><a href="#spark函数学习" class="headerlink" title="spark函数学习"></a>spark函数学习</h2><ol>
<li><p>spark函数讲解 aggregate</p>
<ul>
<li><a href="https://www.iteblog.com/archives/1268" target="_blank" rel="noopener">https://www.iteblog.com/archives/1268</a></li>
<li><a href="http://lib.csdn.net/article/scala/34642==" target="_blank" rel="noopener">http://lib.csdn.net/article/scala/34642==</a></li>
</ul>
</li>
<li><p>所有spark函数讲解</p>
<ul>
<li><a href="http://homepage.cs.latrobe.edu.au/zhe/ZhenHeSparkRDDAPIExamples.html" target="_blank" rel="noopener">http://homepage.cs.latrobe.edu.au/zhe/ZhenHeSparkRDDAPIExamples.html</a></li>
</ul>
</li>
</ol>
<h3 id="Spark数据输入"><a href="#Spark数据输入" class="headerlink" title="Spark数据输入"></a>Spark数据输入</h3><ol>
<li><p>从HDFS读取日志文件</p>
<p> var file = sc.textFile(“hdfs://xxx”)</p>
</li>
</ol>
<h3 id="Spark中数据处理"><a href="#Spark中数据处理" class="headerlink" title="Spark中数据处理"></a>Spark中数据处理</h3><ol>
<li><p>过滤</p>
<p> var errors = file.filter(line =&gt; line.contains(“error”)</p>
</li>
</ol>
<p>aggregate函数</p>
<p><a href="http://lib.csdn.net/article/scala/34642" target="_blank" rel="noopener">理解Spark RDD中的aggregate函数</a><br><a href="http://homepage.cs.latrobe.edu.au/zhe/ZhenHeSparkRDDAPIExamples.html" target="_blank" rel="noopener">learn</a></p>
<p>groupBy函数</p>
<p>combineByKey函数<br>countByKey函数<br>reduce<br>reduceByKey<br>sortBy<br>sortByKey</p>
<p>S</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2017/03/31/spark-learn/" data-id="ckw1x5qc4004i3mnuvaseytk8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spark/">spark</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-thrift-demo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/16/thrift-demo/" class="article-date">
  <time datetime="2017-01-16T02:54:18.000Z" itemprop="datePublished">2017-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/16/thrift-demo/">thrift-demo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2017/01/16/thrift-demo/" data-id="ckw1x5qc6004p3mnu2vaq4aq8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-thrift-install" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/16/thrift-install/" class="article-date">
  <time datetime="2017-01-16T02:37:45.000Z" itemprop="datePublished">2017-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/16/thrift-install/">thrift install</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Centos6-5上安装Apache-Thrift"><a href="#Centos6-5上安装Apache-Thrift" class="headerlink" title="Centos6.5上安装Apache Thrift"></a>Centos6.5上安装Apache Thrift</h2><ol>
<li>按照<a href="http://thrift.apache.org/docs/install/centos" target="_blank" rel="noopener">Building Apache Thrift on CentOS6.5</a>操作</li>
<li>可能还需要安装libevent</li>
<li><p>最后安装thrift的时候，我是下载了thrift-0.9.3.tar.gz </p>
<p> wget <a href="http://archive.apache.org/dist/thrift/0.9.3/thrift-0.9.3.tar.gz" target="_blank" rel="noopener">http://archive.apache.org/dist/thrift/0.9.3/thrift-0.9.3.tar.gz</a><br> tar zxvf thrift-0.9.3.tar.gz<br> cd thrift-0.9.3<br> ./configure<br> make<br> sudo make install</p>
</li>
<li><p>如果出现”error while loading shared libraries: libthrift-0.9.3.so” 错误的原因和解决办法</p>
<p> sudo ldconfig</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2017/01/16/thrift-install/" data-id="ckw1x5qc8004u3mnu7vyp4f0x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thrift/">thrift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-log4cplus介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/02/log4cplus介绍/" class="article-date">
  <time datetime="2017-01-02T14:57:32.000Z" itemprop="datePublished">2017-01-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/02/log4cplus介绍/">log4cplus介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近在看C++，比较难懂的一个c++的库是log4cplus，一直没有找到合适的文档。元旦看了一下老大写的基于log4cplus的库，方才对log4cplus有了一个直观的印象。</p>
<p>首先说一下我的几个困惑：</p>
<ol>
<li><p>版本问题，目前<a href="https://sourceforge.net/p/log4cplus/wiki/Home/" target="_blank" rel="noopener">官方wiki</a>, <a href="https://github.com/log4cplus/log4cplus/blob/master/docs/examples.md" target="_blank" rel="noopener">例子</a> 介绍的是版本2.0。而我们在使用多是1.2版本。 </p>
</li>
<li><p>代码问题。在搜到的博客中，经常见到的是自己定义append,layout等等，代码非常长。老大写的代码只有很少的代码。<br>经过查证，log4cplus有两种方式，一种是代码中写appender,layout,一种是通过配置。</p>
</li>
</ol>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>有关log4cplus的配置有一篇不错的文章。 <a href="http://blog.csdn.net/fksec/article/details/41546189" target="_blank" rel="noopener">log4cplus介绍</a></p>
<p>log4cplus的组成：</p>
<ul>
<li><ol>
<li>logger： 一个应用程序可以使用多个logger，logger是我们打印log的句柄</li>
</ol>
</li>
<li><ol start="2">
<li>appender：一个logger可以拥有多个appender，appender决定了log的输出方向</li>
</ol>
</li>
<li><ol start="3">
<li>filter：一个appender可以有多个filter，在配置文件中设置过滤条件</li>
</ol>
</li>
<li><ol start="4">
<li>layout：支持多种layout，一个appender一个layout</li>
</ol>
</li>
</ul>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>demo.cpp </p>
<pre><code>// demo.cpp
#include &lt;log4cplus/logger.h&gt;
#include &lt;log4cplus/configurator.h&gt;
#include &lt;log4cplus/helpers/loglog.h&gt;
#include &lt;log4cplus/helpers/stringhelper.h&gt;
#include &lt;log4cplus/helpers/sleep.h&gt;
#include &lt;log4cplus/loggingmacros.h&gt;
#include &lt;iostream&gt;

using namespace log4cplus;
using namespace log4cplus::helpers;


Logger log_1 =  Logger::getInstance(LOG4CPLUS_TEXT(&quot;test.log_1&quot;));
Logger log_2 =  Logger::getInstance(LOG4CPLUS_TEXT(&quot;test.log_2&quot;));
Logger log_3 =  Logger::getInstance(LOG4CPLUS_TEXT(&quot;test.log_3&quot;));


void
printMsgs(Logger&amp; logger)
{
    LOG4CPLUS_TRACE_METHOD(logger, LOG4CPLUS_TEXT(&quot;printMsgs()&quot;));
    //LOG4CPLUS_DEBUG(logger, &quot;printMsgs()&quot;);
    LOG4CPLUS_INFO(logger, &quot;printMsgs()&quot;);
    //LOG4CPLUS_WARN(logger, &quot;printMsgs()&quot;);
    //LOG4CPLUS_ERROR(logger, &quot;printMsgs()&quot;);
    LOG4CPLUS_ERROR_FMT(logger, &quot;printMsgs(%s)&quot;, &quot;helloworld&quot;);
}



int
main()
{
    std::cout&lt;&lt; LOG4CPLUS_TEXT(&quot;Entering main()...&quot;) &lt;&lt; std::endl;
    log4cplus::initialize();
    LogLog::getLogLog()-&gt;setInternalDebugging(true);
    Logger root = Logger::getRoot();
    try 
    {
        ConfigureAndWatchThread configureThread(
            LOG4CPLUS_TEXT(&quot;log4cplus.properties&quot;), 5 * 1000);

        LOG4CPLUS_WARN(root, &quot;Testing....&quot;);

        for(int i=0; i&lt;4; ++i) {
            //printMsgs(log_1);
            printMsgs(log_2);
            //printMsgs(log_3);
            log4cplus::helpers::sleep(1);
        }
    }
    catch(...) {
        std::cout&lt;&lt; LOG4CPLUS_TEXT(&quot;Exception...&quot;) &lt;&lt; std::endl;
        LOG4CPLUS_FATAL(root, &quot;Exception occured...&quot;);
    }

    std::cout&lt;&lt; LOG4CPLUS_TEXT(&quot;Exiting main()...&quot;) &lt;&lt; std::endl;
    return 0;
}
</code></pre><p>配置文件</p>
<pre><code>log4cplus.rootLogger= WARN, M
log4cplus.logger.test.log_1=WARN
log4cplus.logger.test.log_2=WARN
log4cplus.logger.test.log_3=WARN

log4cplus.appender.TT=log4cplus::ConsoleAppender
log4cplus.appender.TT.layout=log4cplus::PatternLayout
log4cplus.appender.TT.layout.ConversionPattern=%d{%m/%d/%y %H:%M:%S} [%t] %-5p %c{2} %%%x%% - %m [%l]%n

log4cplus.appender.M=log4cplus::DailyRollingFileAppender
log4cplus.appender.M.Schedule=MINUTELY
log4cplus.appender.M.filters.1.LogLevelToMatch=DEBUG
log4cplus.appender.M.filters.1.AcceptOnMatch=TRUE
log4cplus.appender.M.filters.2=log4cplus::spi::DenyAllFilter
log4cplus.appender.M.File=output.log
#log4cplus.appender.M.MaxFileSize=5MB
log4cplus.appender.M.MaxBackupIndex=1
log4cplus.appender.M.layout=log4cplus::PatternLayout
log4cplus.appender.M.layout.ConversionPattern=%d{%m/%d/%y %H:%M:%S} [%t] %-5p %c{2} %%%x%% - %m [%l]%n
</code></pre><p>编译</p>
<pre><code>g++ -llog4cplus -lpthread -o test log4cplus.demo.cpp
</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://blog.csdn.net/cchd0001/article/details/49928421" target="_blank" rel="noopener">log4cplus学习速记</a><br><a href="http://blog.csdn.net/skyztttt/article/details/51492935" target="_blank" rel="noopener">log4cplush学习</a></p>
<p>安装</p>
<p> ./configure –enable-static –prefix=/Users/keything/log4cplus_static CXXFLAGS=”-std=c++0x”</p>
<p>因为如果需要log4cplus支持C++11，必须在g++编译的时候需要加选项“-std=c++0x”。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2017/01/02/log4cplus介绍/" data-id="ckw1x5qbi002z3mnu7cgm91iu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mac安装hive" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/27/mac安装hive/" class="article-date">
  <time datetime="2016-11-27T01:42:54.000Z" itemprop="datePublished">2016-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/27/mac安装hive/">mac安装hive</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Mac安装hive"><a href="#Mac安装hive" class="headerlink" title="Mac安装hive"></a>Mac安装hive</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li>brew install hive</li>
</ol>
<h3 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h3><ol start="2">
<li>设置<code>HIVE_HOME=/usr/local/Cellar/hive/2.1.0/libexec</code></li>
<li><code>cp $HIVE_HOME/conf/hive-default.xml.template $HIVE_HOME/conf/hive-default.xml</code></li>
<li><p>hive-site.xml 文件中包含两部分，第一部分mysql是hive的metastore，存在mysql中。第二部分是metastore的目录。关于hive的metastore保存可以参考 官方wiki:<a href="http://wiki.apache.org/hadoop/Hive/AdminManual/MetastoreAdmin" target="_blank" rel="noopener">Hive Metastore</a>。其中配置中的用户名和密码都是hive</p>
<pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;

&lt;configuration&gt;

    &lt;property&gt;
        &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;
        &lt;value&gt;jdbc:mysql://127.0.0.1:3306/pdw?useSSL=false&lt;/value&gt;
    &lt;/property&gt;

    &lt;property&gt;
        &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;
        &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;
    &lt;/property&gt;

    &lt;property&gt;
        &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;
        &lt;value&gt;hive&lt;/value&gt;
    &lt;/property&gt;

    &lt;property&gt;
        &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;
        &lt;value&gt;hive&lt;/value&gt;
    &lt;/property&gt;

    &lt;property&gt;
        &lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt;
        &lt;value&gt;/user/hive/warehouse&lt;/value&gt;
    &lt;/property&gt;

&lt;/configuration&gt;
</code></pre></li>
<li><p>因为我们使用mysql存储meta信息，因此需要下载一个连接的jar包并将其放在<code>$HIVE_HOME/lib</code>中 <a href="http://dev.mysql.com/downloads/connector/j/" target="_blank" rel="noopener">jar包下载</a></p>
<p> <code>cp ~/Downloads/mysql-connector-java-5.1.40/mysql-connector-java-5.1.40-bin.jar $HIVE_HOME/lib</code></p>
</li>
</ol>
<h2 id="配置spark支持hive"><a href="#配置spark支持hive" class="headerlink" title="配置spark支持hive"></a>配置spark支持hive</h2><ol>
<li><p>Spark支持hive需要三个jar包，如果有的话则已经支持；如果没有的话则需要编译。在通过brew install spark 安装的spark2.0.1默认已经支持</p>
<p> ➜  ~ cd $SPARK_HOME/jars</p>
<p> ➜  ls -l d*</p>
<pre><code>-rw-r--r--@ 1 keything  staff   339666 Sep 29 08:03 datanucleus-api-jdo-3.2.6.jar
-rw-r--r--@ 1 keything  staff  1890075 Sep 29 08:03 datanucleus-core-3.2.10.jar
-rw-r--r--@ 1 keything  staff  1809447 Sep 29 08:03 datanucleus-rdbms-3.2.9.jar
</code></pre></li>
<li><p>配置文件的拷贝</p>
<ul>
<li><p>复制hive配置文件</p>
<p>  <code>cp $HIVE_HOME/conf/hive-site.xml $SPARK_HOME/conf/hive-site.xml</code></p>
</li>
<li><p>复制hdfs配置文件</p>
<p>  <code>cp $HADOOP_HOME/libexec/etc/hadoop/hdfs-site.xml $SPARK_HOME/conf/hdfs-site.xml</code><br>  <code>cp $HADOOP_HOME/libexec/etc/hadoop/core-site.xml $SPARK_HOME/conf/core-site.xml</code></p>
</li>
</ul>
</li>
<li><p>启动</p>
<p> <code>./bin/spark-shell --jars $HIVE_HOME/lib/mysql-connector-java-5.1.xx-bin.jar</code></p>
</li>
<li><p>测试</p>
</li>
</ol>
<pre><code>import org.apache.spark.sql.SQLContext
val hc = new org.apache.spark.sql.hive.HiveContext(sc)
val df = hc.sql(&quot;show databases&quot;)
df.show
</code></pre><p>注意：在执行<code>val df = hc.sql(&quot;show databases&quot;)</code>中会报出<code>16/11/27 09:09:35 ERROR metastore.RetryingHMSHandler: AlreadyExistsException(message:Database default already exists)
    at org.apache.hadoop.hive.metastore.HiveMetaStore$HMSHandler.create_database(HiveMetaStore.java:891)</code>的错误，可以忽略掉，如何不让这个错误出来，目前未知。</p>
<p>注意：在hadoop 2.7.3 下 启动hive 3.1 及 hive 2.3 都会报错：<br>hive 命令启动 </p>
<blockquote>
<p>show databases;<br>会有下面的报错<br><code>FAILED: HiveException java.lang.RuntimeException: Unable to instantiate org.apache.hadoop.hive.ql.metadata.SessionHiveMetaStoreClient</code></p>
</blockquote>
<p>换成hive 1.2.2以后没有问题。<br>hive下载地址:<a href="http://mirror.bit.edu.cn/apache/hive/" target="_blank" rel="noopener">http://mirror.bit.edu.cn/apache/hive/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/11/27/mac安装hive/" data-id="ckw1x5qbl00353mnuoe39pcvy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mac/">mac</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="thrift-Thrift网络栈" class="article article-type-thrift" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/12/Thrift网络栈/" class="article-date">
  <time datetime="2016-11-12T08:29:53.000Z" itemprop="datePublished">2016-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/12/Thrift网络栈/">Thrift network stack</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Thrift-network-stack"><a href="#Thrift-network-stack" class="headerlink" title="Thrift network stack"></a>Thrift network stack</h3><p>本文翻译自<a href="http://thrift.apache.org/docs/concepts" target="_blank" rel="noopener">Thrift network stack</a></p>
<p>Apache Thrift网络栈的简要描述</p>
<pre><code>+-------------------------------------------+
| Server                                    |
| (single-threaded, event-driven etc)       |
+-------------------------------------------+
| Processor                                 |
| (compiler generated)                      |
+-------------------------------------------+
| Protocol                                  |
| (JSON, compact etc)                       |
+-------------------------------------------+
| Transport                                 |
| (raw TCP, HTTP etc)                       |
+-------------------------------------------+
</code></pre><h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><p>传输层提供了读写网络的简单抽象。这使得Thrift可以与系统的底层传输解耦（如序列化/反序列化）。<br>下面是传输层接口暴露的一些方法：</p>
<ul>
<li>open</li>
<li>close</li>
<li>read</li>
<li>write</li>
<li>flush</li>
</ul>
<p>除了上面的传输接口外，Thrift还使用<code>ServerTransport</code>接口来接受或创建原始的传输对象。正如名字所写的，服务器端端使用<code>ServerTransport</code>为到来的连接创建一个传输对象（Transport objects)。</p>
<ul>
<li>open</li>
<li>listen</li>
<li>accept</li>
<li>close</li>
</ul>
<p>大多数支持Thrift支持的语言的可选的一些传输如下：</p>
<ul>
<li>file: read/write to/from a file on disk</li>
<li>http: as the name suggests</li>
</ul>
<p>###协议<br>协议的抽象定义了将内存中结构映射为有线格式（wire-format）的机制。换句话说，协议指明了数据如何使用底层的传输来进行编解码。因此协议实现控制了编码格式，并负责序列化和反序列化。协议举例，如JSON,XML,plain text, compact binary 。</p>
<p>下面是协议接口：</p>
<pre><code>writeMessageBegin(name, type, seq)
writeMessageEnd()
writeStructBegin(name)
writeStructEnd()
writeFieldBegin(name, type, id)
writeFieldEnd()
writeFieldStop()
writeMapBegin(ktype, vtype, size)
writeMapEnd()
writeListBegin(etype, size)
writeListEnd()
writeSetBegin(etype, size)
writeSetEnd()
writeBool(bool)
writeByte(byte)
writeI16(i16)
writeI32(i32)
writeI64(i64)
writeDouble(double)
writeString(string)

name, type, seq = readMessageBegin()
                  readMessageEnd()
name = readStructBegin()
       readStructEnd()
name, type, id = readFieldBegin()
                 readFieldEnd()
k, v, size = readMapBegin()
             readMapEnd()
etype, size = readListBegin()
              readListEnd()
etype, size = readSetBegin()
              readSetEnd()
bool = readBool()
byte = readByte()
i16 = readI16()
i32 = readI32()
i64 = readI64()
double = readDouble()
string = readString()
</code></pre><p>Thrift协议是面向流的。没有必要需要任何明确的框架。举例，开始序列化的时候，不需要知道字符串的长度或列表中的个数。大多数支持Thrift语言可选的协议：</p>
<ul>
<li>binary：相当简单的二进制编码–字段的长度和类型都编码为字节</li>
<li>compact：在<a href="https://issues.apache.org/jira/browse/THRIFT-110" target="_blank" rel="noopener">THRIFT-100</a>中描述</li>
<li>json</li>
</ul>
<p>###处理器（Processor）</p>
<p>一个处理器有两个能力：从输入流读取数据，将数据写入到输出流。协议对象（protocal objects）代表输入流和输出流。处理器接口可以非常简单：</p>
<pre><code>interface TProcessor {
    bool process(TProtocol in, TProtocol out) throws TException
}
</code></pre><p>特定服务处理器(service-specific)的实现是由compiler生成的。本质上处理器processor使用输入协议从wire读取数据，将处理过程委托给用户自己实现的handler，然后使用输出协议将数据写入wire。</p>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>一个server将上面描述的所有的不同的特性聚合在一起：</p>
<ul>
<li>创建一个传输 transport</li>
<li>为传输创建一个input/output协议</li>
<li>基于Input/output协议创建一个处理器processor</li>
<li>等待输入连接，并将其交给processor</li>
</ul>
<h3 id="其他文章"><a href="#其他文章" class="headerlink" title="其他文章"></a>其他文章</h3><p><a href="http://thrift.apache.org/docs/features" target="_blank" rel="noopener">Thrift Feature</a></p>
<p><a href="http://thrift.apache.org/docs/idl" target="_blank" rel="noopener">Thrift interface description language</a></p>
<p><a href="http://thrift.apache.org/docs/install/" target="_blank" rel="noopener">Thrift install</a></p>
<p><a href="http://thrift.apache.org/docs/types" target="_blank" rel="noopener">Thrift types</a></p>
<p><a href="http://dongxicheng.org/search-engine/thrift-guide/" target="_blank" rel="noopener"></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/11/12/Thrift网络栈/" data-id="ckw1x5qav00173mnu96ddajep" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thrift/">thrift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Thrift：可扩展的跨语言的服务实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/12/Thrift：可扩展的跨语言的服务实现/" class="article-date">
  <time datetime="2016-11-12T08:26:52.000Z" itemprop="datePublished">2016-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/12/Thrift：可扩展的跨语言的服务实现/">Thrift：可扩展的跨语言的服务实现[论文翻译]</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文翻译<a href="http://thrift.apache.org/static/files/thrift-20070401.pdf" target="_blank" rel="noopener">Thrift: Scalable Cross-Language Services Implementation</a></p>
<p>有一些地方没有翻译到，就纯纯的用英文直接读咯.</p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Thrift是什么呢？Thrift由Facebook开发；Thrift是一个软件库，一个代码生成工具的集合；通过这些工具可以加快高效可扩展的后端服务的开发和实现。Thrift的主要目标是：实现跨语言的高效可靠的通信。实现方式：将各个语言中需要的定制化抽象为一个通用的库。这个库是由各个语言实现的一个库。 特别地，Thrift允许开发者以一个中立语言（language-neutral)文件定义数据类型和服务接口，并且生成构建RPC客户端和服务器端的所需的所有必要的代码。 </p>
<p>这篇论文详细介绍了Thrift中的动机和设计思想。 这并不是作为一个研究，而是详细阐述了我们做了什么以及为什么这么做。 </p>
<h2 id="1-说明"><a href="#1-说明" class="headerlink" title="1. 说明"></a>1. 说明</h2><p>一句话，单纯的LAMP框架不能够满足Facebook的需求，Facebook的文化就是选择最好的工具和实现来达到最好的性能。那么带来的问题就是需要在各个语言之间建立一个透明和高性能的桥。我们发现大多数可选系统要么限制太多，要么有性能问题。</p>
<p>我们的实现方案：将一个中立语言软件栈与一个代码生成引擎进行组装。<br>中立语言软件栈可以由许多编程语言实现。<br>代码生成引擎可以可以将简单接口和数据定义语言转换为客户端和服务端调用的远程库。</p>
<p>在一个动态系统上选择一个静态代码生成，允许我们可以创建有效的代码；这些代码不需要进行实时的类型检查。对于开发者而言，可以在一个简短的文件中定义复杂服务所需要的数据类型和接口。</p>
<p>令人惊讶的是竟然一个健壮的开源的解决方案，因此我们将Thrift的实现进行了开源。</p>
<p>评估了网络环境下，跨语言交互的挑战后，我们明确了一些关键组件：</p>
<ul>
<li>types：必须有一个通用的类型系统；跨语言的时候，应用开发者不需要使用自定义的thrift数据类型或者写自己的序列化代码。也就是说，一个C++程序员能够透明的将一个STL map转换为python的字字典。不需要程序员写应用层以下的代码。 </li>
<li>transport。每个语言都需要一个通用的双向数据传输的接口。服务开发者（service developer）不需要关心特定传输是如何实现的。相同的应用代码可以跑在不同的传输上，比如TCP流，内存中数据，或者硬盘上的文件。</li>
<li>protocol：数据类型必须有某种使用传输层的方式来编解码自己。当然，应用开发者不需要关心协议这一层的实现。对于应用层代码而言，使用XML或二进制协议都是一样的。所有要确定的就是，必须以始终一样的确定的协议进行传输</li>
<li>versioning。对于健壮的服务，所包含的数据类型必须提供一个版本化自己的机制。特别的，能够在不破坏服务的情况下增加或删除对象(或者函数列表)中的字段。Section 5 details Thrift’s versioning system.</li>
<li>Processors：最后，我们生成能够处理数据流的代码来完成远程进程调用。Section 6 details the generated code and TProcessor paradigm。</li>
<li>Section 7 discusses implementation details, and Section 8 describes our conclusions.</li>
</ul>
<h2 id="2-Types"><a href="#2-Types" class="headerlink" title="2. Types"></a>2. Types</h2><p>Thrift类型系统是为了：不管使用什么编程语言，都使用完全原生的类型进行开发。设计上，Thrift类型系统不会引入任何特别的动态类型或者wrapper objects。并且，不需要开发者写任何对象序列化或传输的代码。Thrift IDL（Interface Definition Language）文件以最简单的方式告诉代码生成工具，如何安全的跨语言的传输对象。</p>
<h3 id="2-1-base-types"><a href="#2-1-base-types" class="headerlink" title="2.1 base types"></a>2.1 base types</h3><p>类型系统依赖一些基础类型。考虑支持哪些类型时，我们目标是在所有编程语言中都可用的数据类型。<br>在Thrift中支持的基础类型是</p>
<ul>
<li>bool</li>
<li>byte</li>
<li>i16: a 16-bit signed integer</li>
<li>i32: a 32-bit signed integer</li>
<li>i64: a 64-bit signed integer</li>
<li>double: a 64-bit floating point </li>
<li>string: 一个不知道编码的文本或者二进制文件。</li>
</ul>
<p>特别注意的是unsigned integer类型的缺失。因为在很多语言中这个类型不能明确的转换为基础类型。并且，在一些语言如python中，应用开发者会给整形变量赋值一个负值。从设计的角度来说，我们发现unsigned integers在算术运算中很少用，实际中大都用作key或者标识符。这种情况下，sign就无关紧要了。signed integers同样可以做，并且可以在需要的时候安全的转换为unsigned。</p>
<h3 id="2-2-structs"><a href="#2-2-structs" class="headerlink" title="2.2 structs"></a>2.2 structs</h3><p>一个Thrift的struct定义了一个对象，可以在不同语言中使用。本质上，结构体等同于面向对象语言的类。定义Thrfit结构体的基本语法类似C的结构体定义。字段可能会用一个整形来进行注释，并且有一个默认值。如果忽略的话，会有一个默认值；不过强烈建议有取值，这对于稍后的版本有很大用处。 </p>
<h3 id="2-3-Containers"><a href="#2-3-Containers" class="headerlink" title="2.3 Containers"></a>2.3 Containers</h3><p>Thrift中的container可以映射到很多语言中的container。可以用C++模板的样式进行标记。有三种可选的类型：</p>
<ul>
<li>list<type>:元素的有序列表。直接转换为STL vector，Java ArrayList, 或JS的native array</type></li>
<li>set<type>:元素的无序集合。转为了STL set， Java HashSet，python的set，或PHP中的字典</type></li>
<li>map&lt;type1, type2&gt;:key到value的映射。转为STL map，Java HashMap，PHP的关联数组</li>
</ul>
<p>当提供默认值时，类型的映射并不是固定的。Container中的元素可以是任何有效的Thrift类型，包含其他结构体的containers。</p>
<pre><code>struct Example {
    1:i32 number = 10,
    2:i64 bigNumber,
    3:double decimals,
    4:string name=&quot;thrifty&quot;
}
</code></pre><p>在目标语言中，每个定义都会生成两种方法的类型，read和write，用于执行序列化和使用Thrift TProtocol对象传输。</p>
<h3 id="2-4-Exception"><a href="#2-4-Exception" class="headerlink" title="2.4 Exception"></a>2.4 Exception</h3><p>异常在语法和功能上等同于结构体，除了使用exception关键字而不是使用struct关键字。<br>生成的对象继承自某个异常基类。目的是：用一种应用层开发者熟悉的代码风格。 </p>
<h3 id="2-5-Services"><a href="#2-5-Services" class="headerlink" title="2.5 Services"></a>2.5 Services</h3><p>使用Thrift类型定义服务service。在语义上，service的定义等同于接口的定义（或者一个纯虚抽象类）。Thrift编译器生成实现这些接口的全部功能的client和server stubs。service定义如下：</p>
<pre><code>service &lt;name&gt; {
    &lt;returntype&gt; &lt;name&gt;(&lt;arguments&gt;)
        [throw (&lt;exceptions&gt;)]
}
</code></pre><p>一个例子：</p>
<pre><code>service StringCache {
    void set(1:i32 key 2:string value),
    string get(1:i32 key) throws (1:KeyNotFound knf),
    void delete(1:i32 key)
}
</code></pre><p>注意到void是函数返回的有效类型，当然也可以返回其他已经定义的thrift类型。另外，<code>async</code>关键字可以加到void函数上，其生成的代码不需要等待服务器的响应。对于一个纯净的void函数，只有完成服务器端的操作以后才会给客户端返回响应。使用async方法调用个，客户端只保证传输层的请求成功。<br>也需要注意到参数列表和异常列表也可以实现为thrift structs。在notation和行为上，三种的构造是相同的。 </p>
<h2 id="3-Transport"><a href="#3-Transport" class="headerlink" title="3. Transport"></a>3. Transport</h2><p>生成的代码使用传输层加速数据传输</p>
<h3 id="3-1-接口"><a href="#3-1-接口" class="headerlink" title="3.1 接口"></a>3.1 接口</h3><p>在Thrift设计中一个关键的设计选择是：从代码生成层中解耦传输层。Though Thrift is typically used on top of the TCP/IP stack with streaming sockets as the base layer of communication, there was no compelling reason to build that constraint into the system。与真实的I/O操作相比，抽象I/O层带来的性能损耗是无关紧要的。</p>
<p>根本上，生成的Thrift代码只需要知道如何读取和写入数据。数据的起始是无关紧要的；它可能是一个socket，一个共享内存的片段，或者本地磁盘的一个文件。Thrift传输接口支持下面的方法：</p>
<ul>
<li>open： 打开传输</li>
<li>close：关闭传输</li>
<li>isOpen：标识传输是否打开</li>
<li>read：读取</li>
<li>write：写入</li>
<li>flush：</li>
</ul>
<p>有一些接口没有列出来，这些接口用于批量读取 and optionally signaling the comple- tion of a read or write operation from the generated code.</p>
<p>除了上面的TTransport接口，还有一个TServerTransport接口用于接收或创建原始的transport objects。其接口如下：</p>
<ul>
<li>open</li>
<li>listen</li>
<li>accept</li>
<li>close</li>
</ul>
<h3 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a>3.2 实现</h3><p>在任何语言中很容易实现传输层接口。如果需要的话，开发者可以实现新的传输层机制。 </p>
<h4 id="3-2-1-TSocket"><a href="#3-2-1-TSocket" class="headerlink" title="3.2.1 TSocket"></a>3.2.1 TSocket</h4><p>在所有目标语言中，实现TSocket类。提供了一个TCP/IP stream socket的通用的简单的接口。</p>
<h4 id="3-2-2-TFileTransport"><a href="#3-2-2-TFileTransport" class="headerlink" title="3.2.2 TFileTransport"></a>3.2.2 TFileTransport</h4><p>TFileTransport是硬盘文件数据流的抽象。可以将到来的thrift请求写入到硬盘文件中。硬盘数据可以从日志中重放，用于post-process或reproduction 或者过去事件的同步。</p>
<h4 id="3-2-3-Utilities"><a href="#3-2-3-Utilities" class="headerlink" title="3.2.3 Utilities"></a>3.2.3 Utilities</h4><p>The Transport interface is designed to support easy extension us- ing common OOP techniques, such as composition. Some sim- ple utilites include the TBufferedTransport, which buffers the writes and reads on an underlying transport, the TFramedTransport, which transmits data with frame size headers for chunking op- timization or nonblocking operation, and the TMemoryBuffer, which allows reading and writing directly from the heap or stack memory owned by the process</p>
<h2 id="4-Protocol"><a href="#4-Protocol" class="headerlink" title="4. Protocol"></a>4. Protocol</h2><p>Thrift中的第二个重要的抽象是：数据结构和传输层表示的分离。 当传输数据时，Thrift加强了（enforce）一种消息结构，但是对于正在用的协议编码是不可知的。也就是，不需要关心数据是编码为XML，还是ASCII，还是二进制；只要数据支持固定的操作集合就行。</p>
<h3 id="4-1-接口"><a href="#4-1-接口" class="headerlink" title="4.1 接口"></a>4.1 接口</h3><p>Thrift的Protocol接口很直接。根本上它支持两件事：1. 双向的顺序消息 2. base type，containers，structs的编码。</p>
<pre><code>writeMessageBegin(name, type, seq)
writeMessageEnd()
writeStructBegin(name)
writeStructEnd()
writeFieldBegin(name, type, id)
writeFieldEnd()
writeFieldStop()
writeMapBegin(ktype, vtype, size)
writeMapEnd()
writeListBegin(etype, size)
writeListEnd()
writeSetBegin(etype, size)
writeSetEnd()
writeBool(bool)
writeByte(byte)
writeI16(i16)
writeI32(i32)
writeI64(i64)
writeDouble(double)
writeString(string)

name, type, seq = readMessageBegin()
                  readMessageEnd()
name = readStructBegin()
       readStructEnd()
name, type, id = readFieldBegin()
                 readFieldEnd()
k, v, size = readMapBegin()
             readMapEnd()
etype, size = readListBegin()
              readListEnd()
etype, size = readSetBegin()
              readSetEnd()
bool = readBool()
byte = readByte()
i16 = readI16()
i32 = readI32()
i64 = readI64()
double = readDouble()
string = readString()
</code></pre><p>Note that every write function has exactly one read counter- part, with the exception of writeFieldStop(). This is a special method that signals the end of a struct. The procedure for reading a struct is to readFieldBegin() until the stop field is encountered, and then to readStructEnd(). The generated code relies upon this call sequence to ensure that everything written by a protocol encoder can be read by a matching protocol decoder. Further note that this set of functions is by design more robust than necessary. For example, writeStructEnd() is not strictly necessary, as the end of a struct may be implied by the stop field. This method is a convenience for verbose protocols in which it is cleaner to separate these calls (e.g. a closing  tag in XML).</p>
<h3 id="4-2-structure"><a href="#4-2-structure" class="headerlink" title="4.2 structure"></a>4.2 structure</h3><p>Thrift structures are designed to support encoding into a streaming protocol. The implementation should never need to frame or com- pute the entire data length of a structure prior to encoding it. This is critical to performance in many scenarios. Consider a long list of relatively large strings. If the protocol interface required reading or writing a list to be an atomic operation, then the implementation would need to perform a linear pass over the entire list before en- coding any data. However, if the list can be written as iteration is performed, the corresponding read may begin in parallel, theoreti- cally offering an end-to-end speedup of (kN − C), where N is the size of the list, k the cost factor associated with serializing a sin- gle element, and C is fixed offset for the delay between data being written and becoming available to read.<br>Similarly, structs do not encode their data lengths a priori. Instead, they are encoded as a sequence of fields, with each field having a type specifier and a unique field identifier. Note that the inclusion of type specifiers allows the protocol to be safely parsed and decoded without any generated code or access to the original IDL file. Structs are terminated by a field header with a special STOP type. Because all the basic types can be read deterministically, all structs (even those containing other structs) can be read deterministically. The Thrift protocol is self-delimiting without any framing and regardless of the encoding format.<br>In situations where streaming is unnecessary or framing is advan- tageous, it can be very simply added into the transport layer, using the TFramedTransport abstraction.</p>
<h3 id="4-3-实现"><a href="#4-3-实现" class="headerlink" title="4.3 实现"></a>4.3 实现</h3><p>Facebook has implemented and deployed a space-efficient binary protocol which is used by most backend services. Essentially, it writes all data in a flat binary format. Integer types are converted to network byte order, strings are prepended with their byte length, and all message and field headers are written using the primitive integer serialization constructs. String names for fields are omitted - when using generated code, field identifiers are sufficient.<br>We decided against some extreme storage optimizations (i.e. pack- ing small integers into ASCII or using a 7-bit continuation for- mat) for the sake of simplicity and clarity in the code. These alter- ations can easily be made if and when we encounter a performance- critical use case that demands them.</p>
<h2 id="5-Versioning"><a href="#5-Versioning" class="headerlink" title="5. Versioning"></a>5. Versioning</h2><p>面对版本和数据定义改变，Thrift是健壮的。对于已经部署的服务，改变的阶段性健壮是必须的。系统必须支持 1. 从日志中读取旧数据 2. 接收来自过期客户端到新服务器的请求等等</p>
<h3 id="5-1-Field-Identifiers"><a href="#5-1-Field-Identifiers" class="headerlink" title="5.1 Field Identifiers"></a>5.1 Field Identifiers</h3><p>Thrift中的版本是通过字段标识符来实现的。 最好的编程实践是清晰的制定字段标识符。 </p>
<pre><code>struct Example {
    1:i32 number=10,
    2:i64 bigNumber,                        
    3:double decimals,
    4:string name=&quot;thrifty&quot;
}
</code></pre><h3 id="5-2-Isset"><a href="#5-2-Isset" class="headerlink" title="5.2 Isset"></a>5.2 Isset</h3><h3 id="5-3-Case-Analysis"><a href="#5-3-Case-Analysis" class="headerlink" title="5.3 Case Analysis"></a>5.3 Case Analysis</h3><h3 id="5-4-Protocol-Transport-Versioning"><a href="#5-4-Protocol-Transport-Versioning" class="headerlink" title="5.4 Protocol/Transport Versioning"></a>5.4 Protocol/Transport Versioning</h3><h2 id="6-RPC实现"><a href="#6-RPC实现" class="headerlink" title="6. RPC实现"></a>6. RPC实现</h2><h3 id="6-1-TProcessor"><a href="#6-1-TProcessor" class="headerlink" title="6.1 TProcessor"></a>6.1 TProcessor</h3><p>Thrift设计中最后一个核心接口是TProcessor，可能是最简单的构造了。接口如下：</p>
<pre><code>interface TProcessor {
    bool process(TProtocol in, TProtocol out)
        throws TException
}
</code></pre><p>这儿关键的设计观点是：我们创建的复杂系统从根本上可以看做是处理输入和输出的服务。大多数情况下，确实是一个需要处理的输入和输出系统。</p>
<h3 id="6-2-Generated-Code"><a href="#6-2-Generated-Code" class="headerlink" title="6.2 Generated Code"></a>6.2 Generated Code</h3><p>当定义一个service时，我们生成一个能够处理RPC请求的TProcessor实例。基本结构如下：</p>
<pre><code>Service.thrift
=&gt; Service.cpp
interface ServiceIf
class ServiceClient : virtual ServiceIf
    TProtocol in
    TProtocol out
class ServiceProcessor : TProcessor
    ServiceIf handler


ServiceHandler.cpp
    class ServiceHandler : virtual ServiceIf

TServer.cpp
    TServer(TProcessor processor,
        TServerTransport transport,
        TTransportFactory tfactory,
        TProtocolFactory pfactory)
    serve()
</code></pre><ul>
<li>从Thrift定义文件，我们生成虚拟服务接口。</li>
<li>生成的客户端类实现了接口，并使用两个TProtocol实例执行I/O操作。</li>
<li>生成的processor实现了TProcessor接口</li>
<li>生成的代码中有所有处理RPC请求的逻辑，通过process()调用来处理。</li>
<li>用户提供一个应用接口的实现，这与生成的源码是独立的。</li>
</ul>
<h3 id="6-3-TServer"><a href="#6-3-TServer" class="headerlink" title="6.3 TServer"></a>6.3 TServer</h3><p>最后，Thrift 核心库提供了一个TServer的抽象。TServer对象通常如下工作：</p>
<ul>
<li>使用TServerTransport生成一个TTransport</li>
<li>使用TTransportFactory将一个基本的transport转换为合适的应用层transport（典型的是使用TBufferedTransportFactory）</li>
<li>使用TProtocolFactory 创建一个用于TTransport的input/output协议</li>
<li>触发TProcessor对象的process()方法</li>
</ul>
<p>这些层都是分开的，从而服务器代码不需要知道传输层、编码。server封装了连接处理、线程等逻辑。The only code written by the application developer lives in the definitional Thrift file and the interface implementation.</p>
<p>设计的TProcessor接口很通用。一个TServer没有带着一个生成的TProcessor对象。Thrift允许应用开发者写任何类型的server用于处理TProtocol对象。</p>
<h2 id="7-实现细节"><a href="#7-实现细节" class="headerlink" title="7. 实现细节"></a>7. 实现细节</h2><h3 id="7-1-Target-Language"><a href="#7-1-Target-Language" class="headerlink" title="7.1 Target Language"></a>7.1 Target Language</h3><p>Thrift目前支持五种目标语言：C++, Java, Python, Ruby 和PHP。</p>
<h3 id="7-2-Generated-Structs"><a href="#7-2-Generated-Structs" class="headerlink" title="7.2 Generated Structs"></a>7.2 Generated Structs</h3><p>We made a conscious decision to make our generated structs as transparent as possible. All fields are publicly accessible; there are no set() and get() methods. Similarly, use of the isset object is not enforced. We do not include any FieldNotSetException construct. Developers have the option to use these fields to write more robust code, but the system is robust to the developer ignor- ing the isset construct entirely and will provide suitable default behavior in all cases.<br>This choice was motivated by the desire to ease application devel- opment. Our stated goal is not to make developers learn a rich new library in their language of choice, but rather to generate code that allow them to work with the constructs that are most familiar in each language.<br>We also made the read() and write() methods of the generated objects public so that the objects can be used outside of the con- text of RPC clients and servers. Thrift is a useful tool simply for generating objects that are easily serializable across programming languages.</p>
<h3 id="7-3-RPC-Method-Identification"><a href="#7-3-RPC-Method-Identification" class="headerlink" title="7.3 RPC Method Identification"></a>7.3 RPC Method Identification</h3><p>在RPC中是通过发送方法名来调用方法的。 这种方法的一个问题是需要更多的带宽。</p>
<p>在方法调用时，我们希望避免很多不必要的字符串比较。为了处理这个，我们生成字符串到函数指针的映射，因此通常情况下能够以常量时间完成方法调用。在C++中，我们使用一个相对深奥的语言构造：member function pointers。</p>
<pre><code>std::map&lt;std::string,
    void (ExampleServiceProcessor::*)(int32_t,
    facebook::thrift::protocol::TProtocol*,
    facebook::thrift::protocol::TProtocol*)&gt;
    processMap_;
</code></pre><p>使用这些技术，处理字符串的消耗被降到最低。</p>
<h3 id="7-4-Servers-and-Multithreading"><a href="#7-4-Servers-and-Multithreading" class="headerlink" title="7.4 Servers and Multithreading"></a>7.4 Servers and Multithreading</h3><p>Thrift服务需要基本的多线程来处理并发请求。对于Python和Java的Thrift服务器逻辑的实现，语言自带的线程库提供了足够的支持。对于C++的实现，没有标准的多线程实时库。特别地，健壮的、轻量的、可移植的线程管理和timer类不存在。我们研究了已有的实现，有boost::thread, boost:threadpool, ACE_Thread_Manager, ACE_TImer。</p>
<p>boost::threads：提供了多线程的轻量、健壮的实现；但是没有提供线程管理或timer实现。<br>boost::threadpool:看起来不错但还是没有达到我们的目标。我们希望尽可能的限制第三方以来。因为boost::threadpool不是一个纯净的模板库，还需要实时库，因为目前还不是官方boost的一部分。</p>
<h3 id="7-5-Thread-Primitives"><a href="#7-5-Thread-Primitives" class="headerlink" title="7.5 Thread Primitives"></a>7.5 Thread Primitives</h3><p>在命名空间facebook::thrift::concurrency中实现了Thrift线程库，有三个组件：</p>
<ul>
<li>primitives</li>
<li>thread pool manager</li>
<li>timer manager</li>
</ul>
<p>正如上面提到的，我们在由于要不要在thrift中引入其他依赖。我们决定使用boost::shared_ptr，因为这对于多线程应用是很有用的，不需要link-time或runtime库，并且它编程了C++0x标准的一部分。</p>
<p>我们实现了标准的Mutex和Condition类，和一个Monitor类。后者是一个mutex和condition变量的组合，有点类似Java Object的Monitor实现。</p>
<p>This is also sometimes referred to as a barrier. We provide a Synchronized guard class to allow Java-like synchronized blocks. This is just a bit of syntactic sugar, but, like its Java counterpart, clearly delimits critical sec- tions of code. Unlike its Java counterpart, we still have the ability to programmatically lock, unlock, block, and signal monitors.</p>
<p>xxxx<br>xxxx<br>xxxx</p>
<h3 id="7-6-Thread-Runnable-and-shared-ptr"><a href="#7-6-Thread-Runnable-and-shared-ptr" class="headerlink" title="7.6 Thread, Runnable, and shared_ptr"></a>7.6 Thread, Runnable, and shared_ptr</h3><h3 id="7-7-ThreadManager"><a href="#7-7-ThreadManager" class="headerlink" title="7.7 ThreadManager"></a>7.7 ThreadManager</h3><h3 id="7-8-TimerManager"><a href="#7-8-TimerManager" class="headerlink" title="7.8 TimerManager"></a>7.8 TimerManager</h3><h3 id="7-9-Nonblocking-Operation"><a href="#7-9-Nonblocking-Operation" class="headerlink" title="7.9 Nonblocking Operation"></a>7.9 Nonblocking Operation</h3><h3 id="7-10-Compiler"><a href="#7-10-Compiler" class="headerlink" title="7.10 Compiler"></a>7.10 Compiler</h3><h3 id="7-11-TFileTransport"><a href="#7-11-TFileTransport" class="headerlink" title="7.11 TFileTransport"></a>7.11 TFileTransport</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/11/12/Thrift：可扩展的跨语言的服务实现/" data-id="ckw1x5qax001c3mnub5quzvpy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thrift/">thrift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Thrift安装" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/12/Thrift安装/" class="article-date">
  <time datetime="2016-11-11T23:41:07.000Z" itemprop="datePublished">2016-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/12/Thrift安装/">Thrift安装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>参考文章：<br><a href="http://thrift.apache.org/tutorial/" target="_blank" rel="noopener">http://thrift.apache.org/tutorial/</a><br><a href="http://thrift.apache.org/docs/BuildingFromSource" target="_blank" rel="noopener">http://thrift.apache.org/docs/BuildingFromSource</a></p>
<p>几点说明：</p>
<ol>
<li>在mac上尝试，PHP是可以的，但是CPP的例子跑不通。</li>
<li>在centos6.8上使用BuildingFromSource进行安装（需要libevent），CPP的例子直接就编译通过。目录(tutorial/cpp/)</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/11/12/Thrift安装/" data-id="ckw1x5qat00143mnundjfh0zt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thrift/">thrift</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Laravel/">Laravel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/composer/">composer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/">cpp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp-lib/">cpp-lib</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/faiss/">faiss</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-source-code/">go.source.code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/laravel/">laravel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/">mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/machine-learning/">machine-learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memcache/">memcache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nosql/">nosql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/octave/">octave</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php源码学习/">php源码学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/">spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tcp/">tcp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thrift/">thrift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础知识/">基础知识</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Laravel/" style="font-size: 10px;">Laravel</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/composer/" style="font-size: 10px;">composer</a> <a href="/tags/cpp/" style="font-size: 12.22px;">cpp</a> <a href="/tags/cpp-lib/" style="font-size: 10px;">cpp-lib</a> <a href="/tags/elasticsearch/" style="font-size: 11.11px;">elasticsearch</a> <a href="/tags/faiss/" style="font-size: 10px;">faiss</a> <a href="/tags/git/" style="font-size: 12.22px;">git</a> <a href="/tags/go-source-code/" style="font-size: 10px;">go.source.code</a> <a href="/tags/golang/" style="font-size: 16.67px;">golang</a> <a href="/tags/laravel/" style="font-size: 11.11px;">laravel</a> <a href="/tags/linux/" style="font-size: 14.44px;">linux</a> <a href="/tags/mac/" style="font-size: 13.33px;">mac</a> <a href="/tags/machine-learning/" style="font-size: 10px;">machine-learning</a> <a href="/tags/memcache/" style="font-size: 15.56px;">memcache</a> <a href="/tags/mysql/" style="font-size: 13.33px;">mysql</a> <a href="/tags/nginx/" style="font-size: 13.33px;">nginx</a> <a href="/tags/nosql/" style="font-size: 18.89px;">nosql</a> <a href="/tags/octave/" style="font-size: 10px;">octave</a> <a href="/tags/php/" style="font-size: 20px;">php</a> <a href="/tags/php源码学习/" style="font-size: 17.78px;">php源码学习</a> <a href="/tags/redis/" style="font-size: 12.22px;">redis</a> <a href="/tags/spark/" style="font-size: 12.22px;">spark</a> <a href="/tags/tcp/" style="font-size: 10px;">tcp</a> <a href="/tags/thrift/" style="font-size: 13.33px;">thrift</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/基础知识/" style="font-size: 15.56px;">基础知识</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/11/16/Spark-DataSource-Hive Tables/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/11/14/分布式-事务/">分布式-事务</a>
          </li>
        
          <li>
            <a href="/2019/04/29/golang继承/">golang继承</a>
          </li>
        
          <li>
            <a href="/2019/04/28/spark-Quick-Start/">spark quick start</a>
          </li>
        
          <li>
            <a href="/2019/03/20/golang-包导入/">golang包导入</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Keything<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>