<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Keything的日志</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Keything的日志">
<meta property="og:url" content="http://keything.github.io/page/3/index.html">
<meta property="og:site_name" content="Keything的日志">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Keything的日志">
  
    <link rel="alternate" href="/atom.xml" title="Keything的日志" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Keything的日志</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://keything.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-golang-glide版本控制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/23/golang-glide版本控制/" class="article-date">
  <time datetime="2018-01-23T11:29:35.000Z" itemprop="datePublished">2018-01-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/23/golang-glide版本控制/">golang_glide版本控制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2018/01/23/golang-glide版本控制/" data-id="ckw5yql4n0024p8nuebout79d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-golang环境变量" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/23/golang环境变量/" class="article-date">
  <time datetime="2018-01-22T16:08:32.000Z" itemprop="datePublished">2018-01-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/23/golang环境变量/">golang环境变量</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="GOROOT"><a href="#GOROOT" class="headerlink" title="GOROOT"></a>GOROOT</h2><p>GOROOT 是golang的安装路径</p>
<h2 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h2><p>go install/go get和 go的工具等会用到GOPATH环境变量.</p>
<p>GOPATH是作为编译后二进制的存放目的地和import包时的搜索路径。其实也是你的工作目录, 你可以在src下创建你自己的go源文件, 然后开始工作。</p>
<ul>
<li>GOPATH之下主要包含三个目录: bin、pkg、src</li>
<li>bin目录主要存放可执行文件; pkg目录存放编译好的库文件, 主要是.a文件; src目录下主要存放go的源文件</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>不要把GOPATH设置成go的安装路径</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://blog.csdn.net/Alsmile/article/details/48290223" target="_blank" rel="noopener">http://blog.csdn.net/Alsmile/article/details/48290223</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2018/01/23/golang环境变量/" data-id="ckw5yql4r002bp8nupwf93kfp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-golang的import介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/21/golang的import介绍/" class="article-date">
  <time datetime="2018-01-20T16:01:53.000Z" itemprop="datePublished">2018-01-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/21/golang的import介绍/">golang的import介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Golang使用包（package）这种语法元素来组织源码，所有语法可见性均定义在package这个级别。</p>
<h3 id="import-路径中的最后一个元素到底代表的是-目录还是包名"><a href="#import-路径中的最后一个元素到底代表的是-目录还是包名" class="headerlink" title="import 路径中的最后一个元素到底代表的是 目录还是包名?"></a>import 路径中的最后一个元素到底代表的是 目录还是包名?</h3><h3 id="编译时使用的是包源码还是-a"><a href="#编译时使用的是包源码还是-a" class="headerlink" title="编译时使用的是包源码还是.a"></a>编译时使用的是包源码还是.a</h3><p>我们知道一个非main包在编译后会生成一个.a文件（在临时目录下生成，除非使用go install安装到$GOROOT或$GOPATH下，否则你看不到.a），用于后续可执行程序链接使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2018/01/21/golang的import介绍/" data-id="ckw5yql4t002ep8nuf0c5jrqp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ElasticSearch基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/15/ElasticSearch基础知识/" class="article-date">
  <time datetime="2017-11-15T02:25:47.000Z" itemprop="datePublished">2017-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/15/ElasticSearch基础知识/">ElasticSearch基础知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>创建一个索引</p>
<pre><code>   curl -XPUT  http://10.95.116.44:9202/test11 -d &apos;{
    &quot;settings&quot;:{
        &quot;number_of_shards&quot;: 5,
        &quot;number_of_replicas&quot;: 1
    },
    &quot;mappings&quot; : {
        &quot;prod&quot;: {
            &quot;dynamic&quot;: &quot;strict&quot;,
            &quot;properties&quot;: {
                &quot;brand_code&quot;: {
                    &quot;type&quot;: &quot;integer&quot;
                },
                &quot;brand&quot;: {
                    &quot;type&quot;: &quot;string&quot;
                }
            }
        }
    }
}&apos;
</code></pre></li>
<li><p>查看索引的setting</p>
<pre><code>curl -XGET http://10.95.116.44:9202/test11/_mapping
</code></pre></li>
<li><p>添加一条数据</p>
</li>
</ol>
<ol start="4">
<li>查看一条记录</li>
</ol>
<pre><code>curl -XGET &quot;http://10.95.116.44:9202/megacorp/employee/1&quot;
</code></pre><ol start="5">
<li><p>检索接口</p>
<pre><code>    curl -XGET &quot;http://10.95.116.44:9202/megacorp/employee/_search?pretty&quot;
{
  &quot;took&quot; : 16,
  &quot;timed_out&quot; : false,
  &quot;_shards&quot; : {
    &quot;total&quot; : 5,
    &quot;successful&quot; : 5,
    &quot;failed&quot; : 0
  },
  &quot;hits&quot; : {
    &quot;total&quot; : 1,
    &quot;max_score&quot; : 1.0,
    &quot;hits&quot; : [ {
      &quot;_index&quot; : &quot;megacorp&quot;,
      &quot;_type&quot; : &quot;employee&quot;,
      &quot;_id&quot; : &quot;1&quot;,
      &quot;_score&quot; : 1.0,
      &quot;_source&quot; : {
        &quot;first_name&quot; : &quot;John&quot;,
        &quot;last_name&quot; : &quot;Smith&quot;,
        &quot;age&quot; : 25,
        &quot;about&quot; : &quot;I love to go rock climbing&quot;,
        &quot;interests&quot; : [ &quot;sports&quot;, &quot;music&quot; ]
      }
    } ]
  }
}
</code></pre></li>
</ol>
<p>5.1 使用查询语句进行</p>
<pre><code>curl -XGET &quot;http://10.95.116.44:9202/megacorp/employee/_search&quot; -d &apos;
{
    &quot;query&quot;: {
        &quot;match&quot;: {
            &quot;first_name&quot;: &quot;John&quot;
        }
    }
}&apos;
</code></pre><p>5.2 更复杂的查询语句</p>
<pre><code>curl -XGET &quot;http://10.95.116.44:9202/megacorp/employee/_search&quot; -d &apos;
{
    &quot;query&quot; : {
        &quot;bool&quot;: {
            &quot;must&quot;: {
                &quot;match&quot; : {
                    &quot;last_name&quot; : &quot;Smith&quot; 
                }
            },
            &quot;filter&quot;: {
                &quot;range&quot; : {
                    &quot;age&quot; : { &quot;gt&quot; : 20 } 
                }
            }
        }
    }
}
&apos;
</code></pre><p>5.3 全文搜索</p>
<p>5.4 短语搜索 match_phrase</p>
<h2 id="集群内部原理"><a href="#集群内部原理" class="headerlink" title="集群内部原理"></a>集群内部原理</h2><ol>
<li><p>查看集群健康</p>
<pre><code>/_cluster/health
</code></pre></li>
<li><p>当master节点都挂了以后，查看机器健康状态就有问题，会报错：</p>
<pre><code>master_not_discovered_exception
</code></pre></li>
</ol>
<h2 id="数据输入与输出"><a href="#数据输入与输出" class="headerlink" title="数据输入与输出"></a>数据输入与输出</h2><ol>
<li><p>取回一个文档</p>
<p> GET /website/blog/123?pretty</p>
</li>
<li><p>取回一个文档的一部分</p>
<p> GET /website/blog/123?pretty&amp;_source=title,text</p>
</li>
<li><p>删除一个文档</p>
<p> DELETE /website/blog/123</p>
</li>
<li><p>判断一个文档是否存在 </p>
<p> HEAD /website/blog/123</p>
<p> 如果有status code = 200;<br> 如果没有 status code = 404</p>
</li>
<li><p>处理冲突</p>
<p> 在数据库领域中，有两种方法通常被用来确保并发更新时变更不会丢失：</p>
<ul>
<li><p>乐观并发控制</p>
<p>  采用compare_and_set的方式， Elasticsearch 使用这个 _version 号来确保变更以正确顺序得到执行。如果旧版本的文档在新版本之后到达，它可以被简单的忽略。冲突时返回的status code 是 409 Conflict HTTP 响应码。</p>
</li>
<li><p>悲观并发控制<br>  采用加锁的方式来做</p>
</li>
</ul>
</li>
</ol>
<ol start="6">
<li>mapping新增一个字段 其中employee是type，新增一个string类型的名为onSale的字段</li>
</ol>
<pre><code>curl -XPOST &quot;http://10.95.177.126:9201/megacorp/employee/_mapping&quot; -d &apos;

{
     &quot;employee&quot;: {
                &quot;properties&quot;: {
                 &quot;onSale&quot;:{
                    &quot;type&quot;:&quot;string&quot; 
               }
            }
        }
}&apos;
</code></pre><ol start="7">
<li><p>文档的部分更新</p>
<p> <a href="https://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/partial-updates.html" target="_blank" rel="noopener">https://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/partial-updates.html</a></p>
</li>
</ol>
<h2 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h2><ol>
<li><p>新建、索引和删除文档</p>
<p> 数据写入时如何是写入成功呢？</p>
<ul>
<li>在客户端收到成功响应时，文档变更已经在主分片和所有副本分片执行完成，变更是安全的。</li>
<li>默认情况下，主分片 需要 规定数量(quorum),或大多数的分片 (其中分片副本可以是主分片或者副本分片)在写入操作时可用。这是为了防止将数据写入到网络分区的‘<code>背面’&#39;。规定的数量定义公式如下：
  +</code>int( (primary + number_of_replicas) / 2 ) + 1`</li>
</ul>
</li>
<li><p>取回一个文档</p>
<ul>
<li>为了读取请求，协调节点在每次请求的时候将选择不同的副本分片来达到负载均衡；通过轮询所有的副本分片。</li>
</ul>
</li>
</ol>
<pre><code>问题：取回是从主分片取还是从副本取呢？？
</code></pre><ol start="3">
<li><p>局部更新文档</p>
<p> 在主分片上更新，同时并行转发给replicas分片。</p>
</li>
<li><p>多文档模式</p>
<p> <a href="https://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/distrib-multi-doc.html" target="_blank" rel="noopener">https://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/distrib-multi-doc.html</a></p>
</li>
</ol>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><ol>
<li><p>空搜索</p>
<p>响应的字段取值</p>
<p> |字段取值|含义|<br> |—|—|<br> |took|告诉我们执行整个搜索请求耗费了多少毫秒<br> |请求中的timeout|默认情况下，搜索请求不会超时。 如果低响应时间比完成结果更重要，你可以指定 timeout 为 10 或者 10ms（10毫秒），或者 1s（1秒），在请求超时之前，Elasticsearch 将会返回已经成功从每个分片获取的结果。 timeout 不是停止执行查询，它仅仅是告知正在协调的节点返回到目前为止收集的结果并且关闭连接。在后台，其他的分片可能仍在执行查询即使是结果已经被发送了。使用超时是因为 SLA(服务等级协议)对你是很重要的，而不是因为想去中止长时间运行的查询。|<br> |响应中timed_out|表示是否超时|<br> |_shards| 告诉我们在查询中参与分片的总数，以及这些分片成功了多少个失败了多少个。正常情况下我们不希望分片失败，但是分片失败是可能发生的。如果我们遭遇到一种灾难级别的故障，在这个故障中丢失了相同分片的原始数据和副本，那么对这个分片将没有可用副本来对搜索请求作出响应。假若这样，Elasticsearch 将报告这个分片是失败的，但是会继续返回剩余分片的结果。|<br> |hits|它 包含 total 字段来表示匹配到的文档总数，并且一个 hits 数组包含所查询结果的前十个文档.在 hits 数组中每个结果包含文档的 _index 、 _type 、 _id ，加上 _source 字段。这意味着我们可以直接从返回的搜索结果中使用整个文档。这不像其他的搜索引擎，仅仅返回文档的ID，需要你单独去获取文档。</p>
</li>
<li><p>分页</p>
<p> 参数from=0&amp;size=1，</p>
<p> 理解为什么深度分页是有问题的，我们可以假设在一个有 5 个主分片的索引中搜索。 当我们请求结果的第一页（结果从 1 到 10 ），每一个分片产生前 10 的结果，并且返回给 协调节点 ，协调节点对 50 个结果排序得到全部结果的前 10 个。</p>
<p> 现在假设我们请求第 1000 页–结果从 10001 到 10010 。所有都以相同的方式工作除了每个分片不得不产生前10010个结果以外。 然后协调节点对全部 50050 个结果排序最后丢弃掉这些结果中的 50040 个结果。</p>
<p> 可以看到，在分布式系统中，对结果排序的成本随分页的深度成指数上升。这就是 web 搜索引擎对任何查询都不要返回超过 1000 个结果的原因。</p>
</li>
</ol>
<h2 id="映射和分析"><a href="#映射和分析" class="headerlink" title="映射和分析"></a>映射和分析</h2><ol>
<li>精确值和全文</li>
<li>倒排索引</li>
<li><p>分析与分析器</p>
<p> 分析 包含下面的过程：</p>
<ul>
<li>首先，将一块文本分成适合于倒排索引的独立的 词条 ，</li>
<li><p>之后，将这些词条统一化为标准格式以提高它们的”可搜索性”，或者 recall</p>
<p>分析器 实际上是将三个功能封装到了一个包里：</p>
</li>
<li><p>字符过滤器<br>首先，字符串按顺序通过每个 字符过滤器 。他们的任务是在分词前整理字符串。一个字符过滤器可以用来去掉HTML，或者将 &amp; 转化成 <code>and</code>。</p>
</li>
<li>分词器<br>其次，字符串被 分词器 分为单个的词条。一个简单的分词器遇到空格和标点的时候，可能会将文本拆分成词条。</li>
<li><p>Token 过滤器<br>最后，词条按顺序通过每个 token 过滤器 。这个过程可能会改变词条</p>
<h3 id="内置分析器"><a href="#内置分析器" class="headerlink" title="内置分析器"></a>内置分析器</h3><p>对于一个例子</p>
<p>  “Set the shape to semi-transparent by calling set_trans(5)”</p>
</li>
</ul>
</li>
</ol>
<pre><code>+ 标准分析器：它根据 Unicode 联盟 定义的 单词边界 划分文本。删除绝大部分标点。最后，将词条小写。
    `set, the, shape, to, semi, transparent, by, calling, set_trans, 5`
+ 简单分析器
简单分析器在任何不是字母的地方分隔文本，将词条小写
    `set, the, shape, to, semi, transparent, by, calling, set, trans`
+ 空格分析器
空格分析器在空格的地方划分文本

    `Set, the, shape, to, semi-transparent, by, calling, set_trans(5)`
+ 语言分析器

    特定语言分析器可用于 很多语言。它们可以考虑指定语言的特点。例如， 英语 分析器附带了一组英语无用词（常用单词，例如 and 或者 the ，它们对相关性没有多少影响），它们会被删除。 由于理解英语语法的规则，这个分词器可以提取英语单词的 词干 .

    `set, shape, semi, transpar, call, set_tran, 5`

### 什么时候使用分析器

全文查询，理解每个域是如何定义的，因此它们可以做 正确的事：

+ 当你查询一个 全文 域时， 会对查询字符串应用相同的分析器，以产生正确的搜索词条列表。
+ 当你查询一个 精确值 域时，不会分析查询字符串， 而是搜索你指定的精确值。

### 注意：

当Elasticsearch在你的文档中检测到一个新的字符串域 ，它会自动设置其为一个全文 字符串 域，使用 标准 分析器对它进行分析。


### 测试分析器


    GET /_analyze
    {
      &quot;analyzer&quot;: &quot;standard&quot;,
      &quot;text&quot;: &quot;Text to analyze&quot;
    }
这样得到分析结果

    {
       &quot;tokens&quot;: [
          {
             &quot;token&quot;:        &quot;text&quot;,
             &quot;start_offset&quot;: 0,
             &quot;end_offset&quot;:   4,
             &quot;type&quot;:         &quot;&lt;ALPHANUM&gt;&quot;,
             &quot;position&quot;:     1
          },
          {
             &quot;token&quot;:        &quot;to&quot;,
             &quot;start_offset&quot;: 5,
             &quot;end_offset&quot;:   7,
             &quot;type&quot;:         &quot;&lt;ALPHANUM&gt;&quot;,
             &quot;position&quot;:     2
          },
          {
             &quot;token&quot;:        &quot;analyze&quot;,
             &quot;start_offset&quot;: 8,
             &quot;end_offset&quot;:   15,
             &quot;type&quot;:         &quot;&lt;ALPHANUM&gt;&quot;,
             &quot;position&quot;:     3
          }
       ]
    }
</code></pre><ol start="4">
<li>映射</li>
</ol>
<pre><code>Elasticsearch 支持 如下简单域类型：

+ 字符串: string
+ 整数 : byte, short, integer, long
+ 浮点数: float, double
+ 布尔型: boolean
+ 日期: date

JSON中类型与Elasticsearch类型对应

|Json类型|Elasticsearch类型|
|---|---|
|true/false|boolean|
|123|long|
|123.45|double|
|字符串，有效日期: 2014-09-15|date|
|字符串foo bar| string|

### string域 
string 域映射的两个最重要 属性是 index 和 analyzer 。
index的取值

|index取值|含义|
|---|---|
| analyzed|首先分析字符串，然后索引它。换句话说，以全文索引这个域|
| not_analyzed|索引这个域，所以可以搜索到它，但索引指定的精确值。不对它进行分析|
| no|不索引这个域。这个域不会被搜索到|

analyzer的取值

对于 analyzed 字符串域，用 analyzer 属性指定在搜索和索引时使用的分析器。默认， Elasticsearch 使用 standard 分析器， 但你可以指定一个内置的分析器替代它，例如 whitespace 、 simple 和 `english`
</code></pre><ol start="5">
<li><p>复杂核心域类型</p>
<ul>
<li>数组 { “tag”: [ “search”, “nosql” ]}<ul>
<li>数组中所有的值必须是相同数据类型的</li>
</ul>
</li>
<li><p>空域 null,[],[null]</p>
<ul>
<li>空域不会被索引</li>
</ul>
</li>
<li><p>多层级对象<br>  内部对象 经常用于 嵌入一个实体或对象到其它对象中。<br>  Elasticsearch 会动态 监测新的对象域并映射它们为 对象 ，在 properties 属性下列出内部域，</p>
<ul>
<li>user 和 name 域的映射结构与 tweet 类型的相同。事实上， type 映射只是一种特殊的 对象 映射，我们称之为 根对象 。除了它有一些文档元数据的特殊顶级域，例如 _source 和 _all 域，它和其他对象一样。</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>        {
          &quot;gb&quot;: {
            &quot;tweet&quot;: { 
              &quot;properties&quot;: {
                &quot;tweet&quot;:            { &quot;type&quot;: &quot;string&quot; },
                &quot;user&quot;: { 
                  &quot;type&quot;:             &quot;object&quot;,
                  &quot;properties&quot;: {
                    &quot;id&quot;:           { &quot;type&quot;: &quot;string&quot; },
                    &quot;gender&quot;:       { &quot;type&quot;: &quot;string&quot; },
                    &quot;age&quot;:          { &quot;type&quot;: &quot;long&quot;   },
                    &quot;name&quot;:   { 
                      &quot;type&quot;:         &quot;object&quot;,
                      &quot;properties&quot;: {
                        &quot;full&quot;:     { &quot;type&quot;: &quot;string&quot; },
                        &quot;first&quot;:    { &quot;type&quot;: &quot;string&quot; },
                        &quot;last&quot;:     { &quot;type&quot;: &quot;string&quot; }
                      }
                    }
                  }
                }
              }
            }
          }
        } 


+ 内部对象是如何进行索引的。


    Lucene 不理解内部对象。 Lucene 文档是由一组键值对列表组成的。为了能让 Elasticsearch 有效地索引内部类，它把我们的文档转化成这样：

        {
            &quot;tweet&quot;:            [elasticsearch, flexible, very],
            &quot;user.id&quot;:          [@johnsmith],
            &quot;user.gender&quot;:      [male],
            &quot;user.age&quot;:         [26],
            &quot;user.name.full&quot;:   [john, smith],
            &quot;user.name.first&quot;:  [john],
            &quot;user.name.last&quot;:   [smith]
        }

+ 内部对象数组 最后，考虑包含 内部对象的数组是如何被索引的

    假设我们有个 followers 数组：

        {
            &quot;followers&quot;: [
                { &quot;age&quot;: 35, &quot;name&quot;: &quot;Mary White&quot;},
                { &quot;age&quot;: 26, &quot;name&quot;: &quot;Alex Jones&quot;},
                { &quot;age&quot;: 19, &quot;name&quot;: &quot;Lisa Smith&quot;}
            ]
        }

    这个文档会像我们之前描述的那样被扁平化处理，结果如下所示：

        {
            &quot;followers.age&quot;:    [19, 26, 35],
            &quot;followers.name&quot;:   [alex, jones, lisa, smith, mary, white]
        }
</code></pre><h2 id="请求体查询"><a href="#请求体查询" class="headerlink" title="请求体查询"></a>请求体查询</h2><ol>
<li>查询表达式</li>
</ol>
<pre><code>一个查询语句的典型结构：

    {
        QUERY_NAME: {
            ARGUMENT: VALUE,
            ARGUMENT: VALUE,...
        }
    }

如果针对某个字段，其结构如下：

    {
        QUERY_NAME: {
            FIELD_NAME: {
                ARGUMENT: VALUE,
                ARGUMENT: VALUE,...
            }
        }
    }
举个例子，你可以使用 match 查询语句 来查询 tweet 字段中包含 elasticsearch 的 tweet：

    {
        &quot;match&quot;:{
            &quot;tweet&quot;:&quot;elasticsearch&quot;
        }
    }

完整的查询语句：

    GET /_search
    {
        &quot;query&quot;: {
            &quot;match&quot;: {
                &quot;tweet&quot;: &quot;elasticsearch&quot;
            }
        }
    }
</code></pre><ol start="2">
<li><p>合并查询语句</p>
<p> 查询语句Query Clasues就像一些简单的组合块，这些组合块可以彼此之间合并组成更复杂的查询。如下：</p>
<ul>
<li>叶子语句 Leaf Clauses：用于将查询字符串和一个字段对比</li>
<li><p>复合Compound语句：合并其他查询语句，比如一个bool语句 允许在你需要的时候组合其他语句，无论是<code>must</code>，<code>must not</code>, <code>should</code>，同时它可以包含不评分的过滤器<code>filters</code></p>
<pre><code>{
    &quot;bool&quot;: {
        &quot;must&quot;:     { &quot;match&quot;: { &quot;tweet&quot;: &quot;elasticsearch&quot; }},
        &quot;must_not&quot;: { &quot;match&quot;: { &quot;name&quot;:  &quot;mary&quot; }},
        &quot;should&quot;:   { &quot;match&quot;: { &quot;tweet&quot;: &quot;full text&quot; }},
        &quot;filter&quot;:   { &quot;range&quot;: { &quot;age&quot; : { &quot;gt&quot; : 30 }} }
    }
}
</code></pre><p>一条复合语句可以合并 任何 其它查询语句，包括复合语句，了解这一点是很重要的。这就意味着，复合语句之间可以互相嵌套，可以表达非常复杂的逻辑。</p>
</li>
</ul>
</li>
<li><p>查询与过滤</p>
<p> Elasticsearch使用的查询语言可以以无限组合的方式进行搭配，可以在以下两种情况下使用：过滤情况(filtering context)和查询情况（query context)。</p>
<ul>
<li>过滤情况：回答是 yes/no，二者必居其一。</li>
<li><p>查询情况：查询就变成了一个“评分”的查询。        </p>
<p>但从 Elasticsearch 2.0 开始，过滤（filters）已经从技术上被排除了，同时所有的查询（queries）拥有变成不评分查询的能力</p>
<p>性能差异</p>
</li>
<li><p>过滤查询（Filtering queries）只是简单的检查包含或者排除，这就使得计算起来非常快。考虑到至少有一个过滤查询（filtering query）的结果是 “稀少的”（很少匹配的文档），并且经常使用不评分查询（non-scoring queries），结果会被缓存到内存中以便快速读取，所以有各种各样的手段来优化查询结果。</p>
</li>
<li><p>评分查询（scoring queries）不仅仅要找出 匹配的文档，还要计算每个匹配文档的相关性，计算相关性使得它们比不评分查询费力的多。同时，查询结果并不缓存。</p>
<p>如何选择过滤或评分</p>
<p>通常的规则是，使用 查询（query）语句来进行 全文 搜索或者其它任何需要影响 相关性得分 的搜索。除此以外的情况都使用过滤（filters)。</p>
</li>
</ul>
</li>
<li><p>重要的查询</p>
<ul>
<li><code>match_all</code> 查询简单的 匹配所有文档</li>
<li><p><code>match</code>查询：无论你在任何字段上进行的是全文搜索还是精确查询，match 查询是你可用的标准查询。</p>
<ul>
<li>如果是全文搜索，会先进行分析 { “match”: { “tweet”: “About Search” }}</li>
</ul>
</li>
<li><p><code>multi_match</code>查询：multi_match 查询可以在多个字段上执行相同的 match 查询</p>
<pre><code>{
    &quot;multi_match&quot;: {
        &quot;query&quot;:    &quot;full text search&quot;,
        &quot;fields&quot;:   [ &quot;title&quot;, &quot;body&quot; ]
    }
}
</code></pre></li>
<li><p><code>range</code>查询 查询找出那些落在指定区间内的数字或者时间，被允许的操作符：gt,lt,gte,lte</p>
<pre><code>{
    &quot;range&quot;: {
        &quot;age&quot;: {
            &quot;gte&quot;:  20,
            &quot;lt&quot;:   30
        }
    }
}
</code></pre></li>
<li><p><code>term</code>查询 term 查询被用于精确值 匹配，这些精确值可能是数字、时间、布尔或者那些 not_analyzed 的字符串</p>
<pre><code>{ &quot;term&quot;: { &quot;age&quot;:    26           }}
{ &quot;term&quot;: { &quot;date&quot;:   &quot;2014-09-01&quot; }}
</code></pre></li>
<li><p><code>terms</code>查询：和 term 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件</p>
<pre><code>{ &quot;terms&quot;: { &quot;tag&quot;: [ &quot;search&quot;, &quot;full_text&quot;, &quot;nosql&quot; ] }}
</code></pre></li>
</ul>
</li>
</ol>
<ol start="5">
<li><p>组合查询</p>
<ul>
<li><p><code>bool查询</code>，可以接收以下参数：</p>
<ul>
<li>must:文档 必须 匹配这些条件才能被包含进来。</li>
<li>must_not:文档 必须不 匹配这些条件才能被包含进来</li>
<li>should:如果满足这些语句中的任意语句，将增加 _score ，否则，无任何影响。它们主要用于修正每个文档的相关性得分</li>
<li>filter:必须 匹配，但它以不评分、过滤模式来进行。这些语句对评分没有贡献，只是根据过滤标准来排除或包含文档。</li>
</ul>
<p>举例：下面的查询用于查找 title 字段匹配 how to make millions 并且不被标识为 spam 的文档。那些被标识为 starred 或在2014之后的文档，将比另外那些文档拥有更高的排名。如果 _两者_ 都满足，那么它排名将更高：</p>
<p>  {</p>
<pre><code>&quot;bool&quot;: {
    &quot;must&quot;:     { &quot;match&quot;: { &quot;title&quot;: &quot;how to make millions&quot; }},
    &quot;must_not&quot;: { &quot;match&quot;: { &quot;tag&quot;:   &quot;spam&quot; }},
    &quot;should&quot;: [
        { &quot;match&quot;: { &quot;tag&quot;: &quot;starred&quot; }},
        { &quot;range&quot;: { &quot;date&quot;: { &quot;gte&quot;: &quot;2014-01-01&quot; }}}
    ]
}
</code></pre><p>  }</p>
<p>假如不想文档的时间影响评分，则可以<code>增加带过滤器的查询</code>：</p>
<p>  {</p>
<pre><code>&quot;bool&quot;: {
    &quot;must&quot;:     { &quot;match&quot;: { &quot;title&quot;: &quot;how to make millions&quot; }},
    &quot;must_not&quot;: { &quot;match&quot;: { &quot;tag&quot;:   &quot;spam&quot; }},
    &quot;should&quot;: [
        { &quot;match&quot;: { &quot;tag&quot;: &quot;starred&quot; }}
    ],
    &quot;filter&quot;: {
      &quot;range&quot;: { &quot;date&quot;: { &quot;gte&quot;: &quot;2014-01-01&quot; }} 
    }
}
</code></pre><p>  }</p>
<p>所有查询都可以借鉴这种方式。将查询移到 bool 查询的 filter 语句中，这样它就自动的转成一个不评分的 filter 了。</p>
</li>
</ul>
</li>
</ol>
<ul>
<li><p><code>constant_score</code>查询</p>
<p>  constant_score 查询也是你工具箱里有用的查询工具。它将一个不变的常量评分应用于所有匹配的文档。它被经常用于你只需要执行一个 filter 而没有其它查询。<br>  可以使用它来取代只有 filter 语句的 bool 查询。在性能上是完全相同的，但对于提高查询简洁性和清晰度有很大帮助。</p>
</li>
</ul>
<pre><code>term 查询被放置在 constant_score 中，转成不评分的 filter

    {
        &quot;constant_score&quot;:   {
            &quot;filter&quot;: {
                &quot;term&quot;: { &quot;category&quot;: &quot;ebooks&quot; } 
            }
        }
    }
</code></pre><h2 id="排序和相关性"><a href="#排序和相关性" class="headerlink" title="排序和相关性"></a>排序和相关性</h2><ol>
<li><p>排序</p>
<p> 为了按照相关性来排序，需要将相关性表示为一个数值。在 Elasticsearch 中， 相关性得分 由一个浮点数进行表示，并在搜索结果中通过 _score 参数返回， 默认排序是 _score 降序。</p>
<ul>
<li><p>按照字段的值进行排序</p>
<p>  我们可以使用 sort 参数进行实现</p>
<p>  返回结果中<code>_score</code>是不会被计算的。</p>
<pre><code>GET /_search

{
    &quot;query&quot; : {
        &quot;bool&quot; : {
            &quot;filter&quot; : { &quot;term&quot; : { &quot;user_id&quot; : 1 }}
        }
    },
    &quot;sort&quot;: { &quot;date&quot;: { &quot;order&quot;: &quot;desc&quot; }}
}
</code></pre></li>
<li><p>多级排序</p>
<pre><code>GET /_search
{
    &quot;query&quot; : {
        &quot;bool&quot; : {
            &quot;must&quot;:   { &quot;match&quot;: { &quot;tweet&quot;: &quot;manage text search&quot; }},
            &quot;filter&quot; : { &quot;term&quot; : { &quot;user_id&quot; : 2 }}
        }
    },
    &quot;sort&quot;: [
        { &quot;date&quot;:   { &quot;order&quot;: &quot;desc&quot; }},
        { &quot;_score&quot;: { &quot;order&quot;: &quot;desc&quot; }}
    ]
}
</code></pre></li>
</ul>
</li>
</ol>
<ol start="2">
<li><p><a href="https://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/relevance-intro.html" target="_blank" rel="noopener">相关性</a></p>
<p> Elasticsearch 的相似度算法 被定义为检索词频率/反向文档频率， TF/IDF，包括以下内容：</p>
</li>
<li><p><a href="https://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/docvalues-intro.html" target="_blank" rel="noopener">Doc Value介绍</a></p>
</li>
</ol>
<h2 id="执行分布式检索"><a href="#执行分布式检索" class="headerlink" title="执行分布式检索"></a>执行分布式检索</h2><h2 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h2><ol>
<li><p>创建一个索引</p>
<pre><code>PUT /my_index
{
    &quot;settings&quot;: { ... any settings ... },
    &quot;mappings&quot;: {
        &quot;type_one&quot;: { ... any mappings ... },
        &quot;type_two&quot;: { ... any mappings ... },
        ...
    }
}
</code></pre><p> action.auto_create_index: false</p>
</li>
<li><p>删除一个索引</p>
<pre><code>DELETE /my_index
DELETE /my_index*
</code></pre></li>
<li><p>索引设置</p>
<p> 两个最重要的设置</p>
<ul>
<li><code>number_of_shards</code><br>每个索引的主分片数，默认值是 5 。这个配置在索引创建后不能修改。</li>
<li><p><code>number_of_replicas</code><br>每个主分片的副本数，默认值是 1 。对于活动的索引库，这个配置可以随时修改。</p>
<p>修改副本配置</p>
<p>  PUT /my_temp_index/_settings<br>  {</p>
<pre><code>&quot;number_of_replicas&quot;: 1
</code></pre><p>  }</p>
</li>
</ul>
</li>
<li><p>配置分析器</p>
<p> 第三个重要的索引设置是 analysis 部分， 用来配置已存在的分析器或针对你的索引创建新的自定义分析器。</p>
</li>
</ol>
<pre><code>`standard `分析器是用于全文字段的默认分析器， 对于大部分西方语系来说是一个不错的选择。 它包括了以下几点：

+ standard 分词器，通过单词边界分割输入的文本。
+ standard 语汇单元过滤器，目的是整理分词器触发的语汇单元（但是目前什么都没做）。
+ lowercase 语汇单元过滤器，转换所有的语汇单元为小写。
+ stop 语汇单元过滤器，删除停用词--对搜索相关性影响不大的常用词，如 a ， the ， and ， is 。

    默认情况下，停用词过滤器是被禁用的。如需启用它，你可以通过创建一个基于 standard 分析器的自定义分析器并设置 stopwords 参数。 可以给分析器提供一个停用词列表，或者告知使用一个基于特定语言的预定义停用词列表
</code></pre><ol start="5">
<li><p>自定义分析器</p>
<p> 一个 分析器 就是在一个包里面组合了三种函数的一个包装器</p>
<ul>
<li>字符过滤器：用来处理一个尚未被分词的字符串。可以包含多个字符过滤器</li>
<li>分词器：一个分析器 必须 有一个唯一的分词器。 分词器把字符串分解成单个词条或者词汇单元。 standard 分析器里使用的standard分词器 把一个字符串根据单词边界分解成单个词条，并且移除掉大部分的标点符号。</li>
<li><p>token过滤器：经过分词，作为结果的 词单元流 会按照指定的顺序通过指定的词单元过滤器。</p>
<h3 id="创建一个自定义的分析器"><a href="#创建一个自定义的分析器" class="headerlink" title="创建一个自定义的分析器"></a>创建一个自定义的分析器</h3><p>格式：</p>
<p>  PUT /my_index<br>  {</p>
<pre><code>&quot;settings&quot;: {
    &quot;analysis&quot;: {
        &quot;char_filter&quot;: { ... custom character filters ... },
        &quot;tokenizer&quot;:   { ...    custom tokenizers     ... },
        &quot;filter&quot;:      { ...   custom token filters   ... },
        &quot;analyzer&quot;:    { ...    custom analyzers      ... }
    }
}
</code></pre><p>  }</p>
<p>字符过滤器：将&amp;替换为and,</p>
<pre><code>&quot;char_filter&quot;: {
      &quot;&amp;_to_and&quot;: {
      &quot;type&quot;:       &quot;mapping&quot;,
      &quot;mappings&quot;: [ &quot;&amp;=&gt; and &quot;]
}},
</code></pre><p>token过滤器：</p>
<p>  “filter”: {</p>
<pre><code>&quot;my_stopwords&quot;: {
    &quot;type&quot;:       &quot;stop&quot;,
    &quot;stopwords&quot;: [ &quot;the&quot;, &quot;a&quot; ]
}
</code></pre><p>  },<br>分析：</p>
<p>  “analyzer”: {</p>
<pre><code>&quot;my_analyzer&quot;: {
    &quot;type&quot;:         &quot;custom&quot;,
    &quot;char_filter&quot;:  [ &quot;html_strip&quot;, &quot;&amp;_to_and&quot; ],
    &quot;tokenizer&quot;:    &quot;standard&quot;,
    &quot;filter&quot;:       [ &quot;lowercase&quot;, &quot;my_stopwords&quot; ]
}
</code></pre><p>  }</p>
<p>整体设置：</p>
<p>  PUT /my_index<br>  {</p>
<pre><code>&quot;settings&quot;: {
    &quot;analysis&quot;: {
        &quot;char_filter&quot;: {
            &quot;&amp;_to_and&quot;: {
                &quot;type&quot;:       &quot;mapping&quot;,
                &quot;mappings&quot;: [ &quot;&amp;=&gt; and &quot;]
        }},
        &quot;filter&quot;: {
            &quot;my_stopwords&quot;: {
                &quot;type&quot;:       &quot;stop&quot;,
                &quot;stopwords&quot;: [ &quot;the&quot;, &quot;a&quot; ]
        }},
        &quot;analyzer&quot;: {
            &quot;my_analyzer&quot;: {
                &quot;type&quot;:         &quot;custom&quot;,
                &quot;char_filter&quot;:  [ &quot;html_strip&quot;, &quot;&amp;_to_and&quot; ],
                &quot;tokenizer&quot;:    &quot;standard&quot;,
                &quot;filter&quot;:       [ &quot;lowercase&quot;, &quot;my_stopwords&quot; ]
        }}
</code></pre><p>  }}}</p>
<p>索引被创建以后，使用 analyze API 来 测试这个新的分析器：</p>
<p>  curl -XGET “<a href="http://10.95.177.126:9201/my_index/_analyze?analyzer=my_analyzer&amp;pretty&quot;" target="_blank" rel="noopener">http://10.95.177.126:9201/my_index/_analyze?analyzer=my_analyzer&amp;pretty&quot;</a> -d “ The quick &amp; brown fox”<br>  {</p>
<pre><code>&quot;tokens&quot; : [ {
  &quot;token&quot; : &quot;quick&quot;,
  &quot;start_offset&quot; : 5,
  &quot;end_offset&quot; : 10,
  &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,
  &quot;position&quot; : 1
}, {
  &quot;token&quot; : &quot;and&quot;,
  &quot;start_offset&quot; : 11,
  &quot;end_offset&quot; : 12,
  &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,
  &quot;position&quot; : 2
}, {
  &quot;token&quot; : &quot;brown&quot;,
  &quot;start_offset&quot; : 13,
  &quot;end_offset&quot; : 18,
  &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,
  &quot;position&quot; : 3
}, {
  &quot;token&quot; : &quot;fox&quot;,
  &quot;start_offset&quot; : 19,
  &quot;end_offset&quot; : 22,
  &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,
  &quot;position&quot; : 4
} ]
</code></pre><p>  }</p>
</li>
</ul>
</li>
<li><p>类型和映射</p>
<ul>
<li><code>类型</code>在 Elasticsearch 中表示一类相似的文档</li>
<li><p><code>映射</code> 就像数据库中的 schema ，描述了文档可能具有的字段或 属性 、 每个字段的数据类型，以及Lucene是如何索引和存储这些字段的</p>
<p>避免类型陷阱</p>
<p>这导致了一个有趣的思想实验： 如果有两个不同的类型，每个类型都有同名的字段，但映射不同（例如：一个是字符串一个是数字），将会出现什么情况？</p>
<p>简单回答是，Elasticsearch 不会允许你定义这个映射。当你配置这个映射时，将会出现异常。</p>
</li>
</ul>
</li>
</ol>
<ol start="7">
<li>根对象</li>
</ol>
<pre><code>映射的最高一层被称为 根对象 ，它可能包含下面几项：

+ 一个 properties 节点，列出了文档中可能包含的每个字段的映射
+ 各种元数据字段，它们都以一个下划线开头，例如 _type 、 _id 和 _source
+ 设置项，控制如何动态处理新的字段，例如 analyzer 、 dynamic_date_formats 和 dynamic_templates
+ 其他设置，可以同时应用在根对象和其他 object 类型的字段上，例如 enabled 、 dynamic 和 include_in_all

### 属性

+ type：字段的数据类型，例如 string 或 date
+ index：字段是否应当被当成全文来搜索（ analyzed ），或被当成一个准确的值（ not_analyzed ），还是完全不可被搜索（ no ）
+ analyzer：确定在索引和搜索时全文字段使用的 analyzer
+ ip ,`geo_point` , `geo_shape`

### 元数据：`_source`字段

这个字段的存储几乎总是我们想要的，因为它意味着下面的这些：

+ 搜索结果包括了整个可用的文档——不需要额外的从另一个的数据仓库来取文档。
+ 如果没有 _source 字段，部分 update 请求不会生效。
+ 当你的映射改变时，你需要重新索引你的数据，有了_source字段你可以直接从Elasticsearch这样做，而不必从另一个（通常是速度更慢的）数据仓库取回你的所有文档。
+ 当你不需要看到整个文档时，单个字段可以从 _source 字段提取和通过 get 或者 search 请求返回。
+ 调试查询语句更加简单，因为你可以直接看到每个文档包括什么，而不是从一列id猜测它们的内容。

### 元数据: `_all`字段

_all 字段：一个把其它字段值 当作一个大字符串来索引的特殊字段

如果你不再需要 _all 字段，你可以通过下面的映射来禁用：

    PUT /my_index/_mapping/my_type
    {
        &quot;my_type&quot;: {
            &quot;_all&quot;: { &quot;enabled&quot;: false }
        }
    }

### 元数据：文档标识

+ `_id`: 文档的 ID 字符串
+ `_type`:  文档的类型名
+ `_index`: 文档所在的索引
+ `_uid`: `_type` 和 `_id`连接在一起构造成 type#id
</code></pre><ol start="8">
<li><p>动态映射</p>
<p> 当 Elasticsearch 遇到文档中以前 未遇到的字段，它用 dynamic mapping 来确定字段的数据类型并自动把新的字段添加到类型映射。</p>
<p> dynamic取值</p>
<ul>
<li>true：动态添加新的字段–缺省</li>
<li>false：忽略新的字段</li>
<li>strict：如果遇到新字段抛出异常</li>
<li>下面的设置中，对于<code>my_type</code>出现新增字段就报异常，如果对于字段stash出现新增字段，则动态映射。</li>
</ul>
</li>
</ol>
<pre><code>PUT /my_index
{
    &quot;mappings&quot;: {
        &quot;my_type&quot;: {
            &quot;dynamic&quot;:      &quot;strict&quot;, 
            &quot;properties&quot;: {
                &quot;title&quot;:  { &quot;type&quot;: &quot;string&quot;},
                &quot;stash&quot;:  {
                    &quot;type&quot;:     &quot;object&quot;,
                    &quot;dynamic&quot;:  true 
                }
            }
        }
    }
}
</code></pre><ol start="9">
<li><p>自定义动态映射</p>
<p> <code>https://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/custom-dynamic-mapping.html</code></p>
</li>
<li><p>缺省映射</p>
<p><code>https://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/default-mapping.html</code></p>
</li>
<li><p>重新索引你的数据</p>
<p>从ES2.3开始，可以使用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-reindex.html" target="_blank" rel="noopener">reindex</a> api，它能够对文档重建索引而不需要任何插件或外部工具。</p>
</li>
<li><p>索引别名和零停机</p>
<p>索引 别名 就像一个快捷方式或软连接，可以指向一个或多个索引，也可以给任何一个需要索引名的API来使用。别名 带给我们极大的灵活性，允许我们做下面这些：</p>
<ul>
<li>在运行的集群中可以无缝的从一个索引切换到另一个索引</li>
<li>给多个索引分组 (例如， last_three_months)</li>
<li>给索引的一个子集创建 视图</li>
</ul>
<p>举例：</p>
<pre><code>PUT /my_index_v1  #创建索引my_index_v1
PUT /my_index_v1/_alias/my_index  # 设置别名 my_index指向my_index_v1
</code></pre></li>
</ol>
<h2 id="分片内部原理"><a href="#分片内部原理" class="headerlink" title="分片内部原理"></a>分片内部原理</h2><ul>
<li>为什么搜索是 近 实时的？(内存缓冲区不可被搜索，写入文件系统缓存后可以被搜索）</li>
<li>为什么文档的 CRUD (创建-读取-更新-删除) 操作是 实时 的?</li>
<li>Elasticsearch 是怎样保证更新被持久化在断电时也不丢失数据?<br>为什么删除文档不会立刻释放空间？</li>
<li>refresh, flush, 和 optimize API 都做了什么, 你什么情况下应该是用他们？</li>
</ul>
<ol>
<li><p>使文本可搜索</p>
<h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><ul>
<li><p>倒排索引被写入磁盘后是 不可改变 的:它永远不会修改。 不变性有重要的价值：</p>
<ul>
<li>不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。</li>
<li>一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。</li>
<li>其它缓存(像filter缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。</li>
<li>写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和 需要被缓存到内存的索引的使用量</li>
</ul>
</li>
</ul>
</li>
<li><p><a href="https://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/dynamic-indices.html" target="_blank" rel="noopener">动态更新索引</a></p>
<p> 下一个需要被解决的问题是怎样在保留不变性的前提下实现倒排索引的更新？ 答案是: 用更多的索引。</p>
</li>
</ol>
<h3 id="索引和分片"><a href="#索引和分片" class="headerlink" title="索引和分片"></a>索引和分片</h3><p>被混淆的概念是，一个 Lucene 索引 我们在 Elasticsearch 称作 分片 。 一个 Elasticsearch 索引 是分片的集合。 当 Elasticsearch 在索引中搜索的时候， 他发送查询到每一个属于索引的分片(Lucene 索引)，然后像 <a href="https://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/distributed-search.html" target="_blank" rel="noopener">执行分布式检索</a>  提到的那样，合并每个分片的结果到一个全局的结果集。</p>
<p>sync is a standard system call in the Unix operating system, which commits to disk all data in the kernel filesystem buffers, i.e., data which has been scheduled for writing via low-level I/O system calls. Higher-level I/O layers such as stdio may maintain separate buffers of their own.</p>
<h3 id="数据写入的流程"><a href="#数据写入的流程" class="headerlink" title="数据写入的流程"></a>数据写入的流程</h3><p>要回答的问题是：</p>
<ul>
<li>为什么搜索是 近 实时的？</li>
<li>为什么文档的 CRUD (创建-读取-更新-删除) 操作是 实时 的?</li>
<li>Elasticsearch 是怎样保证更新被持久化在断电时也不丢失数据?</li>
<li>为什么删除文档不会立刻释放空间？</li>
<li>refresh, flush, 和 optimize API 都做了什么, 你什么情况下应该是用他们？<ul>
<li>refresh将内存缓冲区数据写入文件系统缓存的segment，可以被搜索（近实时搜索）</li>
<li>flush将文件系统缓存的数据写入磁盘。执行一个提交并且截断 translog 的行为</li>
</ul>
</li>
</ul>
<ol>
<li>倒排索引写入文件以后就是不变的</li>
<li><p>倒排索引写入的流程</p>
<p> —&gt;写入内存buffer–&gt;写入文件系统缓存（一个segment）</p>
<p> —&gt;translog </p>
<p> 数据写入时在写入内存buffer时，会同时写入translog；<br> 内存buffer中的数据每隔refresh_interval（es设置，默认是1秒）写入文件系统缓存；这就是为什么我们说 Elasticsearch 是 近 实时搜索: 文档的变化并不是立即对搜索可见，但会在一秒之内变为可见<br> 当translog到达一定阈值后</p>
<ul>
<li>所有在内存缓冲区的文档会被写入一个新的段</li>
<li>缓冲区被清空</li>
<li>一个提交点被写入硬盘</li>
<li>文件系统缓存通过 fsync 被刷新（flush）</li>
<li>老的 translog 被删除</li>
</ul>
</li>
</ol>
<p>这个执行一个提交并且截断 translog 的行为在 Elasticsearch 被称作一次 flush 。 <code>分片每30分钟被自动刷新</code>（flush），或者在 <code>translog 太大的时候</code>也会刷新。请查看 translog 文档 来设置，它可以用来 控制这些阈值：</p>
<ol start="3">
<li>提交点 的概念 — 一个列出了所有已知段的文件</li>
<li><p>下面的图演示了一个完整的数据写入流程</p>
 
 
 
 
</li>
</ol>
<ol start="5">
<li><p>段合并。由于自动刷新流程每秒会创建一个新的段 ，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。 每一个段都会消耗文件句柄、内存和cpu运行周期。更重要的是，每个搜索请求都必须轮流检查每个段；所以段越多，搜索也就越慢。</p>
<p> 启动段合并不需要你做任何事。进行索引和搜索时会自动进行。会进行以下工作：</p>
<ul>
<li>当索引的时候，刷新（refresh）操作会创建新的段并将段打开以供搜索使用。</li>
<li><p>合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中。这并不会中断索引和搜索。</p>
<p><img src="//keything.github.io/2017/11/15/ElasticSearch基础知识/elas_两个提交了的段和一个未提交的段进行合并.png" alt="两个提交了的段和一个未提交的段进行合并"></p>
</li>
</ul>
</li>
</ol>
<pre><code>一旦合并结束，老的段被删除，

![合并结束老的段被删除](elas_合并结束老的段被删除.png)


通过optimize API大可看做是 强制合并 API 。它会将一个分片强制合并到 `max_num_segments` 参数指定大小的段数目。 这样做的意图是减少段的数量（通常减少到一个），来提升搜索性能

    POST /logstash-2014-10/_optimize?max_num_segments=1 
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2017/11/15/ElasticSearch基础知识/" data-id="ckw5yql3t0009p8nu77oceb7h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-go源码分析-http处理流程分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/31/go源码分析-http处理流程分析/" class="article-date">
  <time datetime="2017-10-31T06:39:54.000Z" itemprop="datePublished">2017-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/31/go源码分析-http处理流程分析/">go源码分析-http处理流程分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="【概述】"><a href="#【概述】" class="headerlink" title="【概述】"></a>【概述】</h2><p>GO的web服务器的简单helloword 服务器就是使用net/http库的进行编写。需要看一下http.ListenAndServe的工作原理。</p>
<pre><code>package main
import &quot;net/http&quot;
func main() {
    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte(`hello world`))
    })
    http.ListenAndServe(&quot;:3000&quot;, nil)
}
</code></pre><p>主要包括：</p>
<ul>
<li>uri_path跟handler的对应关系是如何初始化的</li>
<li>端口接收到请求后，请求是如何处理、以及如何被定义的func处理、响应是如何处理的</li>
</ul>
<h2 id="HandleFunc的参数"><a href="#HandleFunc的参数" class="headerlink" title="HandleFunc的参数"></a>HandleFunc的参数</h2><p>HandleFunc的第二个参数是func(ResponseWriter, *Request)，会赋值给HandlerFunc类型</p>
<pre><code>// The HandlerFunc type is an adapter to allow the use of
// ordinary functions as HTTP handlers.  If f is a function
// with the appropriate signature, HandlerFunc(f) is a
// Handler that calls f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r)
}
</code></pre><h2 id="映射处理"><a href="#映射处理" class="headerlink" title="映射处理"></a>映射处理</h2><p>在src/net/http/server.go中使用<code>HandleFunc</code>进行注册，会将其放入多路复用的结构体<code>ServeMux</code>中。</p>
<p>src/net/http/server.go</p>
<pre><code>// HandleFunc registers the handler function for the given pattern.
func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    mux.Handle(pattern, HandlerFunc(handler))
}
// Handle registers the handler for the given pattern
// in the DefaultServeMux.
// The documentation for ServeMux explains how patterns are matched.
func Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }
// HandleFunc registers the handler function for the given pattern
// in the DefaultServeMux.
// The documentation for ServeMux explains how patterns are matched.
func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    DefaultServeMux.HandleFunc(pattern, handler)
}

 // HandleFunc registers the handler function for the given pattern.
func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    mux.Handle(pattern, HandlerFunc(handler))
}

type Handler interface {
   ServeHTTP(ResponseWriter, *Request)
}

func (mux *ServeMux) Handle(pattern string, handler Handler) {
}

// The HandlerFunc type is an adapter to allow the use of
// ordinary functions as HTTP handlers.  If f is a function
// with the appropriate signature, HandlerFunc(f) is a
// Handler that calls f.
type HandlerFunc func(ResponseWriter, *Request)
</code></pre><p>http请求的多路复用结构体<code>ServeMux</code></p>
<pre><code>// ServeMux is an HTTP request multiplexer.
// It matches the URL of each incoming request against a list of registered
// patterns and calls the handler for the pattern that
// most closely matches the URL.
//
// Patterns name fixed, rooted paths, like &quot;/favicon.ico&quot;,
// or rooted subtrees, like &quot;/images/&quot; (note the trailing slash).
// Longer patterns take precedence over shorter ones, so that
// if there are handlers registered for both &quot;/images/&quot;
// and &quot;/images/thumbnails/&quot;, the latter handler will be
// called for paths beginning &quot;/images/thumbnails/&quot; and the
// former will receive requests for any other paths in the
// &quot;/images/&quot; subtree.
//
// Note that since a pattern ending in a slash names a rooted subtree,
// the pattern &quot;/&quot; matches all paths not matched by other registered
// patterns, not just the URL with Path == &quot;/&quot;.
//
// If a subtree has been registered and a request is received naming the
// subtree root without its trailing slash, ServeMux redirects that
// request to the subtree root (adding the trailing slash). This behavior can
// be overridden with a separate registration for the path without
// the trailing slash. For example, registering &quot;/images/&quot; causes ServeMux
// to redirect a request for &quot;/images&quot; to &quot;/images/&quot;, unless &quot;/images&quot; has
// been registered separately.
//
// Patterns may optionally begin with a host name, restricting matches to
// URLs on that host only.  Host-specific patterns take precedence over
// general patterns, so that a handler might register for the two patterns
// &quot;/codesearch&quot; and &quot;codesearch.google.com/&quot; without also taking over
// requests for &quot;http://www.google.com/&quot;.
//
// ServeMux also takes care of sanitizing the URL request path,
// redirecting any request containing . or .. elements or repeated slashes
// to an equivalent, cleaner URL.
type ServeMux struct {
    mu    sync.RWMutex
    m     map[string]muxEntry
    hosts bool // whether any patterns contain hostnames
}
</code></pre><h2 id="对外提供服务"><a href="#对外提供服务" class="headerlink" title="对外提供服务"></a>对外提供服务</h2><pre><code>// A Server defines parameters for running an HTTP server.
// The zero value for Server is a valid configuration.
type Server struct {
    Addr           string        // TCP address to listen on, &quot;:http&quot; if empty
    Handler        Handler       // handler to invoke, http.DefaultServeMux if nil
    ReadTimeout    time.Duration // maximum duration before timing out read of the request
    WriteTimeout   time.Duration // maximum duration before timing out write of the response
    MaxHeaderBytes int           // maximum size of request headers, DefaultMaxHeaderBytes if 0
    TLSConfig      *tls.Config   // optional TLS config, used by ListenAndServeTLS

    // TLSNextProto optionally specifies a function to take over
    // ownership of the provided TLS connection when an NPN
    // protocol upgrade has occurred.  The map key is the protocol
    // name negotiated. The Handler argument should be used to
    // handle HTTP requests and will initialize the Request&apos;s TLS
    // and RemoteAddr if not already set.  The connection is
    // automatically closed when the function returns.
    // If TLSNextProto is nil, HTTP/2 support is enabled automatically.
    TLSNextProto map[string]func(*Server, *tls.Conn, Handler)

    // ConnState specifies an optional callback function that is
    // called when a client connection changes state. See the
    // ConnState type and associated constants for details.
    ConnState func(net.Conn, ConnState)

    // ErrorLog specifies an optional logger for errors accepting
    // connections and unexpected behavior from handlers.
    // If nil, logging goes to os.Stderr via the log package&apos;s
    // standard logger.
    ErrorLog *log.Logger

    disableKeepAlives int32     // accessed atomically.
    nextProtoOnce     sync.Once // guards initialization of TLSNextProto in Serve
    nextProtoErr      error
}
</code></pre><p>其中<code>ListenAndServe</code>函数的逻辑，其中tcpKeepAliveListener是开启了tcp的keep-alive</p>
<pre><code>// ListenAndServe listens on the TCP network address srv.Addr and then
// calls Serve to handle requests on incoming connections.
// Accepted connections are configured to enable TCP keep-alives.
// If srv.Addr is blank, &quot;:http&quot; is used.
// ListenAndServe always returns a non-nil error.
func (srv *Server) ListenAndServe() error {
    addr := srv.Addr
    if addr == &quot;&quot; {
        addr = &quot;:http&quot;
    }
    ln, err := net.Listen(&quot;tcp&quot;, addr)
    if err != nil {
        return err
    }
    return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)}) 
}
</code></pre><p>在Serve中在Accept处于等待，当请求到来时，Accept会从Listener l中接收一个到来的连接并创建一个新的goroutine处理请求。这个goroutine会读取请求，调用Server.Handler来处理他们。</p>
<pre><code>func (srv *Server) Serve(l net.Listener) error {
    defer l.Close()
    ....
    for {
        rw, e := l.Accept()
        if e != nil {
            ....
            return e
        }
        tempDelay = 0
        c := srv.newConn(rw)
        c.setState(c.rwc, StateNew) // before Serve can return
        go c.serve()
    }
}
</code></pre><p>其中newConn是获得一个新连接</p>
<pre><code>// Create new connection from rwc.
func (srv *Server) newConn(rwc net.Conn) *conn {
    c := &amp;conn{
        server: srv,
        rwc:    rwc,
    }
    if debugServerConnections {
        c.rwc = newLoggingConn(&quot;server&quot;, c.rwc)
    }
    return c
}
</code></pre><p>其中conn结构体在net/http/server.go文件中</p>
<pre><code>// A conn represents the server side of an HTTP connection.
type conn struct {
    // server is the server on which the connection arrived.
    // Immutable; never nil.
    server *Server

    // rwc is the underlying network connection.
    // This is never wrapped by other types and is the value given out
    // to CloseNotifier callers. It is usually of type *net.TCPConn or
    // *tls.Conn.
    rwc net.Conn

    // remoteAddr is rwc.RemoteAddr().String(). It is not populated synchronously
    // inside the Listener&apos;s Accept goroutine, as some implementations block.
    // It is populated immediately inside the (*conn).serve goroutine.
    // This is the value of a Handler&apos;s (*Request).RemoteAddr.
    remoteAddr string

    // tlsState is the TLS connection state when using TLS.
    // nil means not TLS.
    tlsState *tls.ConnectionState

    // werr is set to the first write error to rwc.
    // It is set via checkConnErrorWriter{w}, where bufw writes.
    werr error

    // r is bufr&apos;s read source. It&apos;s a wrapper around rwc that provides
    // io.LimitedReader-style limiting (while reading request headers)
    // and functionality to support CloseNotifier. See *connReader docs.
    r *connReader

    // bufr reads from r.
    // Users of bufr must hold mu.
    bufr *bufio.Reader

    // bufw writes to checkConnErrorWriter{c}, which populates werr on error.
    bufw *bufio.Writer

    // lastMethod is the method of the most recent request
    // on this connection, if any.
    lastMethod string

    // mu guards hijackedv, use of bufr, (*response).closeNotifyCh.
    mu sync.Mutex

    // hijackedv is whether this connection has been hijacked
    // by a Handler with the Hijacker interface.
    // It is guarded by mu.
    hijackedv bool
}
</code></pre><p>serve方法</p>
<pre><code>// Serve a new connection.
func (c *conn) serve() {
    c.remoteAddr = c.rwc.RemoteAddr().String()
    defer func() {
        ... // defer处理
    }()

    ... // tls connection

    c.r = &amp;connReader{r: c.rwc}
    c.bufr = newBufioReader(c.r)
    c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4&lt;&lt;10)

    for {
        w, err := c.readRequest() //读取请求
        ...
        if err != nil {
            ....
            return
        }


        ...     // Expect 100 Continue support

        // HTTP cannot have multiple simultaneous active requests.[*]
        // Until the server replies to this request, it can&apos;t read another,
        // so we might as well run the handler in this goroutine.
        // [*] Not strictly true: HTTP pipelining.  We could let them all process
        // in parallel even if their responses need to be serialized.
        serverHandler{c.server}.ServeHTTP(w, w.req)

        ... // finish operation
    }
}
</code></pre><p>看一下这里面最核心的 <code>serverHandler{c.server}.ServeHTTP(w, w.rseq)</code>处理逻辑</p>
<pre><code>// serverHandler delegates to either the server&apos;s Handler or
// DefaultServeMux and also handles &quot;OPTIONS *&quot; requests.
type serverHandler struct {
    srv *Server
}

func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {
    handler := sh.srv.Handler
    if handler == nil {
        handler = DefaultServeMux
    }
    if req.RequestURI == &quot;*&quot; &amp;&amp; req.Method == &quot;OPTIONS&quot; {
        handler = globalOptionsHandler{}
    }
    handler.ServeHTTP(rw, req)
}


// ServeHTTP dispatches the request to the handler whose
// pattern most closely matches the request URL.
func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {
    if r.RequestURI == &quot;*&quot; {
        if r.ProtoAtLeast(1, 1) {
            w.Header().Set(&quot;Connection&quot;, &quot;close&quot;)
        }
        w.WriteHeader(StatusBadRequest)
        return
    }
    h, _ := mux.Handler(r)
    h.ServeHTTP(w, r)
}
</code></pre><p>最后的<code>h,_:=mux.Handler</code>获取的是<code>type HandlerFunc func(ResponseWriter, *Request)</code>，调用ServeHTTP也就是调用了我们注册的</p>
<pre><code>http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {    
    w.Write([]byte(`hello world`))
})
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2017/10/31/go源码分析-http处理流程分析/" data-id="ckw5yql4v002lp8nu19nz4wmr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go-source-code/">go.source.code</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux硬盘是否是ssd判断" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/08/linux硬盘是否是ssd判断/" class="article-date">
  <time datetime="2017-10-08T06:52:56.000Z" itemprop="datePublished">2017-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/08/linux硬盘是否是ssd判断/">linux硬盘是否是ssd判断</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>$ cat /sys/block/*/queue/rotational</p>
<p>判断cat /sys/block/<em>/queue/rotational的返回值（其中</em>为你的硬盘设备名称，例如sda等等），如果返回1则表示磁盘可旋转，那么就是HDD了；反之，如果返回0，则表示磁盘不可以旋转，那么就有可能是SSD了</p>
<p>这种方法有个问题，那就是/sys/block/下面不只有硬盘，还可能有别的块设备，它们都在干扰你的判断。</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>使用lsblk命令进行判断，参数-d表示显示设备名称，参数-o表示仅显示特定的列。<br>这种方法的优势在于它只列出了你要看的内容，结果比较简洁明了。还是那个规则，ROTA是1的表示可以旋转，反之则不能旋</p>
<p>$ lsblk -d -o name,rota</p>
<p>NAME ROTA<br>sda     1<br>sdb     1</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2017/10/08/linux硬盘是否是ssd判断/" data-id="ckw5yql50002yp8nu2kcvntu2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux下CPU核数查看" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/08/linux下CPU核数查看/" class="article-date">
  <time datetime="2017-10-08T06:01:54.000Z" itemprop="datePublished">2017-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/08/linux下CPU核数查看/">linux下CPU核数查看</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol>
<li><p>物理cpu</p>
<p>插槽上的CPU个数，物理cpu数量等于不同physical id的个数。</p>
<p>cat /proc/cpuinfo | grep ‘pysical id’ | sort | uniq | wc -l</p>
</li>
<li><p>cpu核数</p>
</li>
</ol>
<p>一颗CPU上面能处理数据的芯片组的数量</p>
<p>cat /proc/cpuinfo| grep “cpu cores”| uniq</p>
<ol start="3">
<li>逻辑cpu核数</li>
</ol>
<p>一般来说，物理CPU个数 X cpu cores = 逻辑CPU的个数。<br>如果不相等的话，则表示服务器的CPU支持超线程技术。</p>
<p>cat /proc/cpuinfo | grep ‘processor’ | wc -l</p>
<ol start="4">
<li>超线程技术<br>cat /proc/cpuinfo| grep “siblings”| uniq</li>
</ol>
<p>超线程的数量 是 “siblings”/“cpu cores”</p>
<h2 id="查看方式"><a href="#查看方式" class="headerlink" title="查看方式"></a>查看方式</h2><p>$  cat /proc/cpuinfo| grep “physical id”| sort| uniq| wc -l<br>2<br>$  cat /proc/cpuinfo| grep “cpu cores”| uniq<br>cpu cores    : 12<br>$  cat /proc/cpuinfo| grep “siblings”| uniq<br>siblings    : 24<br>$ cat /proc/cpuinfo| grep “processor”| wc -l<br>48</p>
<h2 id="cpu核数取决因素"><a href="#cpu核数取决因素" class="headerlink" title="cpu核数取决因素"></a>cpu核数取决因素</h2><p>cpu的个数只与processor 、physical id、siblings 、cpu cores 四个参数有关，其他参数值可以不用考虑</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2017/10/08/linux下CPU核数查看/" data-id="ckw5yql4y002tp8nulw6msffi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-free命令详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/08/free命令详解/" class="article-date">
  <time datetime="2017-10-08T05:15:29.000Z" itemprop="datePublished">2017-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/08/free命令详解/">free命令详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在centos上使用free命令得到如下四行，其中行号1 2 3 4是我加上的</p>
<pre><code>1          total       used       free           shared    buffers     cached
2 Mem:     132047948  121586656   10461292       2824      89148       106314244
3 -/+ buffers/cache:   15183264  116864684
4 Swap:      7812092      97712    7714380
</code></pre><p>第一行解释：</p>
<pre><code>total：除系统外，可以使用的内存总量；
used：已经使用的内存总量
free：空闲的内存总量
shared：共享内存使用总量
buffers:被OS buffer住的内存
cached：被OS cached住的内存
buffers和cached的区别是：

+ A buffer is something that has yet to be &quot;written&quot; to disk. 
+ A cache is something that has been &quot;read&quot; from the disk and stored for later use.
+ 也就是说buffer是用于存放要输出到disk（块设备）的数据的，而cache是存放从disk上读出的数据。这二者是为了提高IO性能的，并由OS管理。
</code></pre><p>第二行解释：</p>
<pre><code>输出是从操作系统（OS）来看的。也就是说，从OS的角度来看，计算机上一共有:

132047948（缺省时free的单位为KB）物理内存，即FO[2][1]；
在这些物理内存中有121586656（即FO[2][2]）被使用了；
还用10461292（即FO[2][3]）是可用的；
这里得到第一个等式：

FO[2][1] = FO[2][2] + FO[2][3]

FO[2][5] 是OS buffer住的内存，FO[2][6]是OS cached住的内存。

Linux和其他成熟的操作系统（例如windows），为了提高IO read的性能，总是要多cache一些数据，这也就是为什么FO[2][6]（cached memory）比较大，而FO[2][3]比较小的原因。
</code></pre><p>第三行解释：</p>
<pre><code>是从一个应用程序的角度看系统内存的使用情况。

对于FO[3][2]，即FO[2][2]-buffers/cache，表示一个应用程序认为系统被用掉多少内存；
对于FO[3][3]，即FO[2][3]+buffers/cache，表示一个应用程序认为系统还有多少内存；
因为被系统cache和buffer占用的内存可以被快速回收，所以通常FO[3][3]比FO[2][3]会大很多

这里还用两个等式：

FO[3][2] = FO[2][2] - FO[2][5] - FO[2][6]
FO[3][3] = FO[2][3] + FO[2][5] + FO[2][6]
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2017/10/08/free命令详解/" data-id="ckw5yql4k001xp8nu31ognmtx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-es-install-ik" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/31/es-install-ik/" class="article-date">
  <time datetime="2017-07-31T05:14:11.000Z" itemprop="datePublished">2017-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/31/es-install-ik/">es_install_ik</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在这篇文章中描述了elasticsearch按照ik分词的步骤。<br><a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik</a></p>
<p>注意：</p>
<ol>
<li>es版本需要与ik分词器的版本对应；我使用的是es-2.4.5和ik-1.10.5版本</li>
<li>测试用例使用也是网址中的说明</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2017/07/31/es-install-ik/" data-id="ckw5yql4i001qp8nuutnh188j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cpp异常处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/28/cpp异常处理/" class="article-date">
  <time datetime="2017-05-28T08:52:56.000Z" itemprop="datePublished">2017-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/28/cpp异常处理/">cpp异常处理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在C++语言中，异常处理包括：</p>
<ul>
<li><p>throw表达式（throw expression），异常检测部分使用throw表达式来表示它遇到了无法处理的问题；我们说throw引发了异常</p>
</li>
<li><p>try语句块（try block），异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以catch 子句结束；</p>
</li>
<li><p>一套异常类（exception class），用于在throw表达式和相关的catch子句之间传递异常的具体信息；</p>
</li>
</ul>
<p>标准异常</p>
<p>C++标准定义了一组类，用于报告标准库函数遇到的问题。这些异常类也可以在用户编写的程序中使用；分别定义在4个头文件中：</p>
<ul>
<li>exception头文件定义了最通用的异常类 exception。它只报告异常的发生，不提供任何额外的信息；</li>
<li><p>stdexcept头文件定义了几种常见的异常类</p>
<ul>
<li>exception 最常见的问题</li>
<li>runtime_error 只有在运行时才能检测中的问题</li>
<li>range_error 运行时错误，生成的结果超出了有意义的值域范围</li>
<li>…</li>
</ul>
</li>
<li><p>new 头文件定义了bad_alloc异常类型，将在12.1.2节介绍</p>
</li>
<li>type_info头文件中定义了bad_cast异常类型；将在19.2节介绍</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2017/05/28/cpp异常处理/" data-id="ckw5yql4h001np8nuylcyd51w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Laravel/">Laravel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/composer/">composer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/">cpp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp-lib/">cpp-lib</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/faiss/">faiss</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-source-code/">go.source.code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/laravel/">laravel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/">mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/machine-learning/">machine-learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memcache/">memcache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nosql/">nosql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/octave/">octave</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php源码学习/">php源码学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/">spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tcp/">tcp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thrift/">thrift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础知识/">基础知识</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Laravel/" style="font-size: 10px;">Laravel</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/composer/" style="font-size: 10px;">composer</a> <a href="/tags/cpp/" style="font-size: 12.22px;">cpp</a> <a href="/tags/cpp-lib/" style="font-size: 10px;">cpp-lib</a> <a href="/tags/elasticsearch/" style="font-size: 11.11px;">elasticsearch</a> <a href="/tags/faiss/" style="font-size: 10px;">faiss</a> <a href="/tags/git/" style="font-size: 12.22px;">git</a> <a href="/tags/go-source-code/" style="font-size: 10px;">go.source.code</a> <a href="/tags/golang/" style="font-size: 16.67px;">golang</a> <a href="/tags/laravel/" style="font-size: 11.11px;">laravel</a> <a href="/tags/linux/" style="font-size: 14.44px;">linux</a> <a href="/tags/mac/" style="font-size: 13.33px;">mac</a> <a href="/tags/machine-learning/" style="font-size: 10px;">machine-learning</a> <a href="/tags/memcache/" style="font-size: 15.56px;">memcache</a> <a href="/tags/mysql/" style="font-size: 13.33px;">mysql</a> <a href="/tags/nginx/" style="font-size: 13.33px;">nginx</a> <a href="/tags/nosql/" style="font-size: 18.89px;">nosql</a> <a href="/tags/octave/" style="font-size: 10px;">octave</a> <a href="/tags/php/" style="font-size: 20px;">php</a> <a href="/tags/php源码学习/" style="font-size: 17.78px;">php源码学习</a> <a href="/tags/redis/" style="font-size: 12.22px;">redis</a> <a href="/tags/spark/" style="font-size: 12.22px;">spark</a> <a href="/tags/tcp/" style="font-size: 10px;">tcp</a> <a href="/tags/thrift/" style="font-size: 13.33px;">thrift</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/基础知识/" style="font-size: 15.56px;">基础知识</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/11/19/分布式-CAP理论/">分布式-CAP理论</a>
          </li>
        
          <li>
            <a href="/2021/11/17/分布式-全序广播/">分布式-全序广播</a>
          </li>
        
          <li>
            <a href="/2021/11/16/Spark-DataSource-Hive Tables/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/11/14/分布式-事务/">分布式-事务</a>
          </li>
        
          <li>
            <a href="/2019/04/29/golang继承/">golang继承</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Keything<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>