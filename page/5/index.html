<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Keything的日志</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Keything的日志">
<meta property="og:url" content="http://keything.github.io/page/5/index.html">
<meta property="og:site_name" content="Keything的日志">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Keything的日志">
  
    <link rel="alternate" href="/atom.xml" title="Keything的日志" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Keything的日志</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://keything.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Thrift安装" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/12/Thrift安装/" class="article-date">
  <time datetime="2016-11-11T23:41:07.000Z" itemprop="datePublished">2016-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/12/Thrift安装/">Thrift安装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>参考文章：<br><a href="http://thrift.apache.org/tutorial/" target="_blank" rel="noopener">http://thrift.apache.org/tutorial/</a><br><a href="http://thrift.apache.org/docs/BuildingFromSource" target="_blank" rel="noopener">http://thrift.apache.org/docs/BuildingFromSource</a></p>
<p>几点说明：</p>
<ol>
<li>在mac上尝试，PHP是可以的，但是CPP的例子跑不通。</li>
<li>在centos6.8上使用BuildingFromSource进行安装（需要libevent），CPP的例子直接就编译通过。目录(tutorial/cpp/)</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/11/12/Thrift安装/" data-id="ckw5yufkg0016tznubc4nm0eg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thrift/">thrift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-laravel到lumen" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/07/laravel到lumen/" class="article-date">
  <time datetime="2016-10-07T09:55:38.000Z" itemprop="datePublished">2016-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/07/laravel到lumen/">laravel到lumen</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Lumen中，默认不会加载Facades，默认不会注册Provider，可以在bootstrap/app.php中看到。</p>
<ol>
<li><p>关于Facades<br> 如果想使用Facades，那么修改bootstrap/app.php</p>
<pre><code>$app-&gt;withFacades();
</code></pre><p> 如果你自己定义了Facades的话，那么需要使用如下方式加载:</p>
<pre><code>$user_facades_alias = [
    App\Http\Facades\KLog::class =&gt; &apos;KLog&apos;,
];
$app-&gt;withFacades(true, $user_facades_alias);
</code></pre><p> 当然不能忘了加载Provider，</p>
<pre><code>$app-&gt;register(App\Providers\KLogProvider::class);
</code></pre></li>
<li><p>关于加载配置文件</p>
<p> 在Laravel中，我们已经习惯<code>config(&#39;config_file.config_item&#39;)</code>，但是在Lumen中服务都是按需绑定并加载的。为了与Laravel中代码尽可能保持一致，方便二者代码的迁移，因此依然在bootstrap/app.php中修改，修改如下：</p>
<pre><code>$cfg_files = [
    &apos;database_split&apos;,
    &apos;database&apos;,
    &apos;didicfg&apos;,
    &apos;errno&apos;,
    &apos;timeout&apos;,
];

foreach ($cfg_files as $cfg_file) {
    $app-&gt;configure($cfg_file);
}
</code></pre></li>
<li><p>关于异常处理</p>
<p> 我们知道在app/Exception/Handler.php中可以对特定的异常进行特别处理，对于render返回return []，laravel会自动转为json输出，而对于Lumen必须return json_encode([])才可以。</p>
</li>
<li><p>目前我知道的需要改变的地方是这些，以后有的话会继续补充</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/10/07/laravel到lumen/" data-id="ckw5yufl5002rtznu4yvclngd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/laravel/">laravel</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Laravel等框架压测" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/06/Laravel等框架压测/" class="article-date">
  <time datetime="2016-10-06T08:05:23.000Z" itemprop="datePublished">2016-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/06/Laravel等框架压测/">Laravel等框架压测</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在学习Laravel过程中，发现大家都讲到Laravel性能比较差，又了解到Laravel为了性能专门有一个Lumen框架，为了更加客观的知道各个框架的性能，现在进行测试。</p>
<ol>
<li><p>压测工具<br> 采用boom</p>
<p> 安装 pip install boom</p>
</li>
<li><p>压测参数</p>
<p> boom your.domain -c 2000 -n 100</p>
</li>
<li><p>压测框架</p>
<p> 对CI2，YII2，Laravel5.3， Lument5.2进行压测</p>
</li>
<li><p>代码及输出</p>
<p> 都是在TestController中输出json串</p>
<p> {“hello”:”world”,”hello2”:”world2”}</p>
</li>
<li><p>压测结果</p>
<p> CI2&gt;LUMENT5.2&gt;YII2&gt;LARAVEL5.3(优化过)&gt;LARAVEL5.3(没有优化)<br> 开启OPCACHE以后性能有显著提高，如下图所示：</p>
<p> <img src="/images/PHP框架QPS对比.png" alt="PHP框架QPS对比.png"></p>
</li>
</ol>
<p>附注：Laravel优化的语句是</p>
<pre><code>配置信息缓存 php artisan config:cache
路由缓存 php artisan route:cache
类映射加载优化 php artisan optimize
自动加载优化 composer dumpautoload
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/10/06/Laravel等框架压测/" data-id="ckw5yufk7000jtznuw7a9u4sb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/laravel/">laravel</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Laravel中日志类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/03/Laravel中日志类/" class="article-date">
  <time datetime="2016-10-03T08:19:37.000Z" itemprop="datePublished">2016-10-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/03/Laravel中日志类/">Laravel中日志类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="问题描述及改进方法"><a href="#问题描述及改进方法" class="headerlink" title="问题描述及改进方法"></a>问题描述及改进方法</h2><ol>
<li><p>Laravel中原有的日志门面Log</p>
<p> 在Laravel中大家都知道Log，其用法是</p>
<pre><code>use Log;
Log::info();
</code></pre><p> 但是这个存在一个问题，通过Log门面打印的日志是打印到一个Log文件中，不利于日志监控。</p>
</li>
<li><p>改进的日志门面KLog</p>
<p> 通过添加一个自定义的日志门面KLog，将日志打印到不同的文件中，并且自动实现日志按天切割。</p>
</li>
</ol>
<h2 id="实现日志门面KLog"><a href="#实现日志门面KLog" class="headerlink" title="实现日志门面KLog"></a>实现日志门面KLog</h2><p>所谓门面facade，简单概括为以静态语法的方式调用底层类。门面的详细解释可以参考<a href="http://laravelacademy.org/post/5820.html" target="_blank" rel="noopener">核心概念 —— 门面（Facades）</a></p>
<p>在 Laravel 应用中，门面就是一个为容器中对象提供访问方式的类。该机制原理由 Facade 类实现。Laravel 自带的门面，以及我们创建的自定义门面，都会继承自 Illuminate\Support\Facades\Facade 基类。</p>
<p>门面类只需要实现一个方法：getFacadeAccessor。正是 getFacadeAccessor 方法定义了从容器中解析什么，然后Facade 基类使用魔术方法 __callStatic() 从你的门面中调用解析对象。</p>
<p>因此门面类KLog的实现如下</p>
<pre><code>&lt;?php
// filepath:app/Http/Facades/KLog.php
namespace App\Http\Facades;

use Illuminate\Support\Facades\Facade;


/**
 * @see \APP\Http\Logic\KLogLogic
 */
class KLog extends Facade
{
    protected static function getFacadeAccessor()
    {
       return &apos;KLog&apos;;//该方法的工作就是返回服务容器绑定类的别名
    }
}
</code></pre><p>KLog门面继承 Facade 基类并定义了 getFacadeAccessor 方法，该方法的工作就是返回服务容器绑定类的别名，当用户引用 KLog类的任何静态方法时，Laravel 从服务容器中解析 KLog绑定，然后在解析出的对象上调用所有请求方法。<code>getFacadeAccessor</code>返回的是在config/app.php中aliases的别名。</p>
<p>前面提到<code>门面就是一个为容器中对象提供访问方式的类</code>，那么服务容器是什么呢？可以参考<a href="http://laravelacademy.org/post/5805.html" target="_blank" rel="noopener">核心概念-服务容器</a> 。既然提到服务容器，就必然提到<a href="http://laravelacademy.org/post/5809.html" target="_blank" rel="noopener">服务提供者</a>。服务提供者是Laravel应用启动的中心，你自己的应用以及所有Laravel的核心服务都是通过服务提供者启动。</p>
<p>KLog类的服务提供者实现如下:</p>
<pre><code>&lt;?php
// filepath:app/Providers/KLogProvider.php
namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class KLogProvider extends ServiceProvider
{
    public function register()
    {
        $this-&gt;app-&gt;singleton(&apos;KLog&apos;, function () {
            return new \App\Http\Logic\KLogLogic();
        });
    }
}
</code></pre><p>在register方法中，你唯一要做的事情就是绑事物到服务容器。</p>
<p>既然服务提供者和门面类都已经创建好，那么接下来我们需要进行配置，在<code>config/app.php</code>中进行如下配置：</p>
<p>a. aliases中增加KLog的配置，<br>b. providers中增加KLogProvider</p>
<pre><code>&apos;aliases&apos; =&gt; [
    ...
    &apos;View&apos; =&gt; Illuminate\Support\Facades\View::class,
    &apos;KLog&apos; =&gt; App\Http\Facades\KLog::class,

],
&apos;providers&apos; =&gt; [
    ...
    App\Providers\RouteServiceProvider::class,
    App\Providers\KLogProvider::class,
],
</code></pre><p>当然我们忘了一件重要的事情，那就是KLogLogic类的实现，这才是真正门面KLog调用的底层类。</p>
<pre><code>&lt;?php
namespace App\Http\Logic;

use Monolog\Logger;
use Monolog\Handler\StreamHandler;
use Illuminate\Log\Writer;

class KLogLogic 
{
    private static $writers = null;
    const MAX_FILES = 5; // 最多保留MAX_FILES天的日志

    public function getBizProc()
    {
        return $this-&gt;getLogger(&apos;biz_proc&apos;);
    }

    public function getBizProcErr()
    {
        return $this-&gt;getLogger(&apos;biz_proc_err&apos;);
    }

    private function getLogger($channel_name)
    {
        if (isset(self::$writers[$channel_name])) {
            return self::$writers[$channel_name];
        }

        $new_writer = new Writer(new Logger($channel_name));
        $log_file_path = storage_path() . &apos;/logs/&apos; . $channel_name . &apos;.log&apos;;
        $new_writer-&gt;useDailyFiles($log_file_path, self::MAX_FILES);

        self::$writers[$channel_name] = $new_writer;
        return self::$writers[$channel_name];
    }
}
</code></pre><p>搞定以后，我们如何使用KLog门面呢？很简单，notice和info后面的参数与门面Log一样，因为都是调用的Writer类的接口</p>
<pre><code>use KLog;

KLog::getBizProcErr()-&gt;info($msg);
KLog::getBizProcErr()-&gt;notice($msg);
</code></pre><p>如果要想添加新的日志，那么在KLogLogic中添加新的方法即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/10/03/Laravel中日志类/" data-id="ckw5yufkc000wtznual0ulx94" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Laravel/">Laravel</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux下expect使用教程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/29/Linux下expect使用教程/" class="article-date">
  <time datetime="2016-09-29T02:03:55.000Z" itemprop="datePublished">2016-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/29/Linux下expect使用教程/">Linux下expect使用教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/09/29/Linux下expect使用教程/" data-id="ckw5yufk4000etznuguv665kf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-匿名函数与闭包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/21/匿名函数与闭包/" class="article-date">
  <time datetime="2016-09-21T14:36:50.000Z" itemprop="datePublished">2016-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/21/匿名函数与闭包/">匿名函数与闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这篇文章翻译了<a href="http://dhorrigan.com/post/29209695084/anonymous-functions-vs-closures" target="_blank" rel="noopener">Anonymous Functions VS Closures</a></p>
<p>是不是很想知道匿名函数和闭包之间的关系？Lambda呢？这些在PHP中是如何实现的呢？在这个领域有很多困惑，现在让我们来深挖并回答这些问题。</p>
<p>第一件事：<code>Lambda</code>是匿名函数的别称。在一些编程语言（如python）中使用Lambda。</p>
<p>接下来让我们看看匿名函数和闭包到底是什么。如果现在你很困惑，不用担心，接下来我希望能够让你明白，下面是两者的一个简单定义：</p>
<ul>
<li>匿名函数：一个匿名函数是一个定义的偶尔触发的函数，不需要与标识符绑定。（An Anonymous Function is a function that is defined, and occasionally invoked, without being bound to an identifier. It also has the variable scoping characteristics of a Closure (see below)）。</li>
<li>闭包函数：闭包是一个能够捕获当前包含作用域，能够获取父作用域的函数。闭包将非局部变量的引用绑定到了闭包创建时的作用域。（A Closure is a function that captures the current containing scope, then provides access to that scope when the Closure is invoked. The Closure binds non-local variable references to the corresponding variables in scope at the time the Closure is created.）</li>
</ul>
<p>从这儿可以看到：所有的匿名函数都是闭包，但并不是所有的闭包都是匿名函数。</p>
<p>用外行的话来说：</p>
<p>所有的匿名函数都是没有名字的闭包。闭包是一个函数，在闭包定义的时候会将非局部变量绑定为函数的局部变量。（原文：An Anonymous Function is a Closure without a name. A Closure is a function which binds references to non-local variables to local variables inside the function at the time of the Closure definition.）</p>
<h3 id="关于PHP呢？"><a href="#关于PHP呢？" class="headerlink" title="关于PHP呢？"></a>关于PHP呢？</h3><p>事情变得有趣了。在PHP5.3中加入了匿名函数和闭包。但是，有一些取巧的地方（其中一个已经在PHP5.4中修复）</p>
<p>匿名函数的实现是Closure对象。PHP贯彻了观点<code>匿名函数是一个无名的闭包</code>。</p>
<p>有一个简单的匿名函数传递给<code>array_map</code>函数，目的是将所有的整数都乘以2。</p>
<pre><code>$arr = array_map(function ($val) {
return is_int($val) ? $val * 2 : $val;
}, $arr);
</code></pre><p>很简答，对不？现在问一下自己：如果你想在函数内部访问非局部变量（non-local variables）？毕竟匿名函数也是闭包。当然可以，但是你必须清晰告诉PHP使用哪些非局部变量，这是诸多取巧的第一个。现在开始深挖。</p>
<p>####取巧1：<br>当使用非局部变量时，必须使用关键字<code>use</code>将这些非局部变量绑定到闭包的作用域。这与大部分其他语言都不一样。</p>
<pre><code>$foo = &apos;foo&apos;;
$bar = &apos;bar&apos;;

$baz = function () use ($foo, $bar) {
    echo $foo, $bar;
};
</code></pre><p>【译者备注】这儿绑定到闭包的作用域，是将这些非局部变量作为了闭包的静态变量</p>
<p>####取巧2：<br>绑定的非局部变量是复制，而不是引用。如果你想在闭包中改变变量的值，那么你必须使用引用传递。</p>
<pre><code>$foo = &apos;foo&apos;;
$bar = &apos;bar&apos;;

$baz = function () use (&amp;$foo, &amp;$bar) {
    $foo = &apos;Hello &apos;;
    $bar = &apos;World!&apos;;
};
$baz();
echo $foo, $bar; // Outputs &quot;Hello World!&quot;;
</code></pre><p>####取巧3：<br>在PHP5.3中，在类中使用闭包，闭包不能使用<code>$this</code>。你必须传递this的引用，而不能直接传递<code>$this</code>。<br>在PHP5.4中修复，可以直接传递<code>$this</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/09/21/匿名函数与闭包/" data-id="ckw5yufm4005atznu78dgpmqu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php源码学习/">php源码学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-PHP函数之匿名函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/21/PHP函数之匿名函数/" class="article-date">
  <time datetime="2016-09-21T12:06:54.000Z" itemprop="datePublished">2016-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/21/PHP函数之匿名函数/">PHP函数之匿名函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="匿名函数与闭包的关系"><a href="#匿名函数与闭包的关系" class="headerlink" title="匿名函数与闭包的关系"></a>匿名函数与闭包的关系</h2><p>匿名函数是一类不需要指定指示符，而又可以被调用的函数或子例程，匿名函数可以方便的作为参数传递给其他函数， 最常见应用是作为回调函数。</p>
<p>闭包是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数， 这个被引用的自由变量将和这个函数一同存在，即使离开了创建它的环境也一样，所以闭包也可认为是有函数和与其相关引用组合而成的实体。 </p>
<p>闭包和匿名函数很容易混用，但其实这是两个不同的概念。</p>
<p>当然在PHP中，一个观点就是<code>Anonymous Functions are Closures without a name</code>，即匿名函数是没有名字的闭包。</p>
<h2 id="PHP中匿名函数基本用法"><a href="#PHP中匿名函数基本用法" class="headerlink" title="PHP中匿名函数基本用法"></a>PHP中匿名函数基本用法</h2><p>在PHP中匿名函数(Anonymous functions)也叫作闭包函数(closures)，允许临时创建一个没有指定名称的函数。</p>
<ol>
<li><p>使用use关键字从父作用域继承变量。继承的变量的取值是在函数定义时的值，而不是被调用的时候的值。因此下面的代码输出是<code>hello hello</code>。</p>
<pre><code>&lt;?php
$helo = &apos;hello&apos;;

$func = function() use ($helo) {
    echo $helo . &quot;\n&quot;;
};
$func();

$helo = &apos;world&apos;;
$func();
</code></pre></li>
<li><p>当把use后面的变量改为引用以后，那么就可以改变了，输出 <code>hello world</code></p>
<pre><code>&lt;?php
$helo = &apos;hello&apos;;

$func = function() use (&amp;$helo) {
    echo $helo . &quot;\n&quot;;
};
$func();

$helo = &apos;world&apos;;
$func();
</code></pre></li>
</ol>
<h2 id="PHP中匿名函数"><a href="#PHP中匿名函数" class="headerlink" title="PHP中匿名函数"></a>PHP中匿名函数</h2><h3 id="create-function"><a href="#create-function" class="headerlink" title="create_function"></a>create_function</h3><p>PHP5.3中才开始正式支持匿名函数，在此之前可以通过create_function函数来创建<code>匿名函数</code>。</p>
<p>通过create_function函数创建的<code>匿名函数</code>并不是真的没有名字，而是生成了一个<code>\0lambda_xxx</code>的函数名，并且会在<code>EG(function_table)</code>中注册。因为函数名的第一个字符是<code>\0</code>，这样的函数名用户是不会出现的。</p>
<pre><code>#define LAMBDA_TEMP_FUNCNAME    &quot;__lambda_func&quot;

ZEND_FUNCTION(create_function)
{
    // ... 省去无关代码
    function_name = (char *) emalloc(sizeof(&quot;0lambda_&quot;)+MAX_LENGTH_OF_LONG);
    function_name[0] = &apos;\0&apos;;  // &lt;--- 这里
    do {
        function_name_length = 1 + sprintf(function_name + 1, &quot;lambda_%d&quot;, ++EG(lambda_count));
    } while (zend_hash_add(EG(function_table), function_name, function_name_length+1, &amp;new_function, sizeof(zend_function), NULL)==FAILURE);
    zend_hash_del(EG(function_table), LAMBDA_TEMP_FUNCNAME, sizeof(LAMBDA_TEMP_FUNCNAME));
    RETURN_STRINGL(function_name, function_name_length, 0);
}
</code></pre><p>通过create_function创建<code>匿名函数</code>有一些缺点：</p>
<ol>
<li>函数的定义是通过将函数拼接为一个字符串来处理的。<a href="http://www.laruence.com/2010/06/20/1602.html" target="_blank" rel="noopener">深入理解php之匿名函数解释</a>，这样的话就无法进行基本的语法检查</li>
<li>这种函数与普通函数没有本质区别，无法实现闭包的效果</li>
</ol>
<h3 id="真正的匿名函数"><a href="#真正的匿名函数" class="headerlink" title="真正的匿名函数"></a>真正的匿名函数</h3><ol>
<li><p><code>__invoke</code>魔术方法<br> 这个魔术方法被调用的时机是：当一个对象当做函数调用的时候。通过<code>__invoke</code>方法可以把一个对象当做函数调用。</p>
</li>
<li><p>匿名函数的实现</p>
<p> 匿名函数的实现就是通过<code>__invoke</code>方式实现的。匿名函数是一个普通的类，类名是<a href="http://php.net/manual/zh/class.closure.php" target="_blank" rel="noopener">Closure</a>。</p>
</li>
<li><p>闭包的使用</p>
<p> PHP使用闭包（Closure）来实现匿名函数。匿名函数在定义的时候如果需要使用作用域外的变量需要使用关键字<code>use</code>。</p>
<p> 特别注意的是，在PHP中是通过<code>拷贝</code>的方式将上层变量传入匿名函数的。如果需要改变上层变量的值则需要通过引用的方式传递。</p>
</li>
</ol>
<pre><code>通过下面的代码看一下func的内容

    &lt;?php
    $b = 1;
    $func = function($a) use($b) {
        $b = $b+1;
        echo $b . &quot;\n&quot;;
    };
    var_dump($func);
可以看到

    object(Closure)#1 (2) {
      [&quot;static&quot;]=&gt;
      array(1) {
        [&quot;b&quot;]=&gt;
        int(1)
      }
      [&quot;parameter&quot;]=&gt;
      array(1) {
        [&quot;$a&quot;]=&gt;
        string(10) &quot;&lt;required&gt;&quot;
      }
    }

将代码中的`use ($b)` 改为`use (&amp;$b)`，可以看到输出是：

    object(Closure)#1 (2) {
      [&quot;static&quot;]=&gt;
      array(1) {
        [&quot;b&quot;]=&gt;
        &amp;int(1)
      }
      [&quot;parameter&quot;]=&gt;
      array(1) {
        [&quot;$a&quot;]=&gt;
        string(10) &quot;&lt;required&gt;&quot;
      }
    }
</code></pre><ol start="4">
<li><p>闭包的实现</p>
<p> 匿名函数是通过闭包来实现的，现在我们来看看闭包（类）是怎么实现的。匿名函数和普通函数除了是否有变量名以外并没有区别，闭包的实现代码在<code>Zend/zend_closure.c</code>中。</p>
<p> 使用关键字use引入的父作用域的变量会作为闭包类的静态变量，从上面的var_dump中也可以看出。</p>
<p> 在<code>ZEND_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_CONST_HANDLER</code>中调用<code>zend_create_closure</code>创建一个闭包对象。在<code>zend_create_closure</code>中会将<code>zval_copy_static_var</code>作为回调函数传递给<code>zend_hash_apply_with_arguments</code>。每次读取到hash表中的值以后都会由这个函数进行处理，而这个函数对所有use语句定义的变量值赋值给这个匿名函数的静态变量， 这样匿名函数就能访问到use的变量了。</p>
</li>
</ol>
<p>##参考文章</p>
<ol>
<li><a href="http://dhorrigan.com/post/29209695084/anonymous-functions-vs-closures" target="_blank" rel="noopener">Anonymous Functions VS Closures</a></li>
<li><a href="http://www.php-internals.com/book/?p=chapt04/04-04-anonymous-function" target="_blank" rel="noopener">匿名函数及闭包</a></li>
<li><a href="http://www.laruence.com/2010/06/20/1602.html" target="_blank" rel="noopener">深入理解PHP之匿名函数</a></li>
<li><a href="http://php.net/manual/zh/functions.anonymous.php" target="_blank" rel="noopener">PHP匿名函数基本用法</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/09/21/PHP函数之匿名函数/" data-id="ckw5yufkb000ttznuvx2s6xi7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php源码学习/">php源码学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-4PHP变量之常量" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/20/4PHP变量之常量/" class="article-date">
  <time datetime="2016-09-20T14:56:56.000Z" itemprop="datePublished">2016-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/20/4PHP变量之常量/">4. PHP变量之常量</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>首先看下常量与变量的区别，常量是在变量的zval结构的基础上添加了一额外的元素。如下所示为PHP中常量的内部结构。<br>常量的内部结构：</p>
<pre><code>typedef struct _zend_constant {
zval value; /* zval结构，PHP内部变量的存储结构，在第一小节有说明 */
int flags;  /* 常量的标记如 CONST_PERSISTENT | CONST_CS */
char *name; /* 常量名称 */
uint name_len;  
int module_number;  /* 模块号 */
} zend_constant;
</code></pre><p>在了解了常量的存储结构后，来看PHP常量的定义过程，一个例子：</p>
<pre><code>define(&apos;TIPI&apos;, &apos;Thinking In PHP Internal&apos;);
</code></pre><h2 id="define定义常量的过程"><a href="#define定义常量的过程" class="headerlink" title="define定义常量的过程"></a>define定义常量的过程</h2><p>define是PHP的内置函数，在zend/zend_builtin_functions.c文件中定义了此函数的实现。最后会调用zend_register_constant。在zend_register_constant中将常量注册到EG(zend_constants)中。</p>
<p>常量zend_constant的标记flag可以有CONST_CS、CONST_PERSISTENT、CONST_CT_SUBST的取值。</p>
<p>CONST_PERSISTENT表示这个常量需要持久化。这里的持久化是指内存申请时的持久化。非持久常量会在请求结束RSHUTDOWN阶段时释放该常量。持久化常量只会在MSHUTDOWN阶段将内存释放。用户空间定义的常量都是非持久化的，通常扩展和内核定义的常量会设置为持久化。</p>
<p>CONST_ST_SUBST可以知道其表示Allocw compile-time substitution(在编译时可被替换)。在php内核中这些常量表示：TRUE、FALSE、NULL、ZEND_THREAD_SAFE和ZEND_DEBUG_BUILD五个。</p>
<h2 id="标准常量的初始化"><a href="#标准常量的初始化" class="headerlink" title="标准常量的初始化"></a>标准常量的初始化</h2><p>通过define()函数定义的常量的模块编号是PHP_USER_CONSTANT，是用户定义的常量。<br>对于错误报告级别E_ALL, E_WARNING等常量就不同了，是PHP内置定义的常量属于标准常量。调用是php_module_startup()-&gt;zend_startup()-&gt;zend_register_standard_constants()-&gt;zend_register_constant。</p>
<h2 id="zend-register-constant"><a href="#zend-register-constant" class="headerlink" title="zend_register_constant"></a>zend_register_constant</h2><p>对于define定义常量和标准常量都会调用zend_register_constant。该函数的核心是调用了<br>    <code>zend_hash_quick_add(EG(zend_constants), name, c-&gt;name_len, chash, (void *) c, ...)</code><br>其中EG(zend_constants)即全局变量execute_gloabls.zend_constants</p>
<p>即常量都是在execute_gloabls.zend_constants这个哈希表中</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.php-internals.com/book/?p=chapt03/03-02-const-var" target="_blank" rel="noopener">PHP变量之常量</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/09/20/4PHP变量之常量/" data-id="ckw5yufjw0007tznu4b84w9ar" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php源码学习/">php源码学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2PHP变量之基本数据类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/20/2PHP变量之基本数据类型/" class="article-date">
  <time datetime="2016-09-20T14:42:43.000Z" itemprop="datePublished">2016-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/20/2PHP变量之基本数据类型/">2. PHP变量之基本数据类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><a href="">PHP的哈希表实现</a></li>
<li><a href="http://www.php-internals.com/book/?p=chapt03/03-01-03-zend-llist" target="_blank" rel="noopener">PHP的链表实现</a><br> 使用哈希表能够提高查询性能，但是在某些情景下不会对数据进行随机查找，这时候使用哈希表就有点浪费了。<br>zend引擎中的链表是双链表，通过双链表的任意节点都能方便的对链表进行遍历。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/09/20/2PHP变量之基本数据类型/" data-id="ckw5yufjv0005tznuwsuponxg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php源码学习/">php源码学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-3PHP变量之基本数据类型之哈希表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/20/3PHP变量之基本数据类型之哈希表/" class="article-date">
  <time datetime="2016-09-20T11:57:23.000Z" itemprop="datePublished">2016-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/20/3PHP变量之基本数据类型之哈希表/">3. PHP中哈希表实现与数组的顺序遍历</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="PHP中哈希表实现"><a href="#PHP中哈希表实现" class="headerlink" title="PHP中哈希表实现"></a>PHP中哈希表实现</h2><p>哈希表的相关概念可以看<a href="http://www.php-internals.com/book/?p=chapt03/03-01-01-hashtable" target="_blank" rel="noopener">TIPI中哈希表介绍</a>，也可以直接看算法导论中哈希表的介绍。</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>PHP中的哈希表实现在Zend/zend_hash.c中。HashTable结构体用于保存整个哈希表需要的基本信息，Bucket结构体用于保存具体的数据内容，如下：</p>
<pre><code>typedef struct _hashtable { 
    uint nTableSize;        // hash Bucket的大小，最小为8，以2x增长。
    uint nTableMask;        // nTableSize-1 ， 索引取值的优化
    uint nNumOfElements;    // hash Bucket中当前存在的元素个数，count()函数会直接返回此值 
    ulong nNextFreeElement; // 下一个数字索引的位置
    Bucket *pInternalPointer;   // 当前遍历的指针（foreach比for快的原因之一）pInternalPointer指向当前的内部指针的位置, 在对数组进行顺序遍历的时候, 这个指针指明了当前的元素.当在线性(顺序)遍历的时候, 就会从pListHead开始, 顺着Bucket中的pListNext/pListLast, 根据移动pInternalPointer, 来实现对所有元素的线性遍历.


    Bucket *pListHead;          // 存储数组头元素指针
    Bucket *pListTail;          // 存储数组尾元素指针
    Bucket **arBuckets;         // 存储hash数组
    dtor_func_t pDestructor;    // 在删除元素时执行的回调函数，用于资源的释放
    zend_bool persistent;       //指出了Bucket内存分配的方式。如果persisient为TRUE，则使用操作系统本身的内存分配函数为Bucket分配内存，否则使用PHP的内存分配函数。
    unsigned char nApplyCount; // 标记当前hash Bucket被递归访问的次数（防止多次递归）
    zend_bool bApplyProtection;// 标记当前hash桶允许不允许多次访问，不允许时，最多只能递归3次
#if ZEND_DEBUG
    int inconsistent;
#endif
} HashTable;
</code></pre><h3 id="数据容器：槽位"><a href="#数据容器：槽位" class="headerlink" title="数据容器：槽位"></a>数据容器：槽位</h3><pre><code>typedef struct bucket {
    ulong h;            // 对char *key进行hash后的值，或者是用户指定的数字索引值
    uint nKeyLength;    // hash关键字的长度，如果数组索引为数字，此值为0
    void *pData;        // 指向value，一般是用户数据的副本，如果是指针数据，则指向pDataPtr
    void *pDataPtr;     //如果是指针数据，此值会指向真正的value，同时上面pData会指向此值
    struct bucket *pListNext;   // 整个hash表的下一元素
    struct bucket *pListLast;   // 整个哈希表该元素的上一个元素
    struct bucket *pNext;       // 存放在同一个hash Bucket内的下一个元素
    struct bucket *pLast;       // 同一个哈希bucket的上一个元素

    char arKey[1];   // 保存当前值所对于的key字符串，这个字段只能定义在最后，实现变长结构体            
} Bucket;
</code></pre><p>在PHP中可以使用字符串或者数字作为数组的索引，数字索引直接就可以作为哈希表的索引，数字无需进行哈希处理。h字段后面的nKeyLength字段是作为key长度的标示，如果索引是数字的话，则nKeyLength为0.在PHP数组中如果索引字符串可以被转换成数字也会被转换成数字索引。所以在php中’19’ ‘20’这样的字符索引和数字索引19，20没有区别。</p>
<p>上面结构体的最后一个字段用来保存key的字符串，而这个字段却申明为只有一个字符的数组， 其实这里是一种长见的<a href="http://stackoverflow.com/a/4690976/319672" target="_blank" rel="noopener">变长结构体</a>，主要的目的是增加灵活性。</p>
<p>一张图来解释<img src="http://www.php-internals.com/images/book/chapt03/03-01-02-zend_hashtable.png" alt="Zend引擎哈希表结构和关系 来自tipi"></p>
<p>详细解释：</p>
<ul>
<li>PHP的Zend引擎中哈希表处理冲突使用的是拉链</li>
<li>HashTable结构体中存储的是哈希表的整体信息，Bucket中存储的是真正的数据</li>
<li>Bucket结构体维护了两个双向链表，pNext和pLast指针分别指向本槽位所在的链表关系。比如相同hash值的两个key分别是k1,k2,先插入k1再插入k2，那么k2-&gt;pNext = k1; k1-&gt;pLast = k2;</li>
<li>pListHead和pListTail维护了整个哈希表的头元素指针和最后一个元素的指针。</li>
<li>关于pListNext和pListLast<ul>
<li>当在线性(顺序)遍历的时候, 就会从pListHead开始, 顺着Bucket中的pListNext/pListLast, 根据移动pInternalPointer, 来实现对所有元素的线性遍历。</li>
<li>数组添加元素的时候，依次添加元素。比如两个key，先添加k1再添加k2，则k1-&gt;pListNext=k2, k2-&gt;pListLast=k1。</li>
<li>也就是说PHP中遍历数组的顺序是和元素的添加先后顺序相关的。</li>
<li>哈希表的Bucket结构通过pListNext和pListLast维护了哈希表插入元素的先后顺序。</li>
</ul>
</li>
<li>pListNext和pListLast指针指向的是整个哈希表所有的数据之间的链接关系。</li>
</ul>
<p>参考文章：</p>
<ol>
<li><a href="http://www.laruence.com/2009/08/23/1065.html" target="_blank" rel="noopener">深入理解PHP之数组(遍历顺序)</a></li>
<li><a href="http://www.laruence.com/2008/11/20/630.html" target="_blank" rel="noopener">深入理解PHP原理之foreach</a></li>
<li><a href="http://www.php-internals.com/book/?p=chapt03/03-01-00-variables-structure" target="_blank" rel="noopener">变量的结构和类型</a></li>
<li><a href="http://www.php-internals.com/book/?p=chapt03/03-01-02-hashtable-in-php" target="_blank" rel="noopener">PHP的哈希表实现</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/09/20/3PHP变量之基本数据类型之哈希表/" data-id="ckw5yufjx0008tznuumhu38fy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php源码学习/">php源码学习</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Laravel/">Laravel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/composer/">composer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/">cpp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp-lib/">cpp-lib</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/faiss/">faiss</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-source-code/">go.source.code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/laravel/">laravel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/">mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/machine-learning/">machine-learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memcache/">memcache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nosql/">nosql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/octave/">octave</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php源码学习/">php源码学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/">spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tcp/">tcp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thrift/">thrift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础知识/">基础知识</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Laravel/" style="font-size: 10px;">Laravel</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/composer/" style="font-size: 10px;">composer</a> <a href="/tags/cpp/" style="font-size: 12.22px;">cpp</a> <a href="/tags/cpp-lib/" style="font-size: 10px;">cpp-lib</a> <a href="/tags/elasticsearch/" style="font-size: 11.11px;">elasticsearch</a> <a href="/tags/faiss/" style="font-size: 10px;">faiss</a> <a href="/tags/git/" style="font-size: 12.22px;">git</a> <a href="/tags/go-source-code/" style="font-size: 10px;">go.source.code</a> <a href="/tags/golang/" style="font-size: 16.67px;">golang</a> <a href="/tags/laravel/" style="font-size: 11.11px;">laravel</a> <a href="/tags/linux/" style="font-size: 14.44px;">linux</a> <a href="/tags/mac/" style="font-size: 13.33px;">mac</a> <a href="/tags/machine-learning/" style="font-size: 10px;">machine-learning</a> <a href="/tags/memcache/" style="font-size: 15.56px;">memcache</a> <a href="/tags/mysql/" style="font-size: 13.33px;">mysql</a> <a href="/tags/nginx/" style="font-size: 13.33px;">nginx</a> <a href="/tags/nosql/" style="font-size: 18.89px;">nosql</a> <a href="/tags/octave/" style="font-size: 10px;">octave</a> <a href="/tags/php/" style="font-size: 20px;">php</a> <a href="/tags/php源码学习/" style="font-size: 17.78px;">php源码学习</a> <a href="/tags/redis/" style="font-size: 12.22px;">redis</a> <a href="/tags/spark/" style="font-size: 12.22px;">spark</a> <a href="/tags/tcp/" style="font-size: 10px;">tcp</a> <a href="/tags/thrift/" style="font-size: 13.33px;">thrift</a> <a href="/tags/分布式/" style="font-size: 11.11px;">分布式</a> <a href="/tags/基础知识/" style="font-size: 15.56px;">基础知识</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/11/19/分布式-CAP理论/">分布式-CAP理论</a>
          </li>
        
          <li>
            <a href="/2021/11/16/Spark-DataSource-Hive Tables/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/11/14/分布式-事务/">分布式-事务</a>
          </li>
        
          <li>
            <a href="/2019/04/29/golang继承/">golang继承</a>
          </li>
        
          <li>
            <a href="/2019/04/28/spark-Quick-Start/">spark quick start</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Keything<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>