<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Keything的日志</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Keything的日志">
<meta property="og:url" content="http://keything.github.io/page/5/index.html">
<meta property="og:site_name" content="Keything的日志">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Keything的日志">
  
    <link rel="alternate" href="/atom.xml" title="Keything的日志" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Keything的日志</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://keything.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-mac安装hive" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/27/mac安装hive/" class="article-date">
  <time datetime="2016-11-27T01:42:54.000Z" itemprop="datePublished">2016-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/27/mac安装hive/">mac安装hive</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Mac安装hive"><a href="#Mac安装hive" class="headerlink" title="Mac安装hive"></a>Mac安装hive</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li>brew install hive</li>
</ol>
<h3 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h3><ol start="2">
<li>设置<code>HIVE_HOME=/usr/local/Cellar/hive/2.1.0/libexec</code></li>
<li><code>cp $HIVE_HOME/conf/hive-default.xml.template $HIVE_HOME/conf/hive-default.xml</code></li>
<li><p>hive-site.xml 文件中包含两部分，第一部分mysql是hive的metastore，存在mysql中。第二部分是metastore的目录。关于hive的metastore保存可以参考 官方wiki:<a href="http://wiki.apache.org/hadoop/Hive/AdminManual/MetastoreAdmin" target="_blank" rel="noopener">Hive Metastore</a>。其中配置中的用户名和密码都是hive</p>
<pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;

&lt;configuration&gt;

    &lt;property&gt;
        &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;
        &lt;value&gt;jdbc:mysql://127.0.0.1:3306/pdw?useSSL=false&lt;/value&gt;
    &lt;/property&gt;

    &lt;property&gt;
        &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;
        &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;
    &lt;/property&gt;

    &lt;property&gt;
        &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;
        &lt;value&gt;hive&lt;/value&gt;
    &lt;/property&gt;

    &lt;property&gt;
        &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;
        &lt;value&gt;hive&lt;/value&gt;
    &lt;/property&gt;

    &lt;property&gt;
        &lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt;
        &lt;value&gt;/user/hive/warehouse&lt;/value&gt;
    &lt;/property&gt;

&lt;/configuration&gt;
</code></pre></li>
<li><p>因为我们使用mysql存储meta信息，因此需要下载一个连接的jar包并将其放在<code>$HIVE_HOME/lib</code>中 <a href="http://dev.mysql.com/downloads/connector/j/" target="_blank" rel="noopener">jar包下载</a></p>
<p> <code>cp ~/Downloads/mysql-connector-java-5.1.40/mysql-connector-java-5.1.40-bin.jar $HIVE_HOME/lib</code></p>
</li>
</ol>
<h2 id="配置spark支持hive"><a href="#配置spark支持hive" class="headerlink" title="配置spark支持hive"></a>配置spark支持hive</h2><ol>
<li><p>Spark支持hive需要三个jar包，如果有的话则已经支持；如果没有的话则需要编译。在通过brew install spark 安装的spark2.0.1默认已经支持</p>
<p> ➜  ~ cd $SPARK_HOME/jars</p>
<p> ➜  ls -l d*</p>
<pre><code>-rw-r--r--@ 1 keything  staff   339666 Sep 29 08:03 datanucleus-api-jdo-3.2.6.jar
-rw-r--r--@ 1 keything  staff  1890075 Sep 29 08:03 datanucleus-core-3.2.10.jar
-rw-r--r--@ 1 keything  staff  1809447 Sep 29 08:03 datanucleus-rdbms-3.2.9.jar
</code></pre></li>
<li><p>配置文件的拷贝</p>
<ul>
<li><p>复制hive配置文件</p>
<p>  <code>cp $HIVE_HOME/conf/hive-site.xml $SPARK_HOME/conf/hive-site.xml</code></p>
</li>
<li><p>复制hdfs配置文件</p>
<p>  <code>cp $HADOOP_HOME/libexec/etc/hadoop/hdfs-site.xml $SPARK_HOME/conf/hdfs-site.xml</code><br>  <code>cp $HADOOP_HOME/libexec/etc/hadoop/core-site.xml $SPARK_HOME/conf/core-site.xml</code></p>
</li>
</ul>
</li>
<li><p>启动</p>
<p> <code>./bin/spark-shell --jars $HIVE_HOME/lib/mysql-connector-java-5.1.xx-bin.jar</code></p>
</li>
<li><p>测试</p>
</li>
</ol>
<pre><code>import org.apache.spark.sql.SQLContext
val hc = new org.apache.spark.sql.hive.HiveContext(sc)
val df = hc.sql(&quot;show databases&quot;)
df.show
</code></pre><p>注意：在执行<code>val df = hc.sql(&quot;show databases&quot;)</code>中会报出<code>16/11/27 09:09:35 ERROR metastore.RetryingHMSHandler: AlreadyExistsException(message:Database default already exists)
    at org.apache.hadoop.hive.metastore.HiveMetaStore$HMSHandler.create_database(HiveMetaStore.java:891)</code>的错误，可以忽略掉，如何不让这个错误出来，目前未知。</p>
<p>注意：在hadoop 2.7.3 下 启动hive 3.1 及 hive 2.3 都会报错：<br>hive 命令启动 </p>
<blockquote>
<p>show databases;<br>会有下面的报错<br><code>FAILED: HiveException java.lang.RuntimeException: Unable to instantiate org.apache.hadoop.hive.ql.metadata.SessionHiveMetaStoreClient</code></p>
</blockquote>
<p>换成hive 1.2.2以后没有问题。<br>hive下载地址:<a href="http://mirror.bit.edu.cn/apache/hive/" target="_blank" rel="noopener">http://mirror.bit.edu.cn/apache/hive/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/11/27/mac安装hive/" data-id="ckw1wzlf00039phnuhlnzm6ui" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mac/">mac</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="thrift-Thrift网络栈" class="article article-type-thrift" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/12/Thrift网络栈/" class="article-date">
  <time datetime="2016-11-12T08:29:53.000Z" itemprop="datePublished">2016-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/12/Thrift网络栈/">Thrift network stack</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Thrift-network-stack"><a href="#Thrift-network-stack" class="headerlink" title="Thrift network stack"></a>Thrift network stack</h3><p>本文翻译自<a href="http://thrift.apache.org/docs/concepts" target="_blank" rel="noopener">Thrift network stack</a></p>
<p>Apache Thrift网络栈的简要描述</p>
<pre><code>+-------------------------------------------+
| Server                                    |
| (single-threaded, event-driven etc)       |
+-------------------------------------------+
| Processor                                 |
| (compiler generated)                      |
+-------------------------------------------+
| Protocol                                  |
| (JSON, compact etc)                       |
+-------------------------------------------+
| Transport                                 |
| (raw TCP, HTTP etc)                       |
+-------------------------------------------+
</code></pre><h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><p>传输层提供了读写网络的简单抽象。这使得Thrift可以与系统的底层传输解耦（如序列化/反序列化）。<br>下面是传输层接口暴露的一些方法：</p>
<ul>
<li>open</li>
<li>close</li>
<li>read</li>
<li>write</li>
<li>flush</li>
</ul>
<p>除了上面的传输接口外，Thrift还使用<code>ServerTransport</code>接口来接受或创建原始的传输对象。正如名字所写的，服务器端端使用<code>ServerTransport</code>为到来的连接创建一个传输对象（Transport objects)。</p>
<ul>
<li>open</li>
<li>listen</li>
<li>accept</li>
<li>close</li>
</ul>
<p>大多数支持Thrift支持的语言的可选的一些传输如下：</p>
<ul>
<li>file: read/write to/from a file on disk</li>
<li>http: as the name suggests</li>
</ul>
<p>###协议<br>协议的抽象定义了将内存中结构映射为有线格式（wire-format）的机制。换句话说，协议指明了数据如何使用底层的传输来进行编解码。因此协议实现控制了编码格式，并负责序列化和反序列化。协议举例，如JSON,XML,plain text, compact binary 。</p>
<p>下面是协议接口：</p>
<pre><code>writeMessageBegin(name, type, seq)
writeMessageEnd()
writeStructBegin(name)
writeStructEnd()
writeFieldBegin(name, type, id)
writeFieldEnd()
writeFieldStop()
writeMapBegin(ktype, vtype, size)
writeMapEnd()
writeListBegin(etype, size)
writeListEnd()
writeSetBegin(etype, size)
writeSetEnd()
writeBool(bool)
writeByte(byte)
writeI16(i16)
writeI32(i32)
writeI64(i64)
writeDouble(double)
writeString(string)

name, type, seq = readMessageBegin()
                  readMessageEnd()
name = readStructBegin()
       readStructEnd()
name, type, id = readFieldBegin()
                 readFieldEnd()
k, v, size = readMapBegin()
             readMapEnd()
etype, size = readListBegin()
              readListEnd()
etype, size = readSetBegin()
              readSetEnd()
bool = readBool()
byte = readByte()
i16 = readI16()
i32 = readI32()
i64 = readI64()
double = readDouble()
string = readString()
</code></pre><p>Thrift协议是面向流的。没有必要需要任何明确的框架。举例，开始序列化的时候，不需要知道字符串的长度或列表中的个数。大多数支持Thrift语言可选的协议：</p>
<ul>
<li>binary：相当简单的二进制编码–字段的长度和类型都编码为字节</li>
<li>compact：在<a href="https://issues.apache.org/jira/browse/THRIFT-110" target="_blank" rel="noopener">THRIFT-100</a>中描述</li>
<li>json</li>
</ul>
<p>###处理器（Processor）</p>
<p>一个处理器有两个能力：从输入流读取数据，将数据写入到输出流。协议对象（protocal objects）代表输入流和输出流。处理器接口可以非常简单：</p>
<pre><code>interface TProcessor {
    bool process(TProtocol in, TProtocol out) throws TException
}
</code></pre><p>特定服务处理器(service-specific)的实现是由compiler生成的。本质上处理器processor使用输入协议从wire读取数据，将处理过程委托给用户自己实现的handler，然后使用输出协议将数据写入wire。</p>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>一个server将上面描述的所有的不同的特性聚合在一起：</p>
<ul>
<li>创建一个传输 transport</li>
<li>为传输创建一个input/output协议</li>
<li>基于Input/output协议创建一个处理器processor</li>
<li>等待输入连接，并将其交给processor</li>
</ul>
<h3 id="其他文章"><a href="#其他文章" class="headerlink" title="其他文章"></a>其他文章</h3><p><a href="http://thrift.apache.org/docs/features" target="_blank" rel="noopener">Thrift Feature</a></p>
<p><a href="http://thrift.apache.org/docs/idl" target="_blank" rel="noopener">Thrift interface description language</a></p>
<p><a href="http://thrift.apache.org/docs/install/" target="_blank" rel="noopener">Thrift install</a></p>
<p><a href="http://thrift.apache.org/docs/types" target="_blank" rel="noopener">Thrift types</a></p>
<p><a href="http://dongxicheng.org/search-engine/thrift-guide/" target="_blank" rel="noopener"></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/11/12/Thrift网络栈/" data-id="ckw1wzle80019phnubw3v2pfg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thrift/">thrift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Thrift：可扩展的跨语言的服务实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/12/Thrift：可扩展的跨语言的服务实现/" class="article-date">
  <time datetime="2016-11-12T08:26:52.000Z" itemprop="datePublished">2016-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/12/Thrift：可扩展的跨语言的服务实现/">Thrift：可扩展的跨语言的服务实现[论文翻译]</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文翻译<a href="http://thrift.apache.org/static/files/thrift-20070401.pdf" target="_blank" rel="noopener">Thrift: Scalable Cross-Language Services Implementation</a></p>
<p>有一些地方没有翻译到，就纯纯的用英文直接读咯.</p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Thrift是什么呢？Thrift由Facebook开发；Thrift是一个软件库，一个代码生成工具的集合；通过这些工具可以加快高效可扩展的后端服务的开发和实现。Thrift的主要目标是：实现跨语言的高效可靠的通信。实现方式：将各个语言中需要的定制化抽象为一个通用的库。这个库是由各个语言实现的一个库。 特别地，Thrift允许开发者以一个中立语言（language-neutral)文件定义数据类型和服务接口，并且生成构建RPC客户端和服务器端的所需的所有必要的代码。 </p>
<p>这篇论文详细介绍了Thrift中的动机和设计思想。 这并不是作为一个研究，而是详细阐述了我们做了什么以及为什么这么做。 </p>
<h2 id="1-说明"><a href="#1-说明" class="headerlink" title="1. 说明"></a>1. 说明</h2><p>一句话，单纯的LAMP框架不能够满足Facebook的需求，Facebook的文化就是选择最好的工具和实现来达到最好的性能。那么带来的问题就是需要在各个语言之间建立一个透明和高性能的桥。我们发现大多数可选系统要么限制太多，要么有性能问题。</p>
<p>我们的实现方案：将一个中立语言软件栈与一个代码生成引擎进行组装。<br>中立语言软件栈可以由许多编程语言实现。<br>代码生成引擎可以可以将简单接口和数据定义语言转换为客户端和服务端调用的远程库。</p>
<p>在一个动态系统上选择一个静态代码生成，允许我们可以创建有效的代码；这些代码不需要进行实时的类型检查。对于开发者而言，可以在一个简短的文件中定义复杂服务所需要的数据类型和接口。</p>
<p>令人惊讶的是竟然一个健壮的开源的解决方案，因此我们将Thrift的实现进行了开源。</p>
<p>评估了网络环境下，跨语言交互的挑战后，我们明确了一些关键组件：</p>
<ul>
<li>types：必须有一个通用的类型系统；跨语言的时候，应用开发者不需要使用自定义的thrift数据类型或者写自己的序列化代码。也就是说，一个C++程序员能够透明的将一个STL map转换为python的字字典。不需要程序员写应用层以下的代码。 </li>
<li>transport。每个语言都需要一个通用的双向数据传输的接口。服务开发者（service developer）不需要关心特定传输是如何实现的。相同的应用代码可以跑在不同的传输上，比如TCP流，内存中数据，或者硬盘上的文件。</li>
<li>protocol：数据类型必须有某种使用传输层的方式来编解码自己。当然，应用开发者不需要关心协议这一层的实现。对于应用层代码而言，使用XML或二进制协议都是一样的。所有要确定的就是，必须以始终一样的确定的协议进行传输</li>
<li>versioning。对于健壮的服务，所包含的数据类型必须提供一个版本化自己的机制。特别的，能够在不破坏服务的情况下增加或删除对象(或者函数列表)中的字段。Section 5 details Thrift’s versioning system.</li>
<li>Processors：最后，我们生成能够处理数据流的代码来完成远程进程调用。Section 6 details the generated code and TProcessor paradigm。</li>
<li>Section 7 discusses implementation details, and Section 8 describes our conclusions.</li>
</ul>
<h2 id="2-Types"><a href="#2-Types" class="headerlink" title="2. Types"></a>2. Types</h2><p>Thrift类型系统是为了：不管使用什么编程语言，都使用完全原生的类型进行开发。设计上，Thrift类型系统不会引入任何特别的动态类型或者wrapper objects。并且，不需要开发者写任何对象序列化或传输的代码。Thrift IDL（Interface Definition Language）文件以最简单的方式告诉代码生成工具，如何安全的跨语言的传输对象。</p>
<h3 id="2-1-base-types"><a href="#2-1-base-types" class="headerlink" title="2.1 base types"></a>2.1 base types</h3><p>类型系统依赖一些基础类型。考虑支持哪些类型时，我们目标是在所有编程语言中都可用的数据类型。<br>在Thrift中支持的基础类型是</p>
<ul>
<li>bool</li>
<li>byte</li>
<li>i16: a 16-bit signed integer</li>
<li>i32: a 32-bit signed integer</li>
<li>i64: a 64-bit signed integer</li>
<li>double: a 64-bit floating point </li>
<li>string: 一个不知道编码的文本或者二进制文件。</li>
</ul>
<p>特别注意的是unsigned integer类型的缺失。因为在很多语言中这个类型不能明确的转换为基础类型。并且，在一些语言如python中，应用开发者会给整形变量赋值一个负值。从设计的角度来说，我们发现unsigned integers在算术运算中很少用，实际中大都用作key或者标识符。这种情况下，sign就无关紧要了。signed integers同样可以做，并且可以在需要的时候安全的转换为unsigned。</p>
<h3 id="2-2-structs"><a href="#2-2-structs" class="headerlink" title="2.2 structs"></a>2.2 structs</h3><p>一个Thrift的struct定义了一个对象，可以在不同语言中使用。本质上，结构体等同于面向对象语言的类。定义Thrfit结构体的基本语法类似C的结构体定义。字段可能会用一个整形来进行注释，并且有一个默认值。如果忽略的话，会有一个默认值；不过强烈建议有取值，这对于稍后的版本有很大用处。 </p>
<h3 id="2-3-Containers"><a href="#2-3-Containers" class="headerlink" title="2.3 Containers"></a>2.3 Containers</h3><p>Thrift中的container可以映射到很多语言中的container。可以用C++模板的样式进行标记。有三种可选的类型：</p>
<ul>
<li>list<type>:元素的有序列表。直接转换为STL vector，Java ArrayList, 或JS的native array</type></li>
<li>set<type>:元素的无序集合。转为了STL set， Java HashSet，python的set，或PHP中的字典</type></li>
<li>map&lt;type1, type2&gt;:key到value的映射。转为STL map，Java HashMap，PHP的关联数组</li>
</ul>
<p>当提供默认值时，类型的映射并不是固定的。Container中的元素可以是任何有效的Thrift类型，包含其他结构体的containers。</p>
<pre><code>struct Example {
    1:i32 number = 10,
    2:i64 bigNumber,
    3:double decimals,
    4:string name=&quot;thrifty&quot;
}
</code></pre><p>在目标语言中，每个定义都会生成两种方法的类型，read和write，用于执行序列化和使用Thrift TProtocol对象传输。</p>
<h3 id="2-4-Exception"><a href="#2-4-Exception" class="headerlink" title="2.4 Exception"></a>2.4 Exception</h3><p>异常在语法和功能上等同于结构体，除了使用exception关键字而不是使用struct关键字。<br>生成的对象继承自某个异常基类。目的是：用一种应用层开发者熟悉的代码风格。 </p>
<h3 id="2-5-Services"><a href="#2-5-Services" class="headerlink" title="2.5 Services"></a>2.5 Services</h3><p>使用Thrift类型定义服务service。在语义上，service的定义等同于接口的定义（或者一个纯虚抽象类）。Thrift编译器生成实现这些接口的全部功能的client和server stubs。service定义如下：</p>
<pre><code>service &lt;name&gt; {
    &lt;returntype&gt; &lt;name&gt;(&lt;arguments&gt;)
        [throw (&lt;exceptions&gt;)]
}
</code></pre><p>一个例子：</p>
<pre><code>service StringCache {
    void set(1:i32 key 2:string value),
    string get(1:i32 key) throws (1:KeyNotFound knf),
    void delete(1:i32 key)
}
</code></pre><p>注意到void是函数返回的有效类型，当然也可以返回其他已经定义的thrift类型。另外，<code>async</code>关键字可以加到void函数上，其生成的代码不需要等待服务器的响应。对于一个纯净的void函数，只有完成服务器端的操作以后才会给客户端返回响应。使用async方法调用个，客户端只保证传输层的请求成功。<br>也需要注意到参数列表和异常列表也可以实现为thrift structs。在notation和行为上，三种的构造是相同的。 </p>
<h2 id="3-Transport"><a href="#3-Transport" class="headerlink" title="3. Transport"></a>3. Transport</h2><p>生成的代码使用传输层加速数据传输</p>
<h3 id="3-1-接口"><a href="#3-1-接口" class="headerlink" title="3.1 接口"></a>3.1 接口</h3><p>在Thrift设计中一个关键的设计选择是：从代码生成层中解耦传输层。Though Thrift is typically used on top of the TCP/IP stack with streaming sockets as the base layer of communication, there was no compelling reason to build that constraint into the system。与真实的I/O操作相比，抽象I/O层带来的性能损耗是无关紧要的。</p>
<p>根本上，生成的Thrift代码只需要知道如何读取和写入数据。数据的起始是无关紧要的；它可能是一个socket，一个共享内存的片段，或者本地磁盘的一个文件。Thrift传输接口支持下面的方法：</p>
<ul>
<li>open： 打开传输</li>
<li>close：关闭传输</li>
<li>isOpen：标识传输是否打开</li>
<li>read：读取</li>
<li>write：写入</li>
<li>flush：</li>
</ul>
<p>有一些接口没有列出来，这些接口用于批量读取 and optionally signaling the comple- tion of a read or write operation from the generated code.</p>
<p>除了上面的TTransport接口，还有一个TServerTransport接口用于接收或创建原始的transport objects。其接口如下：</p>
<ul>
<li>open</li>
<li>listen</li>
<li>accept</li>
<li>close</li>
</ul>
<h3 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a>3.2 实现</h3><p>在任何语言中很容易实现传输层接口。如果需要的话，开发者可以实现新的传输层机制。 </p>
<h4 id="3-2-1-TSocket"><a href="#3-2-1-TSocket" class="headerlink" title="3.2.1 TSocket"></a>3.2.1 TSocket</h4><p>在所有目标语言中，实现TSocket类。提供了一个TCP/IP stream socket的通用的简单的接口。</p>
<h4 id="3-2-2-TFileTransport"><a href="#3-2-2-TFileTransport" class="headerlink" title="3.2.2 TFileTransport"></a>3.2.2 TFileTransport</h4><p>TFileTransport是硬盘文件数据流的抽象。可以将到来的thrift请求写入到硬盘文件中。硬盘数据可以从日志中重放，用于post-process或reproduction 或者过去事件的同步。</p>
<h4 id="3-2-3-Utilities"><a href="#3-2-3-Utilities" class="headerlink" title="3.2.3 Utilities"></a>3.2.3 Utilities</h4><p>The Transport interface is designed to support easy extension us- ing common OOP techniques, such as composition. Some sim- ple utilites include the TBufferedTransport, which buffers the writes and reads on an underlying transport, the TFramedTransport, which transmits data with frame size headers for chunking op- timization or nonblocking operation, and the TMemoryBuffer, which allows reading and writing directly from the heap or stack memory owned by the process</p>
<h2 id="4-Protocol"><a href="#4-Protocol" class="headerlink" title="4. Protocol"></a>4. Protocol</h2><p>Thrift中的第二个重要的抽象是：数据结构和传输层表示的分离。 当传输数据时，Thrift加强了（enforce）一种消息结构，但是对于正在用的协议编码是不可知的。也就是，不需要关心数据是编码为XML，还是ASCII，还是二进制；只要数据支持固定的操作集合就行。</p>
<h3 id="4-1-接口"><a href="#4-1-接口" class="headerlink" title="4.1 接口"></a>4.1 接口</h3><p>Thrift的Protocol接口很直接。根本上它支持两件事：1. 双向的顺序消息 2. base type，containers，structs的编码。</p>
<pre><code>writeMessageBegin(name, type, seq)
writeMessageEnd()
writeStructBegin(name)
writeStructEnd()
writeFieldBegin(name, type, id)
writeFieldEnd()
writeFieldStop()
writeMapBegin(ktype, vtype, size)
writeMapEnd()
writeListBegin(etype, size)
writeListEnd()
writeSetBegin(etype, size)
writeSetEnd()
writeBool(bool)
writeByte(byte)
writeI16(i16)
writeI32(i32)
writeI64(i64)
writeDouble(double)
writeString(string)

name, type, seq = readMessageBegin()
                  readMessageEnd()
name = readStructBegin()
       readStructEnd()
name, type, id = readFieldBegin()
                 readFieldEnd()
k, v, size = readMapBegin()
             readMapEnd()
etype, size = readListBegin()
              readListEnd()
etype, size = readSetBegin()
              readSetEnd()
bool = readBool()
byte = readByte()
i16 = readI16()
i32 = readI32()
i64 = readI64()
double = readDouble()
string = readString()
</code></pre><p>Note that every write function has exactly one read counter- part, with the exception of writeFieldStop(). This is a special method that signals the end of a struct. The procedure for reading a struct is to readFieldBegin() until the stop field is encountered, and then to readStructEnd(). The generated code relies upon this call sequence to ensure that everything written by a protocol encoder can be read by a matching protocol decoder. Further note that this set of functions is by design more robust than necessary. For example, writeStructEnd() is not strictly necessary, as the end of a struct may be implied by the stop field. This method is a convenience for verbose protocols in which it is cleaner to separate these calls (e.g. a closing  tag in XML).</p>
<h3 id="4-2-structure"><a href="#4-2-structure" class="headerlink" title="4.2 structure"></a>4.2 structure</h3><p>Thrift structures are designed to support encoding into a streaming protocol. The implementation should never need to frame or com- pute the entire data length of a structure prior to encoding it. This is critical to performance in many scenarios. Consider a long list of relatively large strings. If the protocol interface required reading or writing a list to be an atomic operation, then the implementation would need to perform a linear pass over the entire list before en- coding any data. However, if the list can be written as iteration is performed, the corresponding read may begin in parallel, theoreti- cally offering an end-to-end speedup of (kN − C), where N is the size of the list, k the cost factor associated with serializing a sin- gle element, and C is fixed offset for the delay between data being written and becoming available to read.<br>Similarly, structs do not encode their data lengths a priori. Instead, they are encoded as a sequence of fields, with each field having a type specifier and a unique field identifier. Note that the inclusion of type specifiers allows the protocol to be safely parsed and decoded without any generated code or access to the original IDL file. Structs are terminated by a field header with a special STOP type. Because all the basic types can be read deterministically, all structs (even those containing other structs) can be read deterministically. The Thrift protocol is self-delimiting without any framing and regardless of the encoding format.<br>In situations where streaming is unnecessary or framing is advan- tageous, it can be very simply added into the transport layer, using the TFramedTransport abstraction.</p>
<h3 id="4-3-实现"><a href="#4-3-实现" class="headerlink" title="4.3 实现"></a>4.3 实现</h3><p>Facebook has implemented and deployed a space-efficient binary protocol which is used by most backend services. Essentially, it writes all data in a flat binary format. Integer types are converted to network byte order, strings are prepended with their byte length, and all message and field headers are written using the primitive integer serialization constructs. String names for fields are omitted - when using generated code, field identifiers are sufficient.<br>We decided against some extreme storage optimizations (i.e. pack- ing small integers into ASCII or using a 7-bit continuation for- mat) for the sake of simplicity and clarity in the code. These alter- ations can easily be made if and when we encounter a performance- critical use case that demands them.</p>
<h2 id="5-Versioning"><a href="#5-Versioning" class="headerlink" title="5. Versioning"></a>5. Versioning</h2><p>面对版本和数据定义改变，Thrift是健壮的。对于已经部署的服务，改变的阶段性健壮是必须的。系统必须支持 1. 从日志中读取旧数据 2. 接收来自过期客户端到新服务器的请求等等</p>
<h3 id="5-1-Field-Identifiers"><a href="#5-1-Field-Identifiers" class="headerlink" title="5.1 Field Identifiers"></a>5.1 Field Identifiers</h3><p>Thrift中的版本是通过字段标识符来实现的。 最好的编程实践是清晰的制定字段标识符。 </p>
<pre><code>struct Example {
    1:i32 number=10,
    2:i64 bigNumber,                        
    3:double decimals,
    4:string name=&quot;thrifty&quot;
}
</code></pre><h3 id="5-2-Isset"><a href="#5-2-Isset" class="headerlink" title="5.2 Isset"></a>5.2 Isset</h3><h3 id="5-3-Case-Analysis"><a href="#5-3-Case-Analysis" class="headerlink" title="5.3 Case Analysis"></a>5.3 Case Analysis</h3><h3 id="5-4-Protocol-Transport-Versioning"><a href="#5-4-Protocol-Transport-Versioning" class="headerlink" title="5.4 Protocol/Transport Versioning"></a>5.4 Protocol/Transport Versioning</h3><h2 id="6-RPC实现"><a href="#6-RPC实现" class="headerlink" title="6. RPC实现"></a>6. RPC实现</h2><h3 id="6-1-TProcessor"><a href="#6-1-TProcessor" class="headerlink" title="6.1 TProcessor"></a>6.1 TProcessor</h3><p>Thrift设计中最后一个核心接口是TProcessor，可能是最简单的构造了。接口如下：</p>
<pre><code>interface TProcessor {
    bool process(TProtocol in, TProtocol out)
        throws TException
}
</code></pre><p>这儿关键的设计观点是：我们创建的复杂系统从根本上可以看做是处理输入和输出的服务。大多数情况下，确实是一个需要处理的输入和输出系统。</p>
<h3 id="6-2-Generated-Code"><a href="#6-2-Generated-Code" class="headerlink" title="6.2 Generated Code"></a>6.2 Generated Code</h3><p>当定义一个service时，我们生成一个能够处理RPC请求的TProcessor实例。基本结构如下：</p>
<pre><code>Service.thrift
=&gt; Service.cpp
interface ServiceIf
class ServiceClient : virtual ServiceIf
    TProtocol in
    TProtocol out
class ServiceProcessor : TProcessor
    ServiceIf handler


ServiceHandler.cpp
    class ServiceHandler : virtual ServiceIf

TServer.cpp
    TServer(TProcessor processor,
        TServerTransport transport,
        TTransportFactory tfactory,
        TProtocolFactory pfactory)
    serve()
</code></pre><ul>
<li>从Thrift定义文件，我们生成虚拟服务接口。</li>
<li>生成的客户端类实现了接口，并使用两个TProtocol实例执行I/O操作。</li>
<li>生成的processor实现了TProcessor接口</li>
<li>生成的代码中有所有处理RPC请求的逻辑，通过process()调用来处理。</li>
<li>用户提供一个应用接口的实现，这与生成的源码是独立的。</li>
</ul>
<h3 id="6-3-TServer"><a href="#6-3-TServer" class="headerlink" title="6.3 TServer"></a>6.3 TServer</h3><p>最后，Thrift 核心库提供了一个TServer的抽象。TServer对象通常如下工作：</p>
<ul>
<li>使用TServerTransport生成一个TTransport</li>
<li>使用TTransportFactory将一个基本的transport转换为合适的应用层transport（典型的是使用TBufferedTransportFactory）</li>
<li>使用TProtocolFactory 创建一个用于TTransport的input/output协议</li>
<li>触发TProcessor对象的process()方法</li>
</ul>
<p>这些层都是分开的，从而服务器代码不需要知道传输层、编码。server封装了连接处理、线程等逻辑。The only code written by the application developer lives in the definitional Thrift file and the interface implementation.</p>
<p>设计的TProcessor接口很通用。一个TServer没有带着一个生成的TProcessor对象。Thrift允许应用开发者写任何类型的server用于处理TProtocol对象。</p>
<h2 id="7-实现细节"><a href="#7-实现细节" class="headerlink" title="7. 实现细节"></a>7. 实现细节</h2><h3 id="7-1-Target-Language"><a href="#7-1-Target-Language" class="headerlink" title="7.1 Target Language"></a>7.1 Target Language</h3><p>Thrift目前支持五种目标语言：C++, Java, Python, Ruby 和PHP。</p>
<h3 id="7-2-Generated-Structs"><a href="#7-2-Generated-Structs" class="headerlink" title="7.2 Generated Structs"></a>7.2 Generated Structs</h3><p>We made a conscious decision to make our generated structs as transparent as possible. All fields are publicly accessible; there are no set() and get() methods. Similarly, use of the isset object is not enforced. We do not include any FieldNotSetException construct. Developers have the option to use these fields to write more robust code, but the system is robust to the developer ignor- ing the isset construct entirely and will provide suitable default behavior in all cases.<br>This choice was motivated by the desire to ease application devel- opment. Our stated goal is not to make developers learn a rich new library in their language of choice, but rather to generate code that allow them to work with the constructs that are most familiar in each language.<br>We also made the read() and write() methods of the generated objects public so that the objects can be used outside of the con- text of RPC clients and servers. Thrift is a useful tool simply for generating objects that are easily serializable across programming languages.</p>
<h3 id="7-3-RPC-Method-Identification"><a href="#7-3-RPC-Method-Identification" class="headerlink" title="7.3 RPC Method Identification"></a>7.3 RPC Method Identification</h3><p>在RPC中是通过发送方法名来调用方法的。 这种方法的一个问题是需要更多的带宽。</p>
<p>在方法调用时，我们希望避免很多不必要的字符串比较。为了处理这个，我们生成字符串到函数指针的映射，因此通常情况下能够以常量时间完成方法调用。在C++中，我们使用一个相对深奥的语言构造：member function pointers。</p>
<pre><code>std::map&lt;std::string,
    void (ExampleServiceProcessor::*)(int32_t,
    facebook::thrift::protocol::TProtocol*,
    facebook::thrift::protocol::TProtocol*)&gt;
    processMap_;
</code></pre><p>使用这些技术，处理字符串的消耗被降到最低。</p>
<h3 id="7-4-Servers-and-Multithreading"><a href="#7-4-Servers-and-Multithreading" class="headerlink" title="7.4 Servers and Multithreading"></a>7.4 Servers and Multithreading</h3><p>Thrift服务需要基本的多线程来处理并发请求。对于Python和Java的Thrift服务器逻辑的实现，语言自带的线程库提供了足够的支持。对于C++的实现，没有标准的多线程实时库。特别地，健壮的、轻量的、可移植的线程管理和timer类不存在。我们研究了已有的实现，有boost::thread, boost:threadpool, ACE_Thread_Manager, ACE_TImer。</p>
<p>boost::threads：提供了多线程的轻量、健壮的实现；但是没有提供线程管理或timer实现。<br>boost::threadpool:看起来不错但还是没有达到我们的目标。我们希望尽可能的限制第三方以来。因为boost::threadpool不是一个纯净的模板库，还需要实时库，因为目前还不是官方boost的一部分。</p>
<h3 id="7-5-Thread-Primitives"><a href="#7-5-Thread-Primitives" class="headerlink" title="7.5 Thread Primitives"></a>7.5 Thread Primitives</h3><p>在命名空间facebook::thrift::concurrency中实现了Thrift线程库，有三个组件：</p>
<ul>
<li>primitives</li>
<li>thread pool manager</li>
<li>timer manager</li>
</ul>
<p>正如上面提到的，我们在由于要不要在thrift中引入其他依赖。我们决定使用boost::shared_ptr，因为这对于多线程应用是很有用的，不需要link-time或runtime库，并且它编程了C++0x标准的一部分。</p>
<p>我们实现了标准的Mutex和Condition类，和一个Monitor类。后者是一个mutex和condition变量的组合，有点类似Java Object的Monitor实现。</p>
<p>This is also sometimes referred to as a barrier. We provide a Synchronized guard class to allow Java-like synchronized blocks. This is just a bit of syntactic sugar, but, like its Java counterpart, clearly delimits critical sec- tions of code. Unlike its Java counterpart, we still have the ability to programmatically lock, unlock, block, and signal monitors.</p>
<p>xxxx<br>xxxx<br>xxxx</p>
<h3 id="7-6-Thread-Runnable-and-shared-ptr"><a href="#7-6-Thread-Runnable-and-shared-ptr" class="headerlink" title="7.6 Thread, Runnable, and shared_ptr"></a>7.6 Thread, Runnable, and shared_ptr</h3><h3 id="7-7-ThreadManager"><a href="#7-7-ThreadManager" class="headerlink" title="7.7 ThreadManager"></a>7.7 ThreadManager</h3><h3 id="7-8-TimerManager"><a href="#7-8-TimerManager" class="headerlink" title="7.8 TimerManager"></a>7.8 TimerManager</h3><h3 id="7-9-Nonblocking-Operation"><a href="#7-9-Nonblocking-Operation" class="headerlink" title="7.9 Nonblocking Operation"></a>7.9 Nonblocking Operation</h3><h3 id="7-10-Compiler"><a href="#7-10-Compiler" class="headerlink" title="7.10 Compiler"></a>7.10 Compiler</h3><h3 id="7-11-TFileTransport"><a href="#7-11-TFileTransport" class="headerlink" title="7.11 TFileTransport"></a>7.11 TFileTransport</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/11/12/Thrift：可扩展的跨语言的服务实现/" data-id="ckw1wzle9001cphnu0u1k5t2t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thrift/">thrift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Thrift安装" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/12/Thrift安装/" class="article-date">
  <time datetime="2016-11-11T23:41:07.000Z" itemprop="datePublished">2016-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/12/Thrift安装/">Thrift安装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>参考文章：<br><a href="http://thrift.apache.org/tutorial/" target="_blank" rel="noopener">http://thrift.apache.org/tutorial/</a><br><a href="http://thrift.apache.org/docs/BuildingFromSource" target="_blank" rel="noopener">http://thrift.apache.org/docs/BuildingFromSource</a></p>
<p>几点说明：</p>
<ol>
<li>在mac上尝试，PHP是可以的，但是CPP的例子跑不通。</li>
<li>在centos6.8上使用BuildingFromSource进行安装（需要libevent），CPP的例子直接就编译通过。目录(tutorial/cpp/)</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/11/12/Thrift安装/" data-id="ckw1wzle70014phnux8ms6u7s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thrift/">thrift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-laravel到lumen" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/07/laravel到lumen/" class="article-date">
  <time datetime="2016-10-07T09:55:38.000Z" itemprop="datePublished">2016-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/07/laravel到lumen/">laravel到lumen</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Lumen中，默认不会加载Facades，默认不会注册Provider，可以在bootstrap/app.php中看到。</p>
<ol>
<li><p>关于Facades<br> 如果想使用Facades，那么修改bootstrap/app.php</p>
<pre><code>$app-&gt;withFacades();
</code></pre><p> 如果你自己定义了Facades的话，那么需要使用如下方式加载:</p>
<pre><code>$user_facades_alias = [
    App\Http\Facades\KLog::class =&gt; &apos;KLog&apos;,
];
$app-&gt;withFacades(true, $user_facades_alias);
</code></pre><p> 当然不能忘了加载Provider，</p>
<pre><code>$app-&gt;register(App\Providers\KLogProvider::class);
</code></pre></li>
<li><p>关于加载配置文件</p>
<p> 在Laravel中，我们已经习惯<code>config(&#39;config_file.config_item&#39;)</code>，但是在Lumen中服务都是按需绑定并加载的。为了与Laravel中代码尽可能保持一致，方便二者代码的迁移，因此依然在bootstrap/app.php中修改，修改如下：</p>
<pre><code>$cfg_files = [
    &apos;database_split&apos;,
    &apos;database&apos;,
    &apos;didicfg&apos;,
    &apos;errno&apos;,
    &apos;timeout&apos;,
];

foreach ($cfg_files as $cfg_file) {
    $app-&gt;configure($cfg_file);
}
</code></pre></li>
<li><p>关于异常处理</p>
<p> 我们知道在app/Exception/Handler.php中可以对特定的异常进行特别处理，对于render返回return []，laravel会自动转为json输出，而对于Lumen必须return json_encode([])才可以。</p>
</li>
<li><p>目前我知道的需要改变的地方是这些，以后有的话会继续补充</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/10/07/laravel到lumen/" data-id="ckw1wzleu002sphnupvkwi6z6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/laravel/">laravel</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Laravel等框架压测" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/06/Laravel等框架压测/" class="article-date">
  <time datetime="2016-10-06T08:05:23.000Z" itemprop="datePublished">2016-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/06/Laravel等框架压测/">Laravel等框架压测</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在学习Laravel过程中，发现大家都讲到Laravel性能比较差，又了解到Laravel为了性能专门有一个Lumen框架，为了更加客观的知道各个框架的性能，现在进行测试。</p>
<ol>
<li><p>压测工具<br> 采用boom</p>
<p> 安装 pip install boom</p>
</li>
<li><p>压测参数</p>
<p> boom your.domain -c 2000 -n 100</p>
</li>
<li><p>压测框架</p>
<p> 对CI2，YII2，Laravel5.3， Lument5.2进行压测</p>
</li>
<li><p>代码及输出</p>
<p> 都是在TestController中输出json串</p>
<p> {“hello”:”world”,”hello2”:”world2”}</p>
</li>
<li><p>压测结果</p>
<p> CI2&gt;LUMENT5.2&gt;YII2&gt;LARAVEL5.3(优化过)&gt;LARAVEL5.3(没有优化)<br> 开启OPCACHE以后性能有显著提高，如下图所示：</p>
<p> <img src="/images/PHP框架QPS对比.png" alt="PHP框架QPS对比.png"></p>
</li>
</ol>
<p>附注：Laravel优化的语句是</p>
<pre><code>配置信息缓存 php artisan config:cache
路由缓存 php artisan route:cache
类映射加载优化 php artisan optimize
自动加载优化 composer dumpautoload
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/10/06/Laravel等框架压测/" data-id="ckw1wzldy000hphnu2p19fh6f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/laravel/">laravel</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Laravel中日志类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/03/Laravel中日志类/" class="article-date">
  <time datetime="2016-10-03T08:19:37.000Z" itemprop="datePublished">2016-10-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/03/Laravel中日志类/">Laravel中日志类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="问题描述及改进方法"><a href="#问题描述及改进方法" class="headerlink" title="问题描述及改进方法"></a>问题描述及改进方法</h2><ol>
<li><p>Laravel中原有的日志门面Log</p>
<p> 在Laravel中大家都知道Log，其用法是</p>
<pre><code>use Log;
Log::info();
</code></pre><p> 但是这个存在一个问题，通过Log门面打印的日志是打印到一个Log文件中，不利于日志监控。</p>
</li>
<li><p>改进的日志门面KLog</p>
<p> 通过添加一个自定义的日志门面KLog，将日志打印到不同的文件中，并且自动实现日志按天切割。</p>
</li>
</ol>
<h2 id="实现日志门面KLog"><a href="#实现日志门面KLog" class="headerlink" title="实现日志门面KLog"></a>实现日志门面KLog</h2><p>所谓门面facade，简单概括为以静态语法的方式调用底层类。门面的详细解释可以参考<a href="http://laravelacademy.org/post/5820.html" target="_blank" rel="noopener">核心概念 —— 门面（Facades）</a></p>
<p>在 Laravel 应用中，门面就是一个为容器中对象提供访问方式的类。该机制原理由 Facade 类实现。Laravel 自带的门面，以及我们创建的自定义门面，都会继承自 Illuminate\Support\Facades\Facade 基类。</p>
<p>门面类只需要实现一个方法：getFacadeAccessor。正是 getFacadeAccessor 方法定义了从容器中解析什么，然后Facade 基类使用魔术方法 __callStatic() 从你的门面中调用解析对象。</p>
<p>因此门面类KLog的实现如下</p>
<pre><code>&lt;?php
// filepath:app/Http/Facades/KLog.php
namespace App\Http\Facades;

use Illuminate\Support\Facades\Facade;


/**
 * @see \APP\Http\Logic\KLogLogic
 */
class KLog extends Facade
{
    protected static function getFacadeAccessor()
    {
       return &apos;KLog&apos;;//该方法的工作就是返回服务容器绑定类的别名
    }
}
</code></pre><p>KLog门面继承 Facade 基类并定义了 getFacadeAccessor 方法，该方法的工作就是返回服务容器绑定类的别名，当用户引用 KLog类的任何静态方法时，Laravel 从服务容器中解析 KLog绑定，然后在解析出的对象上调用所有请求方法。<code>getFacadeAccessor</code>返回的是在config/app.php中aliases的别名。</p>
<p>前面提到<code>门面就是一个为容器中对象提供访问方式的类</code>，那么服务容器是什么呢？可以参考<a href="http://laravelacademy.org/post/5805.html" target="_blank" rel="noopener">核心概念-服务容器</a> 。既然提到服务容器，就必然提到<a href="http://laravelacademy.org/post/5809.html" target="_blank" rel="noopener">服务提供者</a>。服务提供者是Laravel应用启动的中心，你自己的应用以及所有Laravel的核心服务都是通过服务提供者启动。</p>
<p>KLog类的服务提供者实现如下:</p>
<pre><code>&lt;?php
// filepath:app/Providers/KLogProvider.php
namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class KLogProvider extends ServiceProvider
{
    public function register()
    {
        $this-&gt;app-&gt;singleton(&apos;KLog&apos;, function () {
            return new \App\Http\Logic\KLogLogic();
        });
    }
}
</code></pre><p>在register方法中，你唯一要做的事情就是绑事物到服务容器。</p>
<p>既然服务提供者和门面类都已经创建好，那么接下来我们需要进行配置，在<code>config/app.php</code>中进行如下配置：</p>
<p>a. aliases中增加KLog的配置，<br>b. providers中增加KLogProvider</p>
<pre><code>&apos;aliases&apos; =&gt; [
    ...
    &apos;View&apos; =&gt; Illuminate\Support\Facades\View::class,
    &apos;KLog&apos; =&gt; App\Http\Facades\KLog::class,

],
&apos;providers&apos; =&gt; [
    ...
    App\Providers\RouteServiceProvider::class,
    App\Providers\KLogProvider::class,
],
</code></pre><p>当然我们忘了一件重要的事情，那就是KLogLogic类的实现，这才是真正门面KLog调用的底层类。</p>
<pre><code>&lt;?php
namespace App\Http\Logic;

use Monolog\Logger;
use Monolog\Handler\StreamHandler;
use Illuminate\Log\Writer;

class KLogLogic 
{
    private static $writers = null;
    const MAX_FILES = 5; // 最多保留MAX_FILES天的日志

    public function getBizProc()
    {
        return $this-&gt;getLogger(&apos;biz_proc&apos;);
    }

    public function getBizProcErr()
    {
        return $this-&gt;getLogger(&apos;biz_proc_err&apos;);
    }

    private function getLogger($channel_name)
    {
        if (isset(self::$writers[$channel_name])) {
            return self::$writers[$channel_name];
        }

        $new_writer = new Writer(new Logger($channel_name));
        $log_file_path = storage_path() . &apos;/logs/&apos; . $channel_name . &apos;.log&apos;;
        $new_writer-&gt;useDailyFiles($log_file_path, self::MAX_FILES);

        self::$writers[$channel_name] = $new_writer;
        return self::$writers[$channel_name];
    }
}
</code></pre><p>搞定以后，我们如何使用KLog门面呢？很简单，notice和info后面的参数与门面Log一样，因为都是调用的Writer类的接口</p>
<pre><code>use KLog;

KLog::getBizProcErr()-&gt;info($msg);
KLog::getBizProcErr()-&gt;notice($msg);
</code></pre><p>如果要想添加新的日志，那么在KLogLogic中添加新的方法即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/10/03/Laravel中日志类/" data-id="ckw1wzldt0009phnuprqt82yl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Laravel/">Laravel</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux下expect使用教程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/29/Linux下expect使用教程/" class="article-date">
  <time datetime="2016-09-29T02:03:55.000Z" itemprop="datePublished">2016-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/29/Linux下expect使用教程/">Linux下expect使用教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/09/29/Linux下expect使用教程/" data-id="ckw1wzle0000lphnueaqn3335" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-匿名函数与闭包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/21/匿名函数与闭包/" class="article-date">
  <time datetime="2016-09-21T14:36:50.000Z" itemprop="datePublished">2016-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/21/匿名函数与闭包/">匿名函数与闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这篇文章翻译了<a href="http://dhorrigan.com/post/29209695084/anonymous-functions-vs-closures" target="_blank" rel="noopener">Anonymous Functions VS Closures</a></p>
<p>是不是很想知道匿名函数和闭包之间的关系？Lambda呢？这些在PHP中是如何实现的呢？在这个领域有很多困惑，现在让我们来深挖并回答这些问题。</p>
<p>第一件事：<code>Lambda</code>是匿名函数的别称。在一些编程语言（如python）中使用Lambda。</p>
<p>接下来让我们看看匿名函数和闭包到底是什么。如果现在你很困惑，不用担心，接下来我希望能够让你明白，下面是两者的一个简单定义：</p>
<ul>
<li>匿名函数：一个匿名函数是一个定义的偶尔触发的函数，不需要与标识符绑定。（An Anonymous Function is a function that is defined, and occasionally invoked, without being bound to an identifier. It also has the variable scoping characteristics of a Closure (see below)）。</li>
<li>闭包函数：闭包是一个能够捕获当前包含作用域，能够获取父作用域的函数。闭包将非局部变量的引用绑定到了闭包创建时的作用域。（A Closure is a function that captures the current containing scope, then provides access to that scope when the Closure is invoked. The Closure binds non-local variable references to the corresponding variables in scope at the time the Closure is created.）</li>
</ul>
<p>从这儿可以看到：所有的匿名函数都是闭包，但并不是所有的闭包都是匿名函数。</p>
<p>用外行的话来说：</p>
<p>所有的匿名函数都是没有名字的闭包。闭包是一个函数，在闭包定义的时候会将非局部变量绑定为函数的局部变量。（原文：An Anonymous Function is a Closure without a name. A Closure is a function which binds references to non-local variables to local variables inside the function at the time of the Closure definition.）</p>
<h3 id="关于PHP呢？"><a href="#关于PHP呢？" class="headerlink" title="关于PHP呢？"></a>关于PHP呢？</h3><p>事情变得有趣了。在PHP5.3中加入了匿名函数和闭包。但是，有一些取巧的地方（其中一个已经在PHP5.4中修复）</p>
<p>匿名函数的实现是Closure对象。PHP贯彻了观点<code>匿名函数是一个无名的闭包</code>。</p>
<p>有一个简单的匿名函数传递给<code>array_map</code>函数，目的是将所有的整数都乘以2。</p>
<pre><code>$arr = array_map(function ($val) {
return is_int($val) ? $val * 2 : $val;
}, $arr);
</code></pre><p>很简答，对不？现在问一下自己：如果你想在函数内部访问非局部变量（non-local variables）？毕竟匿名函数也是闭包。当然可以，但是你必须清晰告诉PHP使用哪些非局部变量，这是诸多取巧的第一个。现在开始深挖。</p>
<p>####取巧1：<br>当使用非局部变量时，必须使用关键字<code>use</code>将这些非局部变量绑定到闭包的作用域。这与大部分其他语言都不一样。</p>
<pre><code>$foo = &apos;foo&apos;;
$bar = &apos;bar&apos;;

$baz = function () use ($foo, $bar) {
    echo $foo, $bar;
};
</code></pre><p>【译者备注】这儿绑定到闭包的作用域，是将这些非局部变量作为了闭包的静态变量</p>
<p>####取巧2：<br>绑定的非局部变量是复制，而不是引用。如果你想在闭包中改变变量的值，那么你必须使用引用传递。</p>
<pre><code>$foo = &apos;foo&apos;;
$bar = &apos;bar&apos;;

$baz = function () use (&amp;$foo, &amp;$bar) {
    $foo = &apos;Hello &apos;;
    $bar = &apos;World!&apos;;
};
$baz();
echo $foo, $bar; // Outputs &quot;Hello World!&quot;;
</code></pre><p>####取巧3：<br>在PHP5.3中，在类中使用闭包，闭包不能使用<code>$this</code>。你必须传递this的引用，而不能直接传递<code>$this</code>。<br>在PHP5.4中修复，可以直接传递<code>$this</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/09/21/匿名函数与闭包/" data-id="ckw1wzlfw005aphnudnq1i86p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php源码学习/">php源码学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-PHP函数之匿名函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/21/PHP函数之匿名函数/" class="article-date">
  <time datetime="2016-09-21T12:06:54.000Z" itemprop="datePublished">2016-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/21/PHP函数之匿名函数/">PHP函数之匿名函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="匿名函数与闭包的关系"><a href="#匿名函数与闭包的关系" class="headerlink" title="匿名函数与闭包的关系"></a>匿名函数与闭包的关系</h2><p>匿名函数是一类不需要指定指示符，而又可以被调用的函数或子例程，匿名函数可以方便的作为参数传递给其他函数， 最常见应用是作为回调函数。</p>
<p>闭包是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数， 这个被引用的自由变量将和这个函数一同存在，即使离开了创建它的环境也一样，所以闭包也可认为是有函数和与其相关引用组合而成的实体。 </p>
<p>闭包和匿名函数很容易混用，但其实这是两个不同的概念。</p>
<p>当然在PHP中，一个观点就是<code>Anonymous Functions are Closures without a name</code>，即匿名函数是没有名字的闭包。</p>
<h2 id="PHP中匿名函数基本用法"><a href="#PHP中匿名函数基本用法" class="headerlink" title="PHP中匿名函数基本用法"></a>PHP中匿名函数基本用法</h2><p>在PHP中匿名函数(Anonymous functions)也叫作闭包函数(closures)，允许临时创建一个没有指定名称的函数。</p>
<ol>
<li><p>使用use关键字从父作用域继承变量。继承的变量的取值是在函数定义时的值，而不是被调用的时候的值。因此下面的代码输出是<code>hello hello</code>。</p>
<pre><code>&lt;?php
$helo = &apos;hello&apos;;

$func = function() use ($helo) {
    echo $helo . &quot;\n&quot;;
};
$func();

$helo = &apos;world&apos;;
$func();
</code></pre></li>
<li><p>当把use后面的变量改为引用以后，那么就可以改变了，输出 <code>hello world</code></p>
<pre><code>&lt;?php
$helo = &apos;hello&apos;;

$func = function() use (&amp;$helo) {
    echo $helo . &quot;\n&quot;;
};
$func();

$helo = &apos;world&apos;;
$func();
</code></pre></li>
</ol>
<h2 id="PHP中匿名函数"><a href="#PHP中匿名函数" class="headerlink" title="PHP中匿名函数"></a>PHP中匿名函数</h2><h3 id="create-function"><a href="#create-function" class="headerlink" title="create_function"></a>create_function</h3><p>PHP5.3中才开始正式支持匿名函数，在此之前可以通过create_function函数来创建<code>匿名函数</code>。</p>
<p>通过create_function函数创建的<code>匿名函数</code>并不是真的没有名字，而是生成了一个<code>\0lambda_xxx</code>的函数名，并且会在<code>EG(function_table)</code>中注册。因为函数名的第一个字符是<code>\0</code>，这样的函数名用户是不会出现的。</p>
<pre><code>#define LAMBDA_TEMP_FUNCNAME    &quot;__lambda_func&quot;

ZEND_FUNCTION(create_function)
{
    // ... 省去无关代码
    function_name = (char *) emalloc(sizeof(&quot;0lambda_&quot;)+MAX_LENGTH_OF_LONG);
    function_name[0] = &apos;\0&apos;;  // &lt;--- 这里
    do {
        function_name_length = 1 + sprintf(function_name + 1, &quot;lambda_%d&quot;, ++EG(lambda_count));
    } while (zend_hash_add(EG(function_table), function_name, function_name_length+1, &amp;new_function, sizeof(zend_function), NULL)==FAILURE);
    zend_hash_del(EG(function_table), LAMBDA_TEMP_FUNCNAME, sizeof(LAMBDA_TEMP_FUNCNAME));
    RETURN_STRINGL(function_name, function_name_length, 0);
}
</code></pre><p>通过create_function创建<code>匿名函数</code>有一些缺点：</p>
<ol>
<li>函数的定义是通过将函数拼接为一个字符串来处理的。<a href="http://www.laruence.com/2010/06/20/1602.html" target="_blank" rel="noopener">深入理解php之匿名函数解释</a>，这样的话就无法进行基本的语法检查</li>
<li>这种函数与普通函数没有本质区别，无法实现闭包的效果</li>
</ol>
<h3 id="真正的匿名函数"><a href="#真正的匿名函数" class="headerlink" title="真正的匿名函数"></a>真正的匿名函数</h3><ol>
<li><p><code>__invoke</code>魔术方法<br> 这个魔术方法被调用的时机是：当一个对象当做函数调用的时候。通过<code>__invoke</code>方法可以把一个对象当做函数调用。</p>
</li>
<li><p>匿名函数的实现</p>
<p> 匿名函数的实现就是通过<code>__invoke</code>方式实现的。匿名函数是一个普通的类，类名是<a href="http://php.net/manual/zh/class.closure.php" target="_blank" rel="noopener">Closure</a>。</p>
</li>
<li><p>闭包的使用</p>
<p> PHP使用闭包（Closure）来实现匿名函数。匿名函数在定义的时候如果需要使用作用域外的变量需要使用关键字<code>use</code>。</p>
<p> 特别注意的是，在PHP中是通过<code>拷贝</code>的方式将上层变量传入匿名函数的。如果需要改变上层变量的值则需要通过引用的方式传递。</p>
</li>
</ol>
<pre><code>通过下面的代码看一下func的内容

    &lt;?php
    $b = 1;
    $func = function($a) use($b) {
        $b = $b+1;
        echo $b . &quot;\n&quot;;
    };
    var_dump($func);
可以看到

    object(Closure)#1 (2) {
      [&quot;static&quot;]=&gt;
      array(1) {
        [&quot;b&quot;]=&gt;
        int(1)
      }
      [&quot;parameter&quot;]=&gt;
      array(1) {
        [&quot;$a&quot;]=&gt;
        string(10) &quot;&lt;required&gt;&quot;
      }
    }

将代码中的`use ($b)` 改为`use (&amp;$b)`，可以看到输出是：

    object(Closure)#1 (2) {
      [&quot;static&quot;]=&gt;
      array(1) {
        [&quot;b&quot;]=&gt;
        &amp;int(1)
      }
      [&quot;parameter&quot;]=&gt;
      array(1) {
        [&quot;$a&quot;]=&gt;
        string(10) &quot;&lt;required&gt;&quot;
      }
    }
</code></pre><ol start="4">
<li><p>闭包的实现</p>
<p> 匿名函数是通过闭包来实现的，现在我们来看看闭包（类）是怎么实现的。匿名函数和普通函数除了是否有变量名以外并没有区别，闭包的实现代码在<code>Zend/zend_closure.c</code>中。</p>
<p> 使用关键字use引入的父作用域的变量会作为闭包类的静态变量，从上面的var_dump中也可以看出。</p>
<p> 在<code>ZEND_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_CONST_HANDLER</code>中调用<code>zend_create_closure</code>创建一个闭包对象。在<code>zend_create_closure</code>中会将<code>zval_copy_static_var</code>作为回调函数传递给<code>zend_hash_apply_with_arguments</code>。每次读取到hash表中的值以后都会由这个函数进行处理，而这个函数对所有use语句定义的变量值赋值给这个匿名函数的静态变量， 这样匿名函数就能访问到use的变量了。</p>
</li>
</ol>
<p>##参考文章</p>
<ol>
<li><a href="http://dhorrigan.com/post/29209695084/anonymous-functions-vs-closures" target="_blank" rel="noopener">Anonymous Functions VS Closures</a></li>
<li><a href="http://www.php-internals.com/book/?p=chapt04/04-04-anonymous-function" target="_blank" rel="noopener">匿名函数及闭包</a></li>
<li><a href="http://www.laruence.com/2010/06/20/1602.html" target="_blank" rel="noopener">深入理解PHP之匿名函数</a></li>
<li><a href="http://php.net/manual/zh/functions.anonymous.php" target="_blank" rel="noopener">PHP匿名函数基本用法</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/09/21/PHP函数之匿名函数/" data-id="ckw1wzle1000ophnuvx5ti005" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php源码学习/">php源码学习</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Laravel/">Laravel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/composer/">composer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/">cpp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp-lib/">cpp-lib</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/faiss/">faiss</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-source-code/">go.source.code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/laravel/">laravel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/">mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/machine-learning/">machine-learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memcache/">memcache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nosql/">nosql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/octave/">octave</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php源码学习/">php源码学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/">spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tcp/">tcp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thrift/">thrift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础知识/">基础知识</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Laravel/" style="font-size: 10px;">Laravel</a> <a href="/tags/composer/" style="font-size: 10px;">composer</a> <a href="/tags/cpp/" style="font-size: 12.22px;">cpp</a> <a href="/tags/cpp-lib/" style="font-size: 10px;">cpp-lib</a> <a href="/tags/elasticsearch/" style="font-size: 11.11px;">elasticsearch</a> <a href="/tags/faiss/" style="font-size: 10px;">faiss</a> <a href="/tags/git/" style="font-size: 12.22px;">git</a> <a href="/tags/go-source-code/" style="font-size: 10px;">go.source.code</a> <a href="/tags/golang/" style="font-size: 16.67px;">golang</a> <a href="/tags/laravel/" style="font-size: 11.11px;">laravel</a> <a href="/tags/linux/" style="font-size: 14.44px;">linux</a> <a href="/tags/mac/" style="font-size: 13.33px;">mac</a> <a href="/tags/machine-learning/" style="font-size: 10px;">machine-learning</a> <a href="/tags/memcache/" style="font-size: 15.56px;">memcache</a> <a href="/tags/mysql/" style="font-size: 13.33px;">mysql</a> <a href="/tags/nginx/" style="font-size: 13.33px;">nginx</a> <a href="/tags/nosql/" style="font-size: 18.89px;">nosql</a> <a href="/tags/octave/" style="font-size: 10px;">octave</a> <a href="/tags/php/" style="font-size: 20px;">php</a> <a href="/tags/php源码学习/" style="font-size: 17.78px;">php源码学习</a> <a href="/tags/redis/" style="font-size: 12.22px;">redis</a> <a href="/tags/spark/" style="font-size: 12.22px;">spark</a> <a href="/tags/tcp/" style="font-size: 10px;">tcp</a> <a href="/tags/thrift/" style="font-size: 13.33px;">thrift</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/基础知识/" style="font-size: 15.56px;">基础知识</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/11/16/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/11/16/elasticsearch路由规则学习/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/11/16/Spark-DataSource-Hive Tables/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/11/16/Starting Point- SparkSession/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/11/16/RedisCluster详细说明[翻译]/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Keything<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>