<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Keything的日志</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Keything的日志">
<meta property="og:url" content="http://keything.github.io/page/7/index.html">
<meta property="og:site_name" content="Keything的日志">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Keything的日志">
  
    <link rel="alternate" href="/atom.xml" title="Keything的日志" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Keything的日志</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://keything.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-mysql锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/28/mysql锁/" class="article-date">
  <time datetime="2016-07-28T00:52:01.000Z" itemprop="datePublished">2016-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/28/mysql锁/">chapter6:mysql锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="6-1-什么是锁"><a href="#6-1-什么是锁" class="headerlink" title="6.1 什么是锁"></a>6.1 什么是锁</h2><p>锁机制用于管理对共享资源的并发访问</p>
<p>MyISAM引擎的锁是表锁。</p>
<p>InnoDB提供一致性的非锁定读、行级锁支持。行级锁没有相关额外开销，并可以同时得到并发性和一致性</p>
<h2 id="6-2-lock与latch"><a href="#6-2-lock与latch" class="headerlink" title="6.2 lock与latch"></a>6.2 lock与latch</h2><p>一般我们提到的是lock。lock的对象是事务，用来锁定的是数据库中的对象，如表，页，行。并且一般lock的对象只在事务commit和rollback后进行释放（不同隔离级别有所不同）。</p>
<p>latch的目的是用来保证并发线程操作临界资源的正确性，并且没有死锁检测的机制。</p>
<h2 id="6-3-InnoDB存储引擎中的锁"><a href="#6-3-InnoDB存储引擎中的锁" class="headerlink" title="6.3 InnoDB存储引擎中的锁"></a>6.3 InnoDB存储引擎中的锁</h2><h3 id="6-3-1-锁的类型"><a href="#6-3-1-锁的类型" class="headerlink" title="6.3.1 锁的类型"></a>6.3.1 锁的类型</h3><p>InnoDB实现了如下两种标准的行级锁：</p>
<pre><code>1. 共享锁（S Lock）允许事务读一行数据
2. 排他锁（X Lock）允许事务删除或更新一行数据
</code></pre><p>InnoDB支持意向锁，其意向锁即为表级别的锁。</p>
<h3 id="6-3-2-一致性非锁定读-consistent-nonlocking-read"><a href="#6-3-2-一致性非锁定读-consistent-nonlocking-read" class="headerlink" title="6.3.2 一致性非锁定读 consistent nonlocking read"></a>6.3.2 一致性非锁定读 consistent nonlocking read</h3><p>一致性非锁定读指InnoDB存储引擎通过行多版本控制的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此等待行上锁的释放，而是会读取行的一个快照数据。</p>
<p>快照数据是指该行的之前版本的数据，该实现是通过undo段来完成，undo段是用来在事务中回滚数据因此没有额外的开销。</p>
<p>在不同事务隔离级别下，读取方式的不同，并不是在每个事务隔离级别下都是采用非锁定的一致性读。此外，即使都是使用非锁定的一致性读，但是对于快照数据的定义也不相同。</p>
<p>在事务隔离级别READ COMMITTED和REPEATABLE READ下，InnoDB存储引擎使用非锁定的一致性读，但是快照数据定义不相同。在REPEATABLE READ隔离级别下，非一致性锁定读总是读取事务开始时的行数据版本。在READ COMMITTED下，总是读取被锁定行的最新一份快照数据。</p>
<h3 id="6-3-3-锁定读-locking-reads"><a href="#6-3-3-锁定读-locking-reads" class="headerlink" title="6.3.3 锁定读 locking reads"></a>6.3.3 锁定读 <a href="http://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html" target="_blank" rel="noopener">locking reads</a></h3><p>在某些情况下用户需要显式对数据库读取操作进行加锁以保障数据逻辑的一致性。即使对于SELECT的只读操作，也要支持加锁语句。</p>
<p>支持两种一致性的锁定读（locking read)操作：</p>
<pre><code>SELECT .. FOR UPDATE
SELECT .. LOCK IN SHARE MODE
</code></pre><h2 id="6-4-锁的算法"><a href="#6-4-锁的算法" class="headerlink" title="6.4 锁的算法"></a>6.4 锁的算法</h2><h3 id="6-4-1-行锁的3种算法"><a href="#6-4-1-行锁的3种算法" class="headerlink" title="6.4.1 行锁的3种算法"></a>6.4.1 行锁的3种算法</h3><p>InnoDB有3种行锁算法，其分别是：</p>
<pre><code>Record Lock：单个行记录上的锁
Gap Lock：间隙锁，锁定一个范围，但不包含记录本身
Next-Key Lock: Gap Lock + Record Lock 锁定一个范围并且锁定记录本身。
</code></pre><p>在默认隔离级别REPEATABLE READ下，使用的是Next-Key Lock。对于查询的索引含有唯一属性时，InnoDB会将Next-KeyLock进行优化，降级为RecordLock，即仅锁住索引本身，而不是范围。</p>
<p>而对于辅助索引，其加上Next-KeyLock InnoDB存储引擎还会辅助索引下一个键值加上gapLock，即会锁住这个辅助索引附近的两个范围。</p>
<h3 id="6-4-2-解决幻象问题"><a href="#6-4-2-解决幻象问题" class="headerlink" title="6.4.2 解决幻象问题"></a>6.4.2 解决幻象问题</h3><p>幻象是指在同一个事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次SQL可能会返回之前不存在的行。</p>
<p>在REPEATABLE READ下采用Next-key Lock加锁</p>
<p>在READ COMMITTED下 只是采用RecordLock。</p>
<h4 id="通过InnoDB存储引擎的Next-Key-Locking-机制在应用层面实现唯一性检查。"><a href="#通过InnoDB存储引擎的Next-Key-Locking-机制在应用层面实现唯一性检查。" class="headerlink" title="通过InnoDB存储引擎的Next-Key Locking 机制在应用层面实现唯一性检查。"></a>通过InnoDB存储引擎的Next-Key Locking 机制在应用层面实现唯一性检查。</h4><p>一个场景：想查询一下某个id是否存在，如果不存在则插入，如果存在则不插入。两种做法：外部加锁或者通过数据库。</p>
<p>数据库方式：</p>
<pre><code>select * from table where col = xx LOCK IN SHARE MODE;
if not found any row:
    # unique for insert value 需要是唯一索引，不然也存在多条插入的情况
    INSERT INTO table VALUES (...);
</code></pre><h2 id="6-5-锁问题"><a href="#6-5-锁问题" class="headerlink" title="6.5 锁问题"></a>6.5 <a href="http://keything.github.io/2016/01/09/mysql-%E9%94%81%E7%9A%84%E9%97%AE%E9%A2%98/">锁问题</a></h2><h3 id="6-5-1-脏读"><a href="#6-5-1-脏读" class="headerlink" title="6.5.1 脏读"></a>6.5.1 脏读</h3><p>脏读：指的是在不同事务下，当前事务可以读到另外事务未提交的数据</p>
<h3 id="6-5-2-不可重复读"><a href="#6-5-2-不可重复读" class="headerlink" title="6.5.2 不可重复读"></a>6.5.2 不可重复读</h3><p>不可重复读：指的是在一个事务内两次读到的数据不一样，多了或者少了数据。</p>
<h3 id="6-5-3-丢失更新"><a href="#6-5-3-丢失更新" class="headerlink" title="6.5.3 丢失更新"></a>6.5.3 丢失更新</h3><p>丢失更新：简单来说，就是一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据的不一致。<br>解决方法：让事务在这种情况下的操作变成串行化。比如使用select … FOR UPDATE.</p>
<h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><p>多版本技术：一个行记录可能有不止一个快照数据，称之为行多版本技术。</p>
<p>由此带来的并发控制，称之为多版本并发控制 multi version concurrency controll mvcc。</p>
<h2 id="6-6-参考文章"><a href="#6-6-参考文章" class="headerlink" title="6.6 参考文章"></a>6.6 参考文章</h2><ol>
<li><a href="http://dev.mysql.com/doc/refman/5.7/en/innodb-locking-transaction-model.html" target="_blank" rel="noopener">15.5 InnoDBlocking and Transaction Model</a></li>
<li>姜承尧 InnoDB存储引擎第二版 6.锁</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/07/28/mysql锁/" data-id="ckw1x704p003u5enuxnpwk0rg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis与Memcache作为缓存时的比较" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/16/Redis与Memcache作为缓存时的比较/" class="article-date">
  <time datetime="2016-07-16T10:16:56.000Z" itemprop="datePublished">2016-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/16/Redis与Memcache作为缓存时的比较/">Redis与memcache作为缓存时的比较</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【说明一个大前提】我觉得拿Redis跟Memcache比较时，是把Redis当做缓存来用。不然一个是缓存一个是持久化，那么比较就失去意义了。</p>
<p>【本文目的】这篇文章是总结了大牛们关于Redis和Memcache的论断，加上部分自己的理解。</p>
<h3 id="1-Redis的性能比Memcache好。"><a href="#1-Redis的性能比Memcache好。" class="headerlink" title="1. Redis的性能比Memcache好。"></a>1. Redis的性能比Memcache好。</h3><p>Redis的QPS能够达到10w [数据来源]</p>
<p>Memcache的QPS在6w [数据来源 </p>
<h4 id="数据来源："><a href="#数据来源：" class="headerlink" title="数据来源："></a>数据来源：</h4><p><a href="http://antirez.com/news/94" target="_blank" rel="noopener">redis作者的声明</a></p>
<p><a href="http://timyang.net/data/mcdb-tt-redis" target="_blank" rel="noopener">memcache,redis性能测试</a></p>
<p>自己测试的话Redis选择<a href="http://redis.io/topics/benchmarks" target="_blank" rel="noopener">RedisBenchmark</a>，Memcache可以使用<a href="https://github.com/twitter/twemperf" target="_blank" rel="noopener">mcperf</a></p>
<h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><ol>
<li>Redis没有使用libevent作为事件处理函数库，而是自己造轮子。libevent因为通用牺牲了不少性能，没有epoll性能好<a href="http://rdc.gleasy.com/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%89%E5%9E%8B%E6%AF%94%E8%BE%83epolllibeventjava-mina2.html" target="_blank" rel="noopener">参考</a></li>
</ol>
<ol start="2">
<li>cas问题：CAS是Memcached中比较方便的一种防止竞争修改资源的方法。CAS实现需要为每个cache key设置一个隐藏的cas token，cas相当value版本号，每次set会token需要递增，因此带来CPU和内存的双重开销，虽然这些开销很小，但是到单机10G+ cache以及QPS上万之后这些开销就会给双方相对带来一些细微性能差别。</li>
</ol>
<h3 id="2-更多元化的方式使用Redis"><a href="#2-更多元化的方式使用Redis" class="headerlink" title="2. 更多元化的方式使用Redis"></a>2. 更多元化的方式使用Redis</h3><p>除了key/value的形式来使用Redis，还可以使用hash等数据形式。使用Hash更加节约空间。<a href="http://blog.nosqlfan.com/html/3379.html" target="_blank" rel="noopener">实践</a> <a href="http://redis.io/topics/memory-optimization" target="_blank" rel="noopener">理论</a></p>
<h3 id="3-Redis的内存效率更高"><a href="#3-Redis的内存效率更高" class="headerlink" title="3. Redis的内存效率更高"></a>3. Redis的内存效率更高</h3><p>   Redis中特殊编码的小型聚合值内存效率非常高<a href="http://redis.io/topics/memory-optimization" target="_blank" rel="noopener">内存优化</a></p>
<p>   真正的内存效率必须基于手头的应用案例来评估</p>
<h3 id="4-Redis禁用磁盘IO，纯内存操作"><a href="#4-Redis禁用磁盘IO，纯内存操作" class="headerlink" title="4. Redis禁用磁盘IO，纯内存操作"></a>4. Redis禁用磁盘IO，纯内存操作</h3><p>有一种论断是说 Memcached根本没有磁盘IO操作。实际上Redis禁用磁盘IO操作以后，也是纯内存操作。</p>
<h3 id="5-作为缓存时，redis-LRU-vs-Slab内存分配器"><a href="#5-作为缓存时，redis-LRU-vs-Slab内存分配器" class="headerlink" title="5. 作为缓存时，redis LRU vs Slab内存分配器"></a>5. 作为缓存时，redis LRU vs Slab内存分配器</h3><p>redis的LRU最近优化了很多，现在非常接近真正的LRU。进一步的信息可阅读： <a href="http://redis.io/topics/lru-cache" target="_blank" rel="noopener">lru-cache</a> 。如果我没理解错的话，Memcached的LRU依旧是根据它的slab分配器来判断数据过期的，因此有时其行为与真正的LRU相差甚远，但我希望这方面的专家能够针对这个问题说点什么。如果你想测试Redis的LRU，在最近几个版本的Redis中可以使用redis-cli的LRU测试模式</p>
<h3 id="6-Memcache的多线程对比Redis的单线程"><a href="#6-Memcache的多线程对比Redis的单线程" class="headerlink" title="6. Memcache的多线程对比Redis的单线程"></a>6. Memcache的多线程对比Redis的单线程</h3><p>Memcache是多线程的，在多核上能线性扩展到每秒处理100,000个请求。</p>
<p>如果我们将特殊用例下的Redis看做是Memcached的替代品，执行多个Redis进程也能反驳“Memcached多线程更好”这个观点，或者简单地执行一个Redis进程也行。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://timyang.net/data/redis-misunderstanding/" target="_blank" rel="noopener">Redis几点认识误区</a></p>
<p><a href="http://www.tuicool.com/wx/bmQFNjm" target="_blank" rel="noopener">关于Redis和Memcache的几点澄清</a></p>
<p><a href="http://redis.io/topics/memory-optimization" target="_blank" rel="noopener">redis内存优化</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/07/16/Redis与Memcache作为缓存时的比较/" data-id="ckw1x703o00145enu1ph6e5t3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nosql/">nosql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-缓存替换" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/12/缓存替换/" class="article-date">
  <time datetime="2016-07-12T01:39:14.000Z" itemprop="datePublished">2016-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/12/缓存替换/">缓存替换</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="零-概述"><a href="#零-概述" class="headerlink" title="零 概述"></a>零 概述</h1><p>在业务中不可避免的需要使用缓存，当缓存数据很少时，只需要几台缓存服务器即可满足需求。 但是当业务增多时，就需要N个业务M个缓存服务器。缓存服务器不管使用memcache还是redis，都是需要业务方来管理缓存服务器的host和port。</p>
<p>我们业务中使用的memcache服务器接近千台，还需要业务方告知相关人员来处理memcache的问题（memcache机器宕机或者连接数打满）。而实际上，对于我们业务方而言，只需要使用缓存服务器即可，业务方不需要关注缓存服务器的重启和健康检查。当然了，业务方还是需要关注访问缓存服务器的访问时间。</p>
<h2 id="一-我们对缓存服务的要求"><a href="#一-我们对缓存服务的要求" class="headerlink" title="一 我们对缓存服务的要求"></a>一 我们对缓存服务的要求</h2><ol>
<li>单个请求耗时在2ms以内</li>
<li>能够抗住30w qps的压力</li>
</ol>
<h2 id="二-我们的尝试"><a href="#二-我们的尝试" class="headerlink" title="二 我们的尝试"></a>二 我们的尝试</h2><h3 id="I-首先尝试twitter的twemproxy"><a href="#I-首先尝试twitter的twemproxy" class="headerlink" title="I. 首先尝试twitter的twemproxy"></a>I. 首先尝试twitter的twemproxy</h3><ol>
<li><p>Twemproxy介绍</p>
<p> Twemproxy是一个使用C语言编写、以代理的方式实现的、轻量级的代理服务器，通过引入一个代理层，将应用程序后端的多台Redis实例进行统一管理，使应用程序只需要在Twemproxy上进行操作，而不用关心后面具体有多少个真实的Redis或Memcached实例，从而实现了基于Redis和Memcached的集群服务。当某个节点宕掉时，Twemproxy可以自动将它从集群中剔除，而当它恢复服务时，Twemproxy也会自动连接。<br> Twemproxy的缺点：1. 无法平滑地扩容/缩容， 2. 运维不友好，没有控制面板（对于业务方而言，这个不是问题）3. 经过一层代理，对性能有损耗。</p>
</li>
</ol>
<ol start="2">
<li><p>我们测试的结果</p>
<p> a. 压测方式一：</p>
<p> 使用twitter自家的<a href="https://github.com/twitter/twemperf" target="_blank" rel="noopener">mcperf</a>压测工具来压测twemproxy。</p>
<p> 压测命令：</p>
<pre><code>/bin/mcperf --timeout=0.2 --conn-rate=1000 --call-rate=5000000 --num-calls=1000 --num-conns=100 --sizes=u32,1024 -s 10.10.10.10 -p 11211
</code></pre><p> 压测结果：</p>
<p> |case| 直连memcache|连接twemproxy|<br> |—|—|—|<br> |数据在32字节和1k字节之间|57750 qps, 耗时100ms以内|25589 qps，耗时100ms以上非常多|<br> |数据在4k和8k字节之间|18156 qps | 12376 qps|</p>
<p> b. 压测方式二：使用n个php进程压测，这种压测方法并不能够得到一个<code>mcperf</code>的准确的qps，但是更接近我们的应用场景，也能够看出一些问题。这种方式压测中发现的问题：</p>
<p> 1) twemproxy所在机器TIME_WAIT和CLOSE_WAIT非常高<br> 2) 单次请求耗时增加，连接twemproxy的qps小于直连memcache</p>
<p> <code>TIME_WAIT</code>及<code>CLOSE_WAIT</code>非常高的原因：</p>
<p>  php端设置超时时间是100ms，即server端100ms内没有响应时，php端就会主动断开连接。上面提到mcperf压测时超过100ms的请求非常多，那么100ms没有收到响应时php段就会主动断开连接。由于twemproxy服务器过于繁忙，没有调用close从而导致twemproxy处于<code>CLOSE_WAIT</code>状态。</p>
<p> 对于<code>TIME_WAIT</code>而言，则是twemproxy向memcache服务器发送请求，等待某个时间（twemproxy中设置），如果没有响应，twemproxy就会主动断开连接；当大量从twemproxy到达memcache的请求超时时，就会出现<code>TIME_WAIT</code>过多。</p>
</li>
</ol>
<h3 id="II-可以考虑方案"><a href="#II-可以考虑方案" class="headerlink" title="II 可以考虑方案"></a>II 可以考虑方案</h3><p>我们将可以考虑的方案列一下，360的bada，360的<a href="https://github.com/Qihoo360/pika" target="_blank" rel="noopener">pika</a>，豌豆荚的<a href="https://github.com/CodisLabs/codis" target="_blank" rel="noopener">codis</a>。 </p>
<p>先来说一下豌豆荚的codis，它跟twemproxy一样都是经过一层代理，首先经过一层代理必然会造成一定的性能损耗，其次在内存拷贝上codis并没有进行优化，官方开发者spinlock在<a href="https://github.com/CodisLabs/codis/issues/309" target="_blank" rel="noopener">答疑</a>中提到:a. <code>twemproxy只有redis性能一半</code>, b. <code>codis比twemproxy慢</code>。</p>
<p>也就是说，不管是twemproxy还是codis，这种经过一层代理的方式都会造成一定的性能损耗；并且在高并发的情况下，代理会带来更多的问题；综合考虑，我们不使用这种代理的方式</p>
<p>再来说一下公司的pika，数据存在硬盘并且底层是rocksdb，单个请求和并发都不满足需求。</p>
<p>再来说一下公司的bada，qps在10w以上，但是平均耗时比redis多。</p>
<p>综合考虑，我们决定测试一下RedisCluster，看是否满足我们的需求。</p>
<h3 id="III-RedisCluster"><a href="#III-RedisCluster" class="headerlink" title="III RedisCluster"></a>III RedisCluster</h3><ol>
<li>压测环境<br>Redis3.0.5版的<a href="https://github.com/antirez/redis/issues/2191" target="_blank" rel="noopener">Redis-benchmark并不支持对RedisCluster的压力测试</a>。看了一下常见的压测工具都没有直接对RedisCluster进行压测的工具。没有办法，只好使用25台测试机，单机进程总数，每个进程请求数量10w个，通过日志记录每个请求的耗时时间，对日志进行分析。</li>
<li><p>qps粗略计算</p>
<p> 采用php直接压测，qps的粗略计算：</p>
<pre><code>机器数*每台机器的php进程数*1000（1s=1000ms)/ 单个请求耗时（单位ms）
</code></pre><p> 如果单次请求是5ms，则预计是<code>25*5*1000/5=2.5w</code></p>
<p> 当然还可以通过redis-trib.rb得到，将数字部分累加即可。</p>
<pre><code>$./redis-trib.rb call 10.138.113.202:16001 info | grep -iE &quot;instantaneous_ops_per_sec&quot;

instantaneous_ops_per_sec:3963
instantaneous_ops_per_sec:3842
instantaneous_ops_per_sec:4219
instantaneous_ops_per_sec:3590 
</code></pre><p> 对RedisCluster，Memcache，Redis进行压力测试，主要是测试在高并发情况下三者的耗时。耗时位于0-5ms的比例Redis好于Memcache好于Cluster。解释：</p>
<p> 因为RedisCluster在创建对象的时候需要发送<code>cluster slots</code>命令获取一次集群的节点信息，导致耗时比redis和memcache要久。当然这也是其比memcache明智的地方， 因为memcache需要业务方维护一份节点信息，一旦需要更换节点，则需要业务方进行更改；而cluster的节点信息是由cluster的管理员维护。</p>
<p> 对于单个http请求而言，与memcache和Redis相比，只是多了获取节点信息的操作</p>
</li>
<li><p>压测中发现<a href="https://github.com/phpredis/phpredis" target="_blank" rel="noopener">phpredis驱动</a>的一个问题：</p>
<p> 压测过程中发现单个redis-cluster节点接受cluster-slots命令是4000qps.（该命令获取集群节点映射信息），当大于4000qps时，耗时就会急剧增加。</p>
<p> 对于这个问题，可以通过增加cluster节点来解决。</p>
<p> 当然最好的方法是修改phpredis的cluster驱动，能够缓存cluster节点信息，不用每次创建对象的时候都发送clusterslots命令</p>
</li>
</ol>
<h2 id="我们最后的选择"><a href="#我们最后的选择" class="headerlink" title="我们最后的选择"></a>我们最后的选择</h2><ol>
<li><p>基于上面的压测，我们决定使用RedisCluster，原因有二：</p>
<p> a. 对于单个http请求（里面可能有多个缓存操作）而言，相比直连memcache或者redis，只是多了一步获取节点信息的耗时，耗时在2ms左右，这点性能损耗我们是可以忍受的。</p>
<p> b. 对于DBA而言，维护简单，扩容方便；对于业务方而言，我只需要获取RedisCluster的一个节点进行连接即可，跟使用普通Redis差别不大。 </p>
</li>
<li><p>使用RedisCluster中存在的问题</p>
<p> 前端机连接RedisCluster使用短连接，因此造成前端机TIMEWAIT过高，从而导致大量的连接超时。这儿要说明两个问题，第一个是为何使用短连接，因为使用长连接的话就不会存在TIMEWAIT过高的问题。第二个是TIMEWAIT过高的解决方式。</p>
<p> 问题1：使用短连接而不使用长连接</p>
<p> 原因是：使用长连接可能造成前端机或cluster机器端口不够用</p>
<p> 先确定采用长连接时Cluster服务器连接数的计算方式：<code>前端机数量*每台前端机fpm进程数量</code>。如果前端机数量非常多，比如300台，每台前端机fpm128个，那么与某台cluster建立的长连接数量是38400，会造成cluster上连接数过多。<br> 而对于前端机而言，则可能会造成端口不够用。端口范围由net.ipv4.ip_local_port_range决定）。<br> 为了避免出现这个问题，我们使用短连接而不是长连接</p>
<p> 问题2：TIMEWAIT</p>
<p> TIMEWAIT出现原因：发送方主动断开连接时，收到接收方发来的FIN以后处于的状态，这是TCP四次挥手的正常状态。但是由于TIMEWAIT状态时，连接依然占有端口和fd，因此可能会出现端口不够用或套接字不够用的情况，从而导致连接失败。<br> TIMEWAIT解决方法：我们采用的是修改net.ipv4.tcp_max_tw_buckets = 5000。</p>
</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/CodisLabs/codis/issues/309" target="_blank" rel="noopener">codis, redis, twemproxy对比</a></p>
<p><a href="http://chuansong.me/n/1271889" target="_blank" rel="noopener">redis cluster浅析与bada对比</a></p>
<p><a href="http://www.infoq.com/cn/articles/effective-ops-part-03" target="_blank" rel="noopener">Redis集群技术及Codis实践</a></p>
<p><a href="https://github.com/phpredis/phpredis/blob/develop/README.markdown" target="_blank" rel="noopener">PhpRedis集群介绍</a></p>
<p><a href="https://github.com/antirez/redis/issues/2191" target="_blank" rel="noopener">redis-benchmark cannot work on Redis Cluster</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/07/12/缓存替换/" data-id="ckw1x705a005f5enuzj9mlk4x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nosql/">nosql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-内核参数-tcp-syncookies" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/09/内核参数-tcp-syncookies/" class="article-date">
  <time datetime="2016-07-09T13:05:09.000Z" itemprop="datePublished">2016-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/09/内核参数-tcp-syncookies/">内核参数 tcp_syncookies-- 默认开启tcp_syncookies</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>提问：<br>基于下面的信息，是否可以默认开启<code>/proc/sys/net/ipv4/tcp_syncookies</code>。缺点呢？</p>
<p>一种流行的服务攻击是给你的服务器发送许多（可能伪造的）的SYN包，但从不通过三次握手完成TCP请求。这样很快用尽内核中半打开队列（unp中叫 incompelete connection queue), 阻止了合法连接的完成。因为一个连接不需要完成，那么被攻击机器上就不需要资源，那么这就很容易处理和维护了。</p>
<p>如果设置了<code>tcp_syncookies</code>变量（需要内核使用<code>CONFIG_SYNCOOKIES</code>编译），那么在队列满的时候，内核也能够处理TCP SYN包了，这就是SYN cookie功能的关键所在。</p>
<p>SYN cookie完全不使用SYN队列就能工作。正常的情况，内核会发送SYN|ACK作为对SYN包的响应，但是，SYN cookie是发送一个特定的TCP 序号，这个序号是对<code>源地址</code>，<code>目的地址</code>，<code>源端口</code>，<code>目的端口</code>和<code>发送包的时间</code>的编码。一个执行SYN 洪水的攻击者拿不到这个包，也就没法响应。一个合法的连接将会包含这个序号来发送三次握手中的第三个包，服务器将会确认这个包是对合法SYN cookie的响应，并允许建立连接，即使在SYN队列中没有对应的位置了。</p>
<p>开启SYN cookie是一种抵御SYN洪水攻击的简单方式，只是多了一点建立cookie和确认cookie的CPU时间。相比拒绝所有到来的连接，开始SYNcookie是一种明智的选择。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.redhat.com/archives/rhl-devel-list/2005-January/msg00447.html" target="_blank" rel="noopener">https://www.redhat.com/archives/rhl-devel-list/2005-January/msg00447.html</a><br><a href="https://ckdake.com/content/2007/disadvantages-of-tcp-syn-cookies.html" target="_blank" rel="noopener">https://ckdake.com/content/2007/disadvantages-of-tcp-syn-cookies.html</a><br><a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">http://coolshell.cn/articles/11564.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/07/09/内核参数-tcp-syncookies/" data-id="ckw1x705600535enuhsdvgs7e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tcp/">tcp</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-php的memcache客户端的几点说明" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/03/php的memcache客户端的几点说明/" class="article-date">
  <time datetime="2016-07-03T12:55:17.000Z" itemprop="datePublished">2016-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/03/php的memcache客户端的几点说明/">php的memcache客户端的几点说明</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一-超时时间"><a href="#一-超时时间" class="headerlink" title="一. 超时时间"></a>一. 超时时间</h2><ol>
<li><p>对于php的memcache客户端，当客户端认为memcached服务器端超时的时候，客户端会主动断开与memcached服务器之间的连接。</p>
</li>
<li><p>对于php的mecache客户端，这个超时时间并不是最低只能是1秒。<a href="http://php.net/manual/zh/memcache.addserver.php" target="_blank" rel="noopener">http://php.net/manual/zh/memcache.addserver.php</a> 中写到timeout的单位是秒，默认是1秒。可是我们可以通过修改变量来调整超时时间。 【<a href="http://tech.uc.cn/?p=326" target="_blank" rel="noopener">http://tech.uc.cn/?p=326</a> 文章中的关于超时时间的论断是错误的】</p>
<pre><code>ini_set(&quot;memcache.default_timeout_ms&quot;, 1000);
</code></pre></li>
</ol>
<h2 id="二-失败重连机制"><a href="#二-失败重连机制" class="headerlink" title="二. 失败重连机制"></a>二. 失败重连机制</h2><p>先提出两个问题，第一个问题：</p>
<pre><code>有n个memcache服务器的时候，某一个server失败了，
那么还会重试下一个server么？
哪些操作会重试下一个server？
</code></pre><p>第二个问题：</p>
<pre><code>当n个server都失败的时候，
会影响到之后的其他操作么？
</code></pre><p>这两个问题，稍后会给出详细的解释。</p>
<h2 id="三-实践前基础知识"><a href="#三-实践前基础知识" class="headerlink" title="三. 实践前基础知识"></a>三. 实践前基础知识</h2><ol>
<li>tc命令控制网络延时</li>
</ol>
<pre><code> tc qdisc add dev eth0 root netem delay 100ms 所有请求都延时100ms

tc qdisc del dev eth0 root netem delay 100ms 删除所有请求都延时100ms的限制
</code></pre><ol start="2">
<li><p>实践的php代码</p>
<p> 有两台memcache服务器，分别是10.16.57.128和10.16.57.191. </p>
<pre><code>// test_mc.php
&lt;?php
function catchErrHandler($level, $msg, $file, $line)
{
    switch ($level)
    {
    case E_NOTICE:
        $hhh = __METHOD__.__LINE__.&apos;|pid=&apos;.getmypid().&apos;notice&apos;.&apos;|msg=&apos;.$msg.microtime(true).&quot;\n&quot;;
        echo $hhh;
        error_log($hhh,3,&apos;/tmp/yk.log&apos;);
        //exit;
        break;
    default:
        error_log(&apos;default&apos;.__METHOD__.__LINE__.&apos;|pid=&apos;.getmypid().&apos;notice&apos;.&apos;|msg=&apos;.$msg.microtime(true).&quot;\n&quot;,3,&apos;/tmp/yk.log&apos;);
        break;
    }
}
ini_set(&quot;memcache.default_timeout_ms&quot;, 99);
ini_set(&apos;memcache.allow_failover&apos;, 1);
set_error_handler(&apos;catchErrHandler&apos;);
$mcobj = new Memcache();
$mcobj-&gt;addServer(&apos;10.16.57.191&apos;, 11211);
$mcobj-&gt;addServer(&apos;10.16.57.128&apos;, 11211);
$pid = getmypid();
$max_qid = 1;
for ($qid = 0; $qid &lt; $max_qid; $qid++)
{
    $start = microtime(true);
    $key = &apos;task_lock&apos; . $qid;
    echo $key . &quot;\n&quot;;
    $value = $mcobj-&gt;set($key, 1, 300);
    $end = microtime(true);
    $consume = $end - $start;
}
</code></pre></li>
</ol>
<h2 id="四-实践"><a href="#四-实践" class="headerlink" title="四. 实践"></a>四. 实践</h2><ol>
<li><p>当一个server失败了，会尝试下一个server么？</p>
<p> memcache客户端关于重试failover有两个设置：</p>
<pre><code>memcache.allow_failover boolean 是否在发生错误时（对用户）透明的转移到其他服务器。
memcache.max_failover_attempts integer 定义在写入和获取数据时最多尝试的服务器次数（即：故障转移最大尝试数），仅和 memcache.allow_failover结合使用。
</code></pre><p> 如果设置 <code>ini_set(&#39;memcache.allow_failover&#39;, 1);</code>那么会重试下一个server。</p>
</li>
<li><p>哪些操作会去重试下一个呢？</p>
<p> 从源码来看，php的memcache客户端发送<code>set/add/replace</code>指令的时候会先判断server可用不，如果不可用则走failover，如果只有一台memcache服务器，那么这个逻辑就忽略。<br>因为server不可用，那么在之后的逻辑就不会发送请求。</p>
<p> 从实践来看，<code>get</code>操作也会走failover，这也就是 <a href="http://tech.uc.cn/?p=326" target="_blank" rel="noopener">http://tech.uc.cn/?p=326</a> 文章中提到的memcache的分布式问题。</p>
<p> 实践步骤：</p>
<p> a. 两台memcache机器，10.16.57.128，10.16.57.191。<br> 10.16.57.191这台机器延时100ms 命令：<code>sudo tc qdisc add dev eth0 root netem delay 100ms</code>。</p>
<p> b. 执行test_mc.php代码</p>
<p> 通过wireshark抓包可以看到，10.16.57.191在三次握手的时候，客户端直接发了RST。然后failover，跟10.16.57.128进行三次握手，之后发送set请求，memcache服务器对其进行处理并返回STORED。add, replace, get操作也是一样的会进行failover。</p>
<p> <img src="/images/php_memcache/set.png" alt="set"><br> <img src="/images/php_memcache/replace.png" alt="replace"><br> <img src="/images/php_memcache/get.png" alt="get"></p>
</li>
</ol>
<ol start="3">
<li><p>当两个memcache服务器都失败的时候呢？？</p>
<p> retry_interval是服务器连接失败时重试的间隔时间，默认值15秒。一旦一个连接失败，他将会被成功重新连接，或者被标记为失败连接并等待retry_interval秒后再践行一次重连。即，当memcache客户端将server的连接标识为失败以后，在retry_interval时间内都不会再次建立连接，而是直接返回false。</p>
<p> 实践步骤：</p>
<p> a. 两台memcache机器， 10.16.57.128，10.16.57.191。<br> 10.16.57.191和10.16.57.128两台机器延时100ms 命令：<code>sudo tc qdisc add dev eth0 root netem delay 100ms</code>。</p>
<p> b. 执行test_mc.php代码</p>
<p> 通过wireshark抓包可以看到，客户端分别对两个memcache服务器发送RST，之后并没有请求再发出，而是直接返回了false</p>
<p> <img src="/images/php_memcache/all_failed.png" alt="不会进行重试"></p>
</li>
</ol>
<h2 id="五-连接twemproxy和连接memcache"><a href="#五-连接twemproxy和连接memcache" class="headerlink" title="五. 连接twemproxy和连接memcache"></a>五. 连接twemproxy和连接memcache</h2><p>连接twemproxy和直接连接memcache时的failover情况：</p>
<ol>
<li><p>php直连memcache时</p>
<p> 三次握手时间超过设置的超时时间，使用pconnect、addserver和connect三种方式都能准确failover</p>
<p> 即直连memcache时，长短连接都能够准确failover。</p>
</li>
<li><p>php连接twemproxy时，</p>
</li>
</ol>
<p>如果只有一台twemproxy（或者通过lvs连接twemproxy集群），即addServer的时候只有一个ip:port，那么不会走failover。</p>
<p>a. PHP设定的timeout 大于 twemproxy的timeout，memcache故障实体机可以及时剔除，connect不出现false，但是pconnect和addserver进程队列里的将继续false很久后才恢复到true；原因：</p>
<pre><code>虽然twemproxy已经剔除故障机，但是只有一个ip:port, 对于php的memcache客户端而言，他就认为这个ip:port的连接不可用，那么需要在retry_interval时间以后才会发送请求。

对于短连接connect而言，则是新建连接，则不存在这个问题。
</code></pre><p>b. PHP设定的timeout &lt; twemproxy的timeout，mc故障实体机不一定及时剔除，pconnect、addserver和connect都将继续false很久后才恢复到true。</p>
<h2 id="六-出现问题"><a href="#六-出现问题" class="headerlink" title="六. 出现问题"></a>六. 出现问题</h2><ol>
<li><p>当切换到twemproxy的时候，发现大量的key写入失败，原因是前端机（跑着php的memcache客户端的机器）的TIME_WAIT非常高，twemproxy机器的TIME_WAIT和CLOSE_WAIT都非常高。</p>
</li>
<li><p>twemproxy机器的TIME_WAIT达到18W， CLOSE_WAIT（被动关闭）也非常高。</p>
<p> TIME_WAIT高的原因是，twemproxy没有收到memcache服务器的响应，主动断开连接。<br>CLOSE_WAIT高的原因是，php的memcache客户端没有收到twemproxy服务器的响应，断开连接，造成twemproxy服务器的CLOSE_WAIT过高， 就是客户端主动关闭，服务器端没有快速响应，因此处于CLOSE_WAIT。</p>
</li>
</ol>
<h2 id="七-解决方案"><a href="#七-解决方案" class="headerlink" title="七. 解决方案"></a>七. 解决方案</h2><ol>
<li><p>调整内核参数解决TIME_WAIT过高的问题</p>
<pre><code>net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_tw_recycle = 0
net.ipv4.tcp_max_tw_buckets = 5000
</code></pre></li>
<li><p>CLOSE_WAIT过高的问题，没有解决</p>
</li>
<li><p>对于twemproxy，可能是我们的使用方式有问题，在使用的过程中出现了twemproxy机器的TIME_WAIT和CLOSE_WAIT都过高，影响服务，因此我们没有使用twemproxy。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/07/03/php的memcache客户端的几点说明/" data-id="ckw1x704z004g5enuq74z2ufd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nosql/">nosql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Index-Condition-Pushdown-优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/26/Index-Condition-Pushdown-优化/" class="article-date">
  <time datetime="2016-06-26T00:24:56.000Z" itemprop="datePublished">2016-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/26/Index-Condition-Pushdown-优化/">Index Condition Pushdown 优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Index Condition Pushdown是一种优化，针对的是使用索引去表中获取记录rows的优化。没有ICP的话，存储引擎遍历索引来定位数据表中的记录（rows），并将其返回给Mysql的server层，在server层对所获取的记录进行WHERE条件的过滤。<br>开启ICP后，如果WHERE条件中的某些字段刚好是索引中的字段，那么Mysql的server层会将这些字段下放到存储引擎，存储引擎会使用这些WHERE条件进行过滤，只有满足这些字段的条件，存储引擎才会去数据表中读取整行记录。</p>
<p>ICP的优点就是：减少了存储引擎到达数据表的次数，以及MySQL server层到达存储引擎的次数。</p>
<p>能够使用ICP优化的索引：range，ref， eq_ref和ref_or_null。这些索引都需要获取全表的记录。<br>能够使用ICP优化的引擎：InnoDB和MyISAM。注意 在MySQL5.6的分区表中不支持，MySQL5.7中支持。<br>注意：只支持辅助索引。因为ICP优化的目标：减少读取整行的次数，从而降低了IO操作。对于InnoDB的聚簇索引，已经读取了整行记录，因此使用ICP并不会降低IO。</p>
<p>优化器没有使用ICP时，数据访问和提取的过程如下：</p>
<pre><code>1) 当storage engine读取下一行时，首先读取一个索引，然后使用索引在数据表中定位和读取整行数据。
2) sever层评估where条件，如果该行数据满足where条件则使用，否则丢弃。
3) 执行1），直到最后一行数据。
</code></pre><p><img src="/images/no_icp.png" alt="no-icp"></p>
<p>优化器使用ICP时，server层会将WHERE条件中某些字段（这些字段在索引中）下推到storage engine层。数据访问和提取过程如下：</p>
<pre><code>1) storage engine从索引中读取下一条索引。
2) storage engine使用索引评估下推的索引条件。如果没有满足wehere条件，则回到1）。只有当索引满足下推的索引条件的时候，才会继续去数据表中读取数据。
3) 如果满足WHERE的索引条件，storage engine通过索引定位数据表的行和读取整行数据并返回给server层。
4) server层评估没有被下推到storage engine层的where条件，如果该行数据满足where条件则使用，否则丢弃。
</code></pre><p><img src="/images/icp.png" alt="icp"></p>
<p>举例来说明：一个表中包含一个人和其地址信息，表中有一个索引(zipcode, lastname, firstname)。如果我们知道一个人的zipcode，但不确定其lastname，因此可以像下面一样进行查询</p>
<pre><code>SELECT * FROM peope WHERE zipcode = &apos;95054&apos; 
AND lastname LIKE &apos;%etrunica%&apos;
AND address LIKE &apos;%Main Street%&apos;;
</code></pre><p>zipcode = ‘95054’可以使用索引，但是第二部分lastname LIKE ‘%etrunica%’，不使用ICP时不能限制需要扫描的记录的行数，需要获取所有满足zipcode = ‘95054’的所有用户记录。</p>
<p>如果使用ICP，在去数据表读取整行记录之前，MYSQL会检查lastname LIKE ‘%etrunica%’部分。这样避免了去读取不满足lastname 这个条件的数据记录。</p>
<p>默认ICP是开启的。可以通过index_condition_pushdown来设置。</p>
<pre><code>set optimizer_switch=&apos;index_condition_pushdown=off&apos;;
</code></pre><p>特别注意：</p>
<ol>
<li>ICP只能用于二级索引，不能用于主索引</li>
<li>也不是全部where条件都可以用ICP筛选，如果某where条件的字段不在索引中，当然还是要读取整条记录做筛选，在这种情况下，仍然要到server端做where筛选。</li>
<li>ICP的加速效果取决于在存储引擎内通过ICP筛选掉的数据的比例</li>
<li>概括之：对于完全命中索引的查询，不需要ICP。比如索引是idx_abc(a,b,c)。查询是where a = 1 and b = 2 则不需要ICP。如果查询是 where a = 1 and b &gt; 3 则会使用ICP.</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="http://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html</a></li>
<li><a href="http://ourmysql.com/archives/1351" target="_blank" rel="noopener">http://ourmysql.com/archives/1351</a></li>
<li><a href="http://mdba.cn/?p=315" target="_blank" rel="noopener">http://mdba.cn/?p=315</a></li>
<li><a href="https://mariadb.com/kb/en/mariadb/index-condition-pushdown/" target="_blank" rel="noopener">https://mariadb.com/kb/en/mariadb/index-condition-pushdown/</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/06/26/Index-Condition-Pushdown-优化/" data-id="ckw1x703a00095enus2wip66e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis内存优化-聚合数据类型的特殊编码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/10/Redis内存优化-聚合数据类型的特殊编码/" class="article-date">
  <time datetime="2016-06-10T00:24:56.000Z" itemprop="datePublished">2016-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/10/Redis内存优化-聚合数据类型的特殊编码/">Redis内存优化之小的聚合数据类型的特殊编码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Redis内存优化之小的聚合数据类型的特殊编码"><a href="#Redis内存优化之小的聚合数据类型的特殊编码" class="headerlink" title="Redis内存优化之小的聚合数据类型的特殊编码"></a>Redis内存优化之小的聚合数据类型的特殊编码</h2><p>从Redis2.2开始，很多数据类型被优化为使用更小的空间。对于由数字组成的Hashes，Lists， Sets，Sorted Sets 在某些情况下可以使用使用更加有效的内存方式来进行编码，这种更有效的内存方式可以节约最少5倍最大10倍的内存。那么在什么情况这些数字组成的类型可以使用这种更有效的内存方式呢?</p>
<pre><code>当元素个数小于给定的数量时，
当到了一个最大的元素大小时，
</code></pre><p>从用户和API角度来看，这完全是透明的。因为这是一种CPU/内存的平衡。可以使用redis.conf中的指令来调整元素的最大个数和最大的元素大小。</p>
<pre><code>hash-max-zipmap-entries 512 (hash-max-ziplist-entries for Redis &gt;= 2.6)
hash-max-zipmap-value 64  (hash-max-ziplist-value for Redis &gt;= 2.6)
list-max-ziplist-entries 512
list-max-ziplist-value 64
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
set-max-intset-entries 512
</code></pre><p>如果一个特定编码值超过了设置的最大值，Redis被自动将其转为普通编码。这个转换过程，对于小的取值非常快，但如果你为了使用特殊编码值而改变了配置，那么就需要允许压力测试来测试这个转换时间了。 </p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>进行三个实践。</p>
<p>第一个使用key/value的形式存储1w个数据，占用空间608175字节。</p>
<p>第二个使用hash的形式存储1w个数据，占用空间79424字节</p>
<ol>
<li>采用k/v形式</li>
</ol>
<pre><code>#! /bin/bash

redis-cli info|grep used_memory:

for (( start = 10000; start &lt;20000 ; start++ ))
do
    redis-cli set $start 100 &gt; /dev/null
done

redis-cli info|grep used_memory:
</code></pre><ol start="2">
<li>采用hash形式</li>
</ol>
<pre><code>#! /bin/bash

redis-cli info|grep used_memory:

for (( start = 10000; start &lt; 20000 ; start++ ))
do
    hash=$((start % 100))
    redis-cli hset $hash $start 100 &gt; /dev/null
done

redis-cli info|grep used_memory:
</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://redis.io/topics/memory-optimization" target="_blank" rel="noopener">redis内存优化</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/06/10/Redis内存优化-聚合数据类型的特殊编码/" data-id="ckw1x703n00115enuwy5sqs24" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nosql/">nosql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-php发送邮件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/25/php发送邮件/" class="article-date">
  <time datetime="2016-05-25T08:31:31.000Z" itemprop="datePublished">2016-05-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/25/php发送邮件/">php发送邮件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="0-概述"><a href="#0-概述" class="headerlink" title="0. 概述"></a>0. 概述</h2><p>php manual中关于mail的介绍很简单，</p>
<pre><code>@param to 电子邮件收件人或收件人列表
@param subjct 电子邮件的主题 也就是收件人或收件人列表
@param message 所要发送的消息 
@return true if the mail was successfully accepted fro delivery, FALSE otherwise
bool mail ( string $to , string $subject , string $message [, string $additional_headers [, string $additional_parameters ]] )
</code></pre><h2 id="0-我的代码"><a href="#0-我的代码" class="headerlink" title="0. 我的代码"></a>0. 我的代码</h2><p>根据邮件协议，使用基本的php代码进行编写，直接包含这个类即可使用</p>
<h2 id="1-发送html"><a href="#1-发送html" class="headerlink" title="1. 发送html"></a>1. 发送html</h2><ol>
<li>发送html就是将正文的message以文本格式发送<h2 id="2-发送附件"><a href="#2-发送附件" class="headerlink" title="2. 发送附件"></a>2. 发送附件</h2></li>
<li><p>附件需要以multipart/form-data的格式进行组装，这儿与web上传form表单的格式一样。例子如下</p>
<pre><code>--==Mime_Multipart_Boundary_x69c8f8864502559be8e17a0cb379ff0cx
Content-Transfer-Encoding: base64

54eV5YevQm9keQoKCgo=

--==Mime_Multipart_Boundary_x69c8f8864502559be8e17a0cb379ff0cx
X-Attachment-Id: 15259
Content-Transfer-Encoding: base64
Content-Type: application/octet-stream; name=&quot;keything.txt&quot;
Content-Disposition: attachment; filename=&quot;keything.txt&quot;

54eV5Yev

--==Mime_Multipart_Boundary_x69c8f8864502559be8e17a0cb379ff0cx--
</code></pre></li>
<li>我们所发出的数据就如上面文本所示，因此要将其组装</li>
</ol>
<ol start="3">
<li><p>class KTMail</p>
<pre><code>&lt;?php
class KTMail
{
    const UTF8_PREFIX  = &apos;=?UTF-8?B?&apos;;
    const UTF8_POSTFIX = &apos;?=&apos;;
    const RN = &quot;\r\n&quot;;
    /**
     * @param from: who send this mail
     * @param to: who receive this mail
     * @param subject: the title of mail
     * @param body: the content of mail
     * @param attachment_fname: the file name of attachement
     * @param attachment_fdata: the file content of attachment
     * @return true if send succeed, FALSE otherwise
     * TODO if attachment_fname is chinese, it will be messay code.
     */
    public static function sendWithAttach($from, $to, $subject, $body, $attachment_fname, $attachment_fdata)
    {
        // a random string 
        $semi_rand = md5(time()); 
        $mime_boundary = &apos;==Mime_Multipart_Boundary_x&apos; . $semi_rand . &apos;x&apos;;
        $part_boundary = &apos;==Part_Multipart_Boundary_x&apos; . $semi_rand . &apos;x&apos;;

        // header 
        $headers = [];
        $headers[] = &apos;MIME-Version: 1.0&apos;;
        $headers[] = &apos;Content-Type: multipart/mixed; boundary=&apos; . $mime_boundary;
        $headers[] = &apos;From: &apos; . $from;
        $headers_raw = implode(self::RN, $headers);

        // Message Body
        $msg = [];
        $msg[] = &apos;--&apos; . $mime_boundary;
        $msg[] = &apos;Content-Transfer-Encoding: base64&apos; . self::RN;
        $msg[] =  chunk_split(base64_encode($body));

        // Attachment
        $msg[] = &apos;--&apos; . $mime_boundary;
        $msg[] = &apos;X-Attachment-Id: &apos; . rand(1000, 99999);
        $msg[] = &apos;Content-Transfer-Encoding: base64&apos;;
        $msg[] = &apos;Content-Type: application/octet-stream;&apos; . &apos; name=&quot;&apos; . $attachment_fname . &apos;&quot;&apos;;
        $msg[] = &apos;Content-Disposition: attachment; filename=&quot;&apos;. $attachment_fname . &apos;&quot;&apos; . self::RN;
        $msg[] = chunk_split(base64_encode($attachment_fdata));
        $msg[] = &apos;--&apos; . $mime_boundary . &apos;--&apos;;

        $msg_raw = implode(self::RN, $msg);
        error_log($msg_raw, 3, &apos;/tmp/sendmail.log&apos;);

        $real_subject = self::UTF8_PREFIX . base64_encode($subject) . self::UTF8_POSTFIX;

        return mail($to, $real_subject, $msg_raw, $headers_raw);
    }
    public static function sendWithHtml($from, $to, $subject, $body)
    {
        // header 
        $headers = array();
        $headers[] = &apos;MIME-Version: 1.0&apos;;
        $headers[] = &apos;Content-type: text/html; charset=utf-8&apos;;
        $headers[] = &apos;From: &apos; . $from;
        $headers_raw = implode(self::RN, $headers);

        // Message Body
        $real_subject = self::UTF8_PREFIX . base64_encode($subject) . self::UTF8_POSTFIX;
        $msg_raw = $body;

        return mail($to, $real_subject, $msg_raw, $headers_raw);
    }
}
</code></pre></li>
<li><p>测试用例</p>
<pre><code>&lt;?php
include (&apos;ktmail.php&apos;);
$from = &apos;local@a.cn&apos;;
$to = &apos;your-email&apos;;
$subject = &apos;keything.net&apos;;
$body = &apos;keything.net&apos;;
$attachment_fname = &apos;keything.txt&apos;;
$attachment_fdata = &apos;keything&apos;;
$attach_res = KTMail::sendWithAttach($from, $to, $subject, $body, $attachment_fname, $attachment_fdata);
echo &apos;attach_res = &apos; . var_export($attach_res, true).&quot;\n&quot;;

$html_body = &apos;
    &lt;html&gt;
        &lt;head&gt; keything &lt;/head&gt;
        &lt;body&gt; 
            keything body 
            &lt;table border=&quot;1&quot;&gt;
                &lt;tr&gt;
                    &lt;td&gt;row 1, cell 1&lt;/td&gt;
                    &lt;td&gt;row 1, cell 2&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td&gt;row 2, cell 1&lt;/td&gt;
                    &lt;td&gt;row 2, cell 2&lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/body&gt;
        &lt;/head&gt;
    &lt;/html&gt;
    &apos;;
$html_res = KTMail::sendWithHtml($from, $to, $subject, $html_body);
echo &apos;html_res = &apos; . var_export($html_res, true).&quot;\n&quot;;
</code></pre></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/05/25/php发送邮件/" data-id="ckw1x704y004e5enuwy8fifkl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-nginx模块执行顺序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/08/nginx模块执行顺序/" class="article-date">
  <time datetime="2016-05-08T10:00:01.000Z" itemprop="datePublished">2016-05-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/08/nginx模块执行顺序/">nginx模块执行顺序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>整篇文章参考</p>
<ol>
<li><a href="http://openresty.org/download/agentzh-nginx-tutorials-zhcn.html" target="_blank" rel="noopener">http://openresty.org/download/agentzh-nginx-tutorials-zhcn.html</a></li>
<li><a href="http://www.nginxguts.com/2011/01/phases/" target="_blank" rel="noopener">http://www.nginxguts.com/2011/01/phases/</a></li>
</ol>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-简要介绍"><a href="#1-简要介绍" class="headerlink" title="1. 简要介绍"></a>1. 简要介绍</h2><p> 在每个阶段都可以注册多个自定义的handlers。但是下面的几个阶段是不能够注册自定义的handler的：</p>
<pre><code>1. find-config阶段
2. post-access阶段
3. post-rewrite阶段
4. try-files阶段
</code></pre><p>每个阶段都有一个与之相关的handler的列表。一旦把handler注册到对应阶段，那么handler就会返回下面的取值：</p>
<pre><code>NGX_OK：请求已经成功处理，请求将会传到下一个阶段。

NGX_DECLINED：请求需要被转发到本阶段的下一个handler

NGX_AGAIN,NGX_DONE：请求已经被正确处理，同时请求被挂起，直到某个事件（子请求结束、socket可写或超时等）到来，handler才会再次被调用
</code></pre><h2 id="2-如何注册自定义的handler"><a href="#2-如何注册自定义的handler" class="headerlink" title="2. 如何注册自定义的handler"></a>2. 如何注册自定义的handler</h2><p> 为了在某个阶段注册自定义的handler，需要找到<code>ngx_http_core_module</code>，并添加（<code>ngx_array_push</code>)到指定的phrase向量中。handlers以相反的顺序被调用。因此在配置中最后注册的handler会首先被调用。</p>
<p>  从上面可以看出，请求处理的顺序和配置文件中的配置指令的先后顺序无关，无论配置文件中指令的顺序如何，各个阶段的处理函数都会按照预先的顺序执行。因此一个处理函数需要知道自己什么时候会被调用，何时需要返回NGX_DECLINED，而且保证减少性能损耗。</p>
<h2 id="3-各个phase对于返回值的处理："><a href="#3-各个phase对于返回值的处理：" class="headerlink" title="3. 各个phase对于返回值的处理："></a>3. 各个phase对于返回值的处理：</h2><ol>
<li><p>Access阶段</p>
<pre><code>NGX_OK：允许访问请求URI指定的资源
   NGX_HTTP_FORBIDDEN，NGX_HTTP_UNAUTHORIZED：不允许访问请求URI指定的资源
</code></pre></li>
<li><p>Content阶段</p>
<pre><code> NGX_AGAIN或NGX_DONE时，content handler不会再被调用。取而代之的handler改变请求的读或写的handler
如果content handler返回NGX_DECLINED， nginx将会将请求转发到content phrase handlers。
</code></pre></li>
<li><p>关于content phase handler与content handler的区别</p>
</li>
</ol>
<p>a. content phase handler是混乱的：每个到达content阶段的请求都可以调用content phase handler. 对于配置content handler的location，这些请求只能调用一次content handler。</p>
<p>b. 在一个location中可以调用多个content phase handler。但是在一个location中只能有一个content handler。</p>
<p>这儿借用agentzh 文章Nginx配置指令的执行顺序（五）中例子。</p>
<pre><code>location /test {
    echo_before_body &quot;before...&quot;;
    proxy_pass http://127.0.0.1:8080/foo;
    echo_after_body &quot;after...&quot;;
}

location /foo {
    echo &quot;contents to be proxied&quot;;
}
</code></pre><p>测试结果表明这一次我们成功了：</p>
<pre><code>$ curl &apos;http://localhost:8080/test&apos;
before...
contents to be proxied
after...

因此我们知道echo_before_body 和echo_after_body指令都属于content phase handler。也就是Agentzh文中的输出过滤器。
</code></pre><h1 id="二、详细介绍"><a href="#二、详细介绍" class="headerlink" title="二、详细介绍"></a>二、详细介绍</h1><p>Nginx 处理请求的过程一共划分为 11 个阶段，按照执行顺序依次是 post-read、server-rewrite、find-config、rewrite、post-rewrite、preaccess、access、post-access、try-files、content 以及 log.</p>
<h2 id="1-post-read"><a href="#1-post-read" class="headerlink" title="1. post-read"></a>1. post-read</h2><ol>
<li>支持模块注册处理程序</li>
<li>发生阶段:nginx读取并解析完请求头之后立即开始执行 </li>
<li>示例模块：标准模块 ngx_realip，目的：改写请求的来源地址。</li>
<li><p>举例</p>
<pre><code>server {
    listen 8080;

    set_real_ip_from 127.0.0.1; # 规定来源地址的改写只对那些来自127.0.0.1请求生效
    real_ip_header   X-My-IP;

    location /test {
        set $addr $remote_addr;
        echo &quot;from: $addr&quot;;
    }
}
</code></pre><p> 结果</p>
<pre><code>$curl -H &apos;X-My-IP: 1.2.3.4&apos; your.domain/test
from: 1.2.3.4
</code></pre></li>
</ol>
<h2 id="2-server-rewrite"><a href="#2-server-rewrite" class="headerlink" title="2. server-rewrite"></a>2. server-rewrite</h2><ol>
<li>支持模块注册处理程序</li>
</ol>
<h2 id="3-find-config"><a href="#3-find-config" class="headerlink" title="3. find-config"></a>3. find-config</h2><ol>
<li>不支持模块注册处理程序</li>
<li>目的：由nginx核心完成当前请求与location配置块之间的配对工作。在此阶段之前，请求没有与任何location配置块相关联。</li>
</ol>
<h2 id="4-rewrite"><a href="#4-rewrite" class="headerlink" title="4. rewrite"></a>4. rewrite</h2><ol>
<li>支持模块注册处理程序</li>
<li>目的：对当前请求进行各种修改，比如URI，URL，或者创建并初始化一系列后续处理阶段所需要的变量</li>
</ol>
<h2 id="5-post-rewrite"><a href="#5-post-rewrite" class="headerlink" title="5. post-rewrite"></a>5. post-rewrite</h2><p>location级别重写的后一阶段，用来检查上阶段是否有uri重写，并根据结果跳转到合适的阶段；</p>
<ol>
<li>不支持模块注册处理程序</li>
<li>目的：nginx核心完成rewrite阶段所要求的“内部跳转”操作。“内部跳转”本质上其实是把当前请求的处理阶段倒退到find-config阶段，以便重新进行请求URI与location配置块的配对。 </li>
<li><p>注意：有趣的地方是，倒退回find-config阶段的动作并不是发生在rewrite阶段，而是发生在后面的POST-REWRITE阶段。rewrite指令只是简单地指示Nginx有必要在POST-REWRITE阶段发起“内部跳转”。这个设计的目的是：为了在最初匹配的location块中支持多次反复地改写URI。</p>
<pre><code>location /foo {
rewrite ^ /bar;
rewrite ^ /baz;

echo foo;
}

location /bar {
    echo bar;
}

location /baz {
    echo baz;
}
</code></pre><p>请求</p>
<pre><code> $ curl localhost:8080/foo
baz
</code></pre><p> 日志</p>
<pre><code>$ grep &apos;using config&apos; logs/error.log
   [debug] 89449#0: *1 using configuration &quot;/foo&quot;
   [debug] 89449#0: *1 using configuration &quot;/baz&quot;
</code></pre></li>
<li><p>server配置块中的rewrite指令</p>
<p> server配置块中的rewrite指令对请求URI进行改写，则不会涉及”内部跳转“，因为此时URI改写发生在server-rewrite阶段，早于location配对的find-config阶段。</p>
</li>
</ol>
<h2 id="6-pre-access"><a href="#6-pre-access" class="headerlink" title="6. pre-access"></a>6. pre-access</h2><ol>
<li>标准模块<code>ngx_limit_req</code>和<code>ngx_limit_zone</code> 就运行在此阶段，前者控制请求的访问频度，后者限制访问的并发度。</li>
<li>【建议】 尽量在server配置块中配置ngx_realip这样的模块</li>
</ol>
<h2 id="7-acess"><a href="#7-acess" class="headerlink" title="7. acess"></a>7. acess</h2><ol>
<li>标准模块 ngx_access</li>
<li>第三方模块 ngx_auth_request, access_by_lua</li>
</ol>
<h2 id="8-post-access阶段"><a href="#8-post-access阶段" class="headerlink" title="8. post-access阶段"></a>8. post-access阶段</h2><ol>
<li>不支持模块注册处理程序</li>
<li>目的：主要配合acess阶段实现标准ngx_http_core模块提供的配置指令satisfy的功能。在access阶段注册多个处理指令，satisfy指令可以用于控制它们彼此之间的协作方式。有两种协作方式，一种是all（与关系），一种是any（或关系）。</li>
<li><p>举例：</p>
<pre><code>location /test {
satisfy all;

deny all;
access_by_lua &apos;ngx.exit(ngx.OK)&apos;;

echo something important;
}
</code></pre><p> 请求</p>
<pre><code>satisfy all; $curl your.domain/test ----403 forbidden
satisfy any; $curl your.domain/test ---- something important
</code></pre></li>
</ol>
<h2 id="9-try-files"><a href="#9-try-files" class="headerlink" title="9. try-files"></a>9. try-files</h2><ol>
<li>不支持模块注册处理程序</li>
<li>目的：专门实现标准配置指令<code>try_files</code>功能</li>
<li><code>try_files</code> 指令接受两个以上任意数量的参数，每个参数都指定了一个 URI. 这里假设配置了 N 个参数，则 Nginx 会在 try-files 阶段，依次把前 N-1 个参数映射为文件系统上的对象（文件或者目录），然后检查这些对象是否存在。一旦 Nginx 发现某个文件系统对象存在，就会在 try-files 阶段把当前请求的 URI 改写为该对象所对应的参数 URI（但不会包含末尾的斜杠字符，也不会发生 “内部跳转”）。如果前 N-1 个参数所对应的文件系统对象都不存在，try-files 阶段就会立即发起“内部跳转”到最后一个参数（即第 N 个参数）所指定的 URI. </li>
<li><code>try_files</code> 指令本质上只是有条件地改写当前请求的 URI，而这里说的“条件”其实就是文件系统上的对象是否存在。当“条件”都不满足时，它就会无条件地发起一个指定的“内部跳转”。当然，除了无条件地发起“内部跳转”之外， try_files 指令还支持直接返回指定状态码的 HTTP 错误页，例如try_files /foo /bar =404;</li>
<li><p>特别注意：对于<code>try_files</code>指令，通过URI末尾的斜杠字符来区分”目录“和”文件“的。</p>
<pre><code> root /var/www/;

location /test {
    try_files /foo /bar/ /baz;
    echo &quot;uri: $uri&quot;;
}

location /foo {
    echo $uri;
    echo &quot;foo&quot;;
}

location /bar/ {
       echo $uri;
     echo bar;
}

location /baz {
    echo $uri;
    echo baz;
}
</code></pre></li>
</ol>
<p>case1 ：根目录下没有foo文件，bar目录，输出/baz, baz</p>
<pre><code>$ grep trying logs/error.log
[debug] 3869#0: *1 trying to use file: &quot;/foo&quot; &quot;/var/www/foo&quot;
[debug] 3869#0: *1 trying to use dir: &quot;/bar&quot; &quot;/var/www/bar&quot;
[debug] 3869#0: *1 trying to use file: &quot;/baz&quot; &quot;/var/www/baz&quot;
</code></pre><p> 这里最后一条“调试信息”容易产生误解，会让人误以为 Nginx 也把最后一个参数 /baz 给映射成了文件系统对象进行检查，事实并非如此。当 try_files 指令处理到它的最后一个参数时，总是直接执行“内部跳转”，而不论其对应的文件系统对象是否存在。</p>
<p> case2 :根目录下有foo文件，输出 uri: /foo</p>
<h2 id="10-content"><a href="#10-content" class="headerlink" title="10. content"></a>10. content</h2><ol>
<li><p>目的：内容生成阶段。肩负着生成“内容”， 并输出HTTP响应的使命。echo, proxy_pass都属于该阶段。</p>
</li>
<li><p>对于content阶段，有两种情况：</p>
<p>  a. 没有使用任何content阶段的指令。那么就会执行静态资源服务模块：<code>ngx_index</code>, <code>ngx_autoindex</code>, <code>ngx_static</code>模块</p>
<p>  b. 如果使用了content阶段的指令，如echo，proxy_pass。</p>
<pre><code>每个location只能有一个内容处理程序content handler.有多个时content阶段指令时，只有一个能够被注册并执行。
</code></pre><p>  比如指令中有 <code>echo ‘hello’;proxy_pass so.com;</code>到底哪个被执行是不一定的。因为在同一个阶段phase中，各个handler的执行顺序是不一定的。</p>
</li>
</ol>
<h2 id="11-log"><a href="#11-log" class="headerlink" title="11. log"></a>11. log</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/05/08/nginx模块执行顺序/" data-id="ckw1x704t00455enu64z8oid6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-nginx-rewrite详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/05/nginx-rewrite详解/" class="article-date">
  <time datetime="2016-05-05T10:00:01.000Z" itemprop="datePublished">2016-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/05/nginx-rewrite详解/">nginx-rewrite详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h3><p><code>ngx_http_rewrite_module</code>模块通过正则表达式、return重定向和条件选择配置（conditionally select configurations）改变请求的URI。<br><code>ngx_http_rewrite_module</code>模块中的指令以下面的顺序执行：</p>
<pre><code>1. 在server{}中的指令先被执行，并且是根据配置中先后顺序依次执行
2. 重复的：
    1. 根据请求URI匹配一个location
    2. 在匹配的location中，该模块的指令按先后顺序依次执行
    3. 如果一个请求URI被重定向，这个循环被重复，但最多不超过10次。
</code></pre><p>【解释】在<code>ngx_http_rewrite_module</code>初始化的时候(<code>ngx_http_rewrite_init</code>)的时候，在<code>SERVER_REWRITE</code>和<code>REWRITE</code>两个阶段注册了相同的处理函数<code>ngx_http_rewrite_handler</code>.</p>
<h3 id="二-指令"><a href="#二-指令" class="headerlink" title="二. 指令"></a>二. 指令</h3><h4 id="1-break"><a href="#1-break" class="headerlink" title="1. break"></a>1. break</h4><pre><code>Syntax:break;
Default:—
Context:server, location, if
</code></pre><p>停止处理<code>ngx_http_rewrite_module</code>模块的指令。<br>如果在location里面使用，那么这个请求接下来phase的处理也都是在这个location里面。<br>看下面的例子</p>
<pre><code>location /proxy3 {
    rewrite (.*) /third;
    set $a 35;
    break;
    rewrite (.*) /second;
    set $a 76;
    echo $a;
}
location /second {
    echo &apos;second&apos;;
    echo $a;
}
location /third {
    echo &apos;third&apos;;
    echo $a;
}
</code></pre><p>curl <a href="http://your.domain/proxy3" target="_blank" rel="noopener">http://your.domain/proxy3</a> </p>
<table>
<thead>
<tr>
<th>case</th>
<th>result</th>
<th>reason</th>
</tr>
</thead>
<tbody>
<tr>
<td>有break</td>
<td>输出35</td>
</tr>
<tr>
<td>没有break</td>
<td>输出second 76</td>
<td>因为4条指令顺序执行，rewrite (.*) /second是最后一条rewrite指令，生效。set $a 76生效。因此在POST-REWRITE阶段转到location /second</td>
</tr>
</tbody>
</table>
<h4 id="2-if"><a href="#2-if" class="headerlink" title="2. if"></a>2. if</h4><pre><code>Syntax: if (condition) {...}
Default: ---
Context: server, location
</code></pre><p>指定的condition参数被判断。如果为true，在if里面的模块指令被执行，请求进入到if指令里面的配置。在if指令里面的配置继承于上一层的配置。<br>condition可以是下面几种情况：</p>
<pre><code>1. 一个变量名; 如果变量是空字符串或0，则false
2. 使用= !=运算符比较
3. 使用~(区分大小写) ~*(不区分大小写) 正则表达式包含capture，可以使用$1...$9来使用捕获的值。!~ !~*也可以使用.如果正则表达式包含} ;的话，整个正则表达式要放在单引号或双引号里面。
4. 检查文件是否存在 -f !-f
5. 检查目录是否存在 -d !-d
6. 检查文件，目录，软链是否存在 -e !-e
7. 检查是否可执行文件 -x !-x
</code></pre><p>举例：</p>
<pre><code>if ($http_user_agent ~ MSIE) {
       rewrite ^(.*)$ /msie/$1 break;
}

if ($http_cookie ~* &quot;id=([^;]+)(?:;|$)&quot;) {
    set $id $1;
}

if ($request_method = POST) {
    return 405;
}

if ($slow) {
    limit_rate 10k;
}

if ($invalid_referer) {
    return 403;
}
</code></pre><h4 id="3-return"><a href="#3-return" class="headerlink" title="3. return"></a>3. return</h4><pre><code>Syntax: return code [text];
        return code URL;
        return URL;
</code></pre><p> 停止处理，并将code返回给客户端。非标准code444 关闭连接并且不发送响应头。<br> 从版本0.8.42开始，可以指定一个URL（对于301，302，303和307）或者响应体（其他code）。一个响应体和重定向的URL可以包含变量。<br> 另外，URL可以指定为单个参数，这样就是302临时跳转。这样一个参数需要以http://, https://, $scheme开头。</p>
<h4 id="4-rewrite"><a href="#4-rewrite" class="headerlink" title="4. rewrite"></a>4. rewrite</h4><pre><code>Syntax: rewrite regex replacement [flag];
Default: ---
Context: server, location, if
</code></pre><p>如果指定的正则表达式匹配了一个请求的URI，URI被指定的replacement改变。</p>
<p>配置文件中多个rewrite指令时，按照出现顺序依次执行，只执行最后一个。可以使用[flags]终止指令的处理。</p>
<p>如果replacement以<code>http:// https://</code> 开头，那么处理将会停止，并重定向返回给客户端。</p>
<p>可选参数flag，可以是下面几个中的某一个:</p>
<pre><code>last:
    停止处理ngx_http_rewrite_module模块的指令集，然后使用改变后的URI去查找新的location。
    【注释】即遇到last以后，执行阶段从rewrite阶段回到了find-config阶段。
break:
    停止处理ngx_http_rewrite_module模块的指令集。
    【注释】遇到break以后，执行阶段从rewrite阶段转到下一个阶段。如果是server-rewrite则转到find-config, 如果是rewrite则转到post-rewrite。
redirect:
    返回一个302临时跳转。当replacement不是以http://, https://开头的时候使用
permanent:
    返回一个301永久跳转。
</code></pre><p>last其实就相当于一个新的url，对nginx进行了一次请求，需要走一遍大多数的处理过程，最重要的是会做一次find config，提供了一个可以转到其他location的配置中处理的机会，</p>
<p>而break则是在一个请求处理过程中将原来的url(包括uri和args)改写之后，在继续进行后面的处理，这个重写之后的请求始终都是在同一个location中处理。</p>
<h4 id="5-rewrite-log"><a href="#5-rewrite-log" class="headerlink" title="5. rewrite_log"></a>5. rewrite_log</h4><pre><code>Syntax: rewrite_log on | off;
Default: rewrite_log off;
Context: http,server,location,if
</code></pre><p>开启或关闭<code>ngx_http_rewrite_module</code>模块指令处理结果到error_log文件，日志级别notice.</p>
<h2 id="三-例子"><a href="#三-例子" class="headerlink" title="三. 例子"></a>三. 例子</h2><ol>
<li><p>echo $a被if继承。因此输出45</p>
<pre><code>location /proxy3 {
     echo $a;
     set $a 35;
     if ($a = 35) {
         set $a 45;
     }
}
</code></pre></li>
<li><p>echo $a被if继承，但if指令里面有echo指令，根据配置的基本规则，if里面的echo指令有效。因此输出43 【todo】配置的基本原则是毛线？？？</p>
<pre><code>location /proxy3 {
     echo $a;
     set $a 35;
     set $b 43;
     if ($a = 35) {
         set $a 45;
         echo $b;
     }
}
</code></pre></li>
<li><p>由于if处于rewrite阶段，执行if以后依然处于rewrite阶段，因此if{}后面的模块指令依然执行。<br>因此输出67;</p>
<pre><code>location /proxy3 {
     echo $a;
     set $a 35;
     if ($a = 35) {
         set $a 45;
     }
     set $a 67;
}
</code></pre></li>
<li><p>演示rewrite</p>
<pre><code>location /proxy3 {
    #rewrite (.*) http://your.domain/third;
    rewrite (.*) /third;
    set $a 67;
    echo $a;
}
set $a 99;
location /third {
    echo $a;
}
</code></pre><p>如果rewrite后面是/third 则输出67<br>如果是http:// 则输出99。<br>解释：<br>set $a 99 发生在server-rewrite阶段<br>之后在find-config阶段，找到location /proxy3<br>在location /proxy3里面 如果是<code>rewrite http://...</code>那么直接跳转。类似 rewrite (.<em>) /third redirect;<br>如果是rewrite (.</em>) /third呢 则还会继续执行接下来的rewrite阶段的指令，set $a 67将会被执行。然后在post-rewrite阶段调转到location /third</p>
</li>
<li><p>rewrite中带有flag</p>
<pre><code>location /proxy3 {
      set $a 35;
      if ($a = 35) {
          set $a 73;
          rewrite (.*) /main break;
      }
      rewrite (.*) /second;
      set $a 76;
      echo &apos;proxy3&apos;;
      echo $uri;
      echo $a;
  }
  location /main {
      echo &apos;main&apos;;
      echo $a;
  }
  location /second {
      echo &apos;second&apos;;
      echo $a;
  }
</code></pre><p> 如果是<code>rewrite (.*) main break</code> 。 则输出proxy3 /main 73</p>
<p> 如果是<code>rewrite (.*) main; break;</code>，则输出proxy3 /main 73<br> 原因是而break则是在一个请求处理过程中将原来的url(包括uri和args)改写之后，在继续进行后面的处理，这个重写之后的请求始终都是在同一个location中处理；</p>
<p> 如果是<code>rewrite (.*) main last</code>，则输出main 35</p>
<p> 如果是<code>rewrite (.*) main</code> 不加break,last, 则rewrite (.*) /second; set $a 76执行 输出 second 76</p>
</li>
</ol>
<ol start="6">
<li><p>多个rewrite只有最后一个起作用</p>
<pre><code>location /proxy3 {
    rewrite (.*) /third;
    set $a 35;
    if ($a = 35) {
        rewrite (.*) /main;
    }
    rewrite (.*) /second; 
    set $a 76;
    echo $a;
}
</code></pre></li>
</ol>
<h2 id="四-几点事实："><a href="#四-几点事实：" class="headerlink" title="四. 几点事实："></a>四. 几点事实：</h2><ol>
<li>rewrite 指令被称为 action directives. 下一层级的location不会从上一级中继承。</li>
<li>server 作用域中的 rewrite 模块指令也不会向下传递到 location 作 用域，但是这些指令会在 SERVER_REWRITE 阶段 (先于 REWRITE 阶段) 被执行.</li>
<li>rewrite 模块提供的指令的执行顺序和其在配置文件中的定义顺序一致</li>
<li><p>if 指令在nginx内部创建了一个无名location，if条件为真时，nginx使用这个无名location作用域的配置处理当前请求。 </p>
</li>
<li><p>rewrite模块<br>rewrite 模块是一个 phase handler， 其初始化函数 <code>ngx_http_rewrite_init</code> 在 SERVER REWRITE 和 REWRITE 阶段 注册了相同的处理函数<code>ngx_http_rewrite_handler</code>。其中，SERVER REWRITE 阶段 的处理函数用于执行 server 作用域中的 rewrite 模块指令，而 REWRITE 阶 段的处理函数用于执行 location 和 if 作用域的 rewrite 模块指令。</p>
</li>
<li><p>POST REWRITE 是 Nginx 内部定义的阶段，通过检查请求 uri 是否被 rewrite 模块修改 (r-&gt;uri_changed)，判断是否需要使用修改后的 uri 重新开始 FIND CONFIG 以重新匹配合适的 location。比如在 location 中有配置如 rewrite … last; 且 rewrite 成功和请求 uri 匹配成功时。</p>
</li>
</ol>
<ol start="7">
<li>指令执行顺序</li>
</ol>
<p>nginx大部分模块提供的配置指令的生效顺序和其在配置文件中的顺序并没有什么关系。但有些是有关系的，比如</p>
<pre><code>1. http core模块中使用正则表达式的location。跟顺序有关
2. rewrite模块中提供的if，break，return，rewrite指令
</code></pre><h2 id="五-参考文章"><a href="#五-参考文章" class="headerlink" title="五. 参考文章"></a>五. 参考文章</h2><p><a href="http://ialloc.org/posts/2015/07/28/ngx-notes-http-evil-if-1/" target="_blank" rel="noopener">http://ialloc.org/posts/2015/07/28/ngx-notes-http-evil-if-1/</a><br><a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">http://nginx.org/en/docs/http/ngx_http_rewrite_module.html</a><br><a href="https://blog.martinfjordvald.com/2012/08/understanding-the-nginx-configuration-inheritance-model/" target="_blank" rel="noopener">https://blog.martinfjordvald.com/2012/08/understanding-the-nginx-configuration-inheritance-model/</a><br><a href="http://ialloc.org/posts/2013/07/18/ngx-notes-conf-parsing/" target="_blank" rel="noopener">http://ialloc.org/posts/2013/07/18/ngx-notes-conf-parsing/</a><br><a href="http://blog.csdn.net/brainkick/article/details/7475770" target="_blank" rel="noopener">http://blog.csdn.net/brainkick/article/details/7475770</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/05/05/nginx-rewrite详解/" data-id="ckw1x704q003w5enugce6tfro" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/8/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Laravel/">Laravel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/composer/">composer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/">cpp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp-lib/">cpp-lib</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/faiss/">faiss</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-source-code/">go.source.code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/laravel/">laravel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/">mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/machine-learning/">machine-learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memcache/">memcache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nosql/">nosql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/octave/">octave</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php源码学习/">php源码学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/">spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tcp/">tcp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thrift/">thrift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础知识/">基础知识</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Laravel/" style="font-size: 10px;">Laravel</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/composer/" style="font-size: 10px;">composer</a> <a href="/tags/cpp/" style="font-size: 12.22px;">cpp</a> <a href="/tags/cpp-lib/" style="font-size: 10px;">cpp-lib</a> <a href="/tags/elasticsearch/" style="font-size: 11.11px;">elasticsearch</a> <a href="/tags/faiss/" style="font-size: 10px;">faiss</a> <a href="/tags/git/" style="font-size: 12.22px;">git</a> <a href="/tags/go-source-code/" style="font-size: 10px;">go.source.code</a> <a href="/tags/golang/" style="font-size: 16.67px;">golang</a> <a href="/tags/laravel/" style="font-size: 11.11px;">laravel</a> <a href="/tags/linux/" style="font-size: 14.44px;">linux</a> <a href="/tags/mac/" style="font-size: 13.33px;">mac</a> <a href="/tags/machine-learning/" style="font-size: 10px;">machine-learning</a> <a href="/tags/memcache/" style="font-size: 15.56px;">memcache</a> <a href="/tags/mysql/" style="font-size: 13.33px;">mysql</a> <a href="/tags/nginx/" style="font-size: 13.33px;">nginx</a> <a href="/tags/nosql/" style="font-size: 18.89px;">nosql</a> <a href="/tags/octave/" style="font-size: 10px;">octave</a> <a href="/tags/php/" style="font-size: 20px;">php</a> <a href="/tags/php源码学习/" style="font-size: 17.78px;">php源码学习</a> <a href="/tags/redis/" style="font-size: 12.22px;">redis</a> <a href="/tags/spark/" style="font-size: 12.22px;">spark</a> <a href="/tags/tcp/" style="font-size: 10px;">tcp</a> <a href="/tags/thrift/" style="font-size: 13.33px;">thrift</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/基础知识/" style="font-size: 15.56px;">基础知识</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/11/16/Spark-DataSource-Hive Tables/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/11/14/分布式-事务/">分布式-事务</a>
          </li>
        
          <li>
            <a href="/2019/04/29/golang继承/">golang继承</a>
          </li>
        
          <li>
            <a href="/2019/04/28/spark-Quick-Start/">spark quick start</a>
          </li>
        
          <li>
            <a href="/2019/03/20/golang-包导入/">golang包导入</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Keything<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>