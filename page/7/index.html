<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Keything的日志</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Keything的日志">
<meta property="og:url" content="http://keything.github.io/page/7/index.html">
<meta property="og:site_name" content="Keything的日志">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Keything的日志">
  
    <link rel="alternate" href="/atom.xml" title="Keything的日志" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Keything的日志</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://keything.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-linux定时任务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/17/linux定时任务/" class="article-date">
  <time datetime="2016-08-17T08:11:49.000Z" itemprop="datePublished">2016-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/17/linux定时任务/">linux定时任务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="34-1-Cron"><a href="#34-1-Cron" class="headerlink" title="34.1. Cron"></a>34.1. Cron</h2><p>Cron是一个守护进程，根据分时日月周的组合来执行任务。<br>Cron假设系统是可用的。如果系统不可用，那么定时任务不会执行。为了安排one-time tasks，可以参考 at and batch.</p>
<p>为了执行Cron服务，<code>crond</code>服务必须执行。<br>可以使用命令<code>rpm -q vixie-cron</code>命令查看是否安装。可以使用命令 <code>service crond status</code>查看状态</p>
<h3 id="34-1-1-配置定时任务"><a href="#34-1-1-配置定时任务" class="headerlink" title="34.1.1 配置定时任务"></a>34.1.1 配置定时任务</h3><pre><code>SHELL=/bin/bash 
PATH=/sbin:/bin:/usr/sbin:/usr/bin 
MAILTO=root HOME=/  
# run-parts 
01 * * * * root run-parts /etc/cron.hourly 
02 4 * * * root run-parts /etc/cron.daily 
22 4 * * 0 root run-parts /etc/cron.weekly 
42 4 1 * * root run-parts /etc/cron.monthly
</code></pre><p>前四行用于配置定时任务执行时的环境变量。<code>SHELL</code>变量告诉系统使用哪个shell，<code>PATH</code>变量定义了执行命令的路径。<code>MAILTO</code>定义了定时任务的输出结果被email给谁，如果MAILTO=””，则不发送邮件。<code>HOME</code>变量用于home目录。</p>
<p>在<code>/etc/crontab/</code>文件中任务的格式如下：<br>    <code>minute hour day month dayofweek command</code></p>
<ul>
<li>minute – 从0到59的任何数字</li>
<li>hour   – 从0到23的任何数字</li>
<li>day    – 从0到31的任何一天</li>
<li>month  – 从1到12的任何数字（或者月份的缩写，如jan或feb）</li>
<li>dayofweek – 从0到7的数字，其中0或7代表星期天（或者缩写，如mon或sun）</li>
<li>command – 要执行的命令</li>
</ul>
<p>几种取值情况</p>
<ul>
<li><code>*</code>：代表任何有效值</li>
<li><code>-</code>：指定一个数字的范围，如1-3代表整数1，2，3。</li>
<li><code>,</code>: 一个以逗号分隔的列表，如3,4,5,8代表四个特定的数字。</li>
<li><code>/</code>: 用于指定步进的值（step value）。 The value of an integer can be skipped within a range by following the range with /<integer>. For example, 0-59/2 can be used to define every other minute in the minute field. Step values can also be used with an asterisk. For instance, the value */3 can be used in the month field to run the task every third month.</integer></li>
</ul>
<p>正如在/etc/crontab文件中，run-parts脚本执行/etc/cron.hourly/，/etc/cron.daily/, /etc/cron.weekly/, and /etc/cron.monthly/目录下的文件。在这些目录下面必须是shell脚本。</p>
<p>如果定时任务不是每小时，每天，每周，每月，那么定时任务可以加到/ect/cron.d/目录下，这个目录下文件的格式与/etc/crontab是一样的。</p>
<p>除了root以外的用户，可以使用crontab工具配置定时任务。所有用户定义的crontab都存在/var/spool/cron/目录下，并且使用创建他们的用户名来执行。使用crontab -e可以编辑。</p>
<p>cron守护进程每分钟会检查/etc/crontab文件，/ect/cron.d/目录的变化，如果有变化则加载到内存。因此如果crontab文件改变了不需要重启守护进程。</p>
<h3 id="34-1-2-控制访问cron权限"><a href="#34-1-2-控制访问cron权限" class="headerlink" title="34.1.2 控制访问cron权限"></a>34.1.2 控制访问cron权限</h3><p>/etc/cron.allow和/etc/cron.deny文件用于严格控制cron进程的访问。文件格式：一行一个用户名，不需要出现空格。如果访问控制文件修改了，crond不需要重启。</p>
<p>root用户什么时候都可以使用cron，而不用考虑访问控制文件中的用户名<br>如果cron.allow文件存在，只有users列表中的用户允许访问；忽略cron.deny文件<br>如果cron.allow文件不存在，只有cron.deny中用户不允许访问。</p>
<h3 id="34-1-3-开始和停止服务"><a href="#34-1-3-开始和停止服务" class="headerlink" title="34.1.3 开始和停止服务"></a>34.1.3 开始和停止服务</h3><p>使用service crond start 开启。<br>使用service crond stop 关闭。</p>
<h2 id="34-2-At和Batch"><a href="#34-2-At和Batch" class="headerlink" title="34.2 At和Batch"></a>34.2 At和Batch</h2><p>cron用于规划重复的任务，at命令用于规划一次性任务（one-time task)，batch用于在系统负载小于0.8的时候执行一次性任务。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://www.centos.org/docs/5/html/Deployment_Guide-en-US/s1-autotasks-at-batch.html" target="_blank" rel="noopener">cron</a></li>
<li><a href="https://www.centos.org/docs/5/html/Deployment_Guide-en-US/s1-autotasks-at-batch.html" target="_blank" rel="noopener">at and batch</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/08/17/linux定时任务/" data-id="ckw5yql4z002vp8nutjtsu2lr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础知识/">基础知识</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-RedisCluster总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/10/RedisCluster总结/" class="article-date">
  <time datetime="2016-08-10T13:39:06.000Z" itemprop="datePublished">2016-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/10/RedisCluster总结/">RedisCluster总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、RedisCluster基本内容"><a href="#一、RedisCluster基本内容" class="headerlink" title="一、RedisCluster基本内容"></a>一、RedisCluster基本内容</h1><h2 id="1-项目背景"><a href="#1-项目背景" class="headerlink" title="1. 项目背景"></a>1. 项目背景</h2><h3 id="a-整个项目背景"><a href="#a-整个项目背景" class="headerlink" title="a. 整个项目背景"></a>a. 整个项目背景</h3><ul>
<li><p>云盘memcache服务器分散，监控和替换麻烦</p>
<p>  云盘100多个集群，每个集群4个memcache，需要业务方配置和监控这些memcache。一旦memcache超时或者不可用，需要业务方和ops共同操作才能解决memcache的问题。</p>
</li>
<li><p>云盘缓存并发高、空间大</p>
<p>  云盘缓存有36亿，400G空间，每秒钟25万的请求量，因此需要高并发的缓存集群才能满足需求。</p>
</li>
</ul>
<h3 id="b-现在的替代方案"><a href="#b-现在的替代方案" class="headerlink" title="b. 现在的替代方案"></a>b. 现在的替代方案</h3><p>使用RedisCluster作为缓存集群。其特点（也是其设计目标）是：</p>
<ul>
<li>水平扩展：最大可以扩展到1000个节点</li>
<li>可以接受的写安全：当出现网络分区（即脑裂）的时候能保证连接到大多数节点分区的写是安全的。</li>
<li>高可用性：当出现网络分区时，大多数节点所在的分区是可用的；并且通过复制转移（replicas migration）保证没有从节点的主节点获得一个从节点。<br>  （所谓的复制转移：当一个主节点A有多个从节点A1,A2,A3，而另外一个主节点B没有从节点时，RedisCluster集群会从多个从节点A1,A2,A3中选择一个从节点A2作为主节点B的从节点）</li>
</ul>
<p>目前RedisCluster 目前集群大小是：</p>
<ul>
<li>一个机房一个大集群</li>
<li>bjdt：集群中有24个节点，每个节点一主一从。每个节点18.63G</li>
<li>bjcc：集群内有16个节点，每个节点一主一从。每个节点18.63G。</li>
</ul>
<h2 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2. 使用方法"></a>2. 使用方法</h2><h3 id="a-业务方使用："><a href="#a-业务方使用：" class="headerlink" title="a. 业务方使用："></a>a. 业务方使用：</h3><p>有两种客户端，一种是笨蛋客户端，一种是智能客户端。</p>
<p><code>笨蛋客户端</code>：本地不缓存节点信息，请求达到任意一个RedisCluster节点后，被告知真正的节点，然后再次请求。比如：redis-cli，telnet</p>
<pre><code>redis-cli -c -h 10.10.10.10 -p 6666
10.10.10.10:6666&gt; get ab
-&gt; Redirected to slot [13567] located at 11.11.11.11:6666
&quot;1&quot;
</code></pre><p><code>智能客户端</code>：本地缓存节点信息，通过本地计算出槽位，直接发一次请求即可。</p>
<h3 id="b-phpredis"><a href="#b-phpredis" class="headerlink" title="b. phpredis"></a>b. phpredis</h3><p>目前<a href="https://github.com/phpredis/phpredis" target="_blank" rel="noopener">phpredis</a>是智能客户端。</p>
<p>不过在最开始的版本中，phpredis每次new RedisCluster都会发送cluster slots来获取节点信息，其实对于一个业务而言是没有必要的。原因是因为RedisCluster一旦稳定后一般不会调整，那么其节点信息就维持不变，因此没有必要每次都去获取。并且cluster slots非常消耗cluster节点的cpu。这一点<a href="https://github.com/JacketWoo" target="_blank" rel="noopener">吴晓飞</a>同学已经给phpredis提了<a href="https://github.com/phpredis/phpredis/pull/826" target="_blank" rel="noopener">pullrequest</a></p>
<h2 id="3-RedisCluster基本概念"><a href="#3-RedisCluster基本概念" class="headerlink" title="3. RedisCluster基本概念"></a>3. RedisCluster基本概念</h2><h3 id="a-集群创建"><a href="#a-集群创建" class="headerlink" title="a. 集群创建"></a>a. 集群创建</h3><ol>
<li>Redis实例启动，redis.conf中多了一个配置项<code>cluster-enabled yes</code></li>
<li>Redis节点通过<code>cluster meet</code>形成一个集群，但是集群不可用</li>
<li>分配槽位：需要将16384个槽位分配到集群中各个节点。如果有的槽位没有分配成功，那么集群就可能不可用（跟<code>cluster-require-full-coverage</code>参数有关系）</li>
</ol>
<h3 id="b-RedisCluster-keys分布模型"><a href="#b-RedisCluster-keys分布模型" class="headerlink" title="b. RedisCluster keys分布模型"></a>b. RedisCluster keys分布模型</h3><p>一共有16384个hash槽位。集群中每个主节点负责16384个槽位中的一部分。如果没有正在进行中的集群重新配置，那么槽位的分布是稳定的。</p>
<p>key与槽位的映射关系计算算法（如果有hash tags则不使用该计算算法）</p>
<pre><code>HASH_SLOT=CRC(key) mod 16384
</code></pre><h3 id="c-RedisCluster与Memcache比较"><a href="#c-RedisCluster与Memcache比较" class="headerlink" title="c. RedisCluster与Memcache比较"></a>c. RedisCluster与Memcache比较</h3><p>我们知道Memcached是“分布式”缓存服务器，但是服务器端没有分布式功能，需要客户端来实现分布式，也就是需要客户端配置好几台memcached服务器，根据分布式算法（一般采用一致性hash算法）计算哪个key位于哪台memcached机器上。</p>
<p>而RedisCluster没有采用一致性hash算法，而是采用了一种<code>hash 槽位</code>的概念。与Memcached相比，业务方不需要维护memcached服务器的列表。使用智能客户端，可以先获取一份节点信息，然后在本地进行计算hash槽位。</p>
<h3 id="d-RedisCluster-HashTags"><a href="#d-RedisCluster-HashTags" class="headerlink" title="d. RedisCluster HashTags"></a>d. RedisCluster HashTags</h3><p>所谓的<code>hash tags</code>是指key中出现了<code>{&quot;字符串&quot;}</code>或者空的符合<code>{}</code>。 当出现<code>HashTags</code>时，key的<code>hash 槽位</code>不是计算整个key所在的槽位，而是计算<code>{}</code>中间字符串的槽位。<br>举例：<code>{user1000}.following</code> 与 <code>{user1000}.followers</code> 这两个key在同一个slot里面。因为其<code>hash tags</code>中的字符串是 <code>user1000</code></p>
<h3 id="e-RedisCluster和Redis比较"><a href="#e-RedisCluster和Redis比较" class="headerlink" title="e. RedisCluster和Redis比较"></a>e. RedisCluster和Redis比较</h3><ul>
<li>RedisCluster实现了所有单key的命令，比如get,set</li>
<li>RedisCluster中多key操作的命令要求多key必须在同一个节点上，可以通过<code>hash tags</code>强迫这些key存在相同节点上。</li>
</ul>
<h3 id="f-RedisCluster重定向"><a href="#f-RedisCluster重定向" class="headerlink" title="f. RedisCluster重定向"></a>f. RedisCluster重定向</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>RedisCluster有两种重定向错误：<code>-MOVED</code>和<code>-ASK</code>两种重定向错误</p>
<p>刚刚在<code>RedisCluster keys</code>分布模型中提到如果没有进行中的集群重新配置，那么槽位分布是稳定的。<br>如果集群正在发生调整呢，那么集群会返回给客户端<code>-MOVED 8 127.0.0.1:8080</code>错误或者 <code>-ASK 8 127.0.0.1:8080</code>这两个重定向错误。 </p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>举例：假设集群中节点A(<code>127.0.0.1:8080</code>)负责hash槽位13565,13566,13567。 节点B(<code>127.0.0.2:8080</code>)负责hash槽位100，101，102。</p>
<p><code>根据crc(ab) mod 16384计算得到ab这个key的slot是13567</code></p>
<p>a. 如果集群没有调整，那么 向节点B请求get ab ，那么节点B会返回<code>-MOVED 127.0.0.1:8080</code>。 </p>
<p>b. 如果集群有所调整，将hash槽位13567从节点A迁移到节点B。</p>
<p>在迁移过程中，节点A处于<code>MIGRATING</code>状态，节点B处于<code>IMPORTING</code>状态。</p>
<p>此时向节点A请求get ab， </p>
<p>1) 如果ab这个位于13567的key已经迁移到节点B了，那么将会受到<code>-ASK 127.0.0.2:8080</code>，此时客户端先向节点B发送一个ASKING的命令，然后再get ab就可以获得数据。如果客户端不向节点B发送一个ASKING命令，而是直接向节点B发送get ab则会返回<code>-MOVED</code>错误。<br>2) 如果ab这个位于13567的key没有迁移到节点B，即依然在节点A上，那么直接返回数据。</p>
<p>c. 如果集群已经调整完毕，即hash槽位13567位于节点B，那么向节点A请求 get ab就会返回<code>-MOVED 127.0.0.2:8080</code></p>
<h4 id="MOVED和-ASK两个重定向区别："><a href="#MOVED和-ASK两个重定向区别：" class="headerlink" title="-MOVED和-ASK两个重定向区别："></a><code>-MOVED</code>和<code>-ASK</code>两个重定向区别：</h4><ol>
<li>MOVED代表槽已经完全从一个节点迁移到另外一个节点</li>
<li>ASK是槽位迁移的中间态，代表这个槽位的节点正在迁移。只针对这个槽位的这个key进行重定向，该槽位上其他key依然先到原来的节点</li>
</ol>
<h3 id="f-RedisCluster节点属性"><a href="#f-RedisCluster节点属性" class="headerlink" title="f. RedisCluster节点属性"></a>f. RedisCluster节点属性</h3><pre><code>redis-cli cluster nodes
d1861060fe6a534d42d8a19aeb36600e18785e04 127.0.0.1:6379 myself - 0 1318428930 1 connected 0-1364
3886e65cc906bfd9b1f7e7bde468726a052d1dae 127.0.0.1:6380 master - 1318428930 1318428931 2 connected 1365-2729
d289c575dcbc4bdd2931585fd4339089e461a27d 127.0.0.1:6381 master - 1318428931 1318428931 3 connected 2730-4095
</code></pre><p>通过<a href="http://redis.io/commands/cluster-nodes" target="_blank" rel="noopener">cluster nodes</a>命令可以知道RedisCluster集群的很多信息，比如当前槽位分布，当前节点个数及其ip:port等等</p>
<h1 id="二、RedisCluster的高可用原理"><a href="#二、RedisCluster的高可用原理" class="headerlink" title="二、RedisCluster的高可用原理"></a>二、RedisCluster的高可用原理</h1><h2 id="1-RedisCluster的CAP"><a href="#1-RedisCluster的CAP" class="headerlink" title="1. RedisCluster的CAP"></a>1. RedisCluster的CAP</h2><p>RedisCluster本身是一个分布式NoSQL，因此必然符合CAP定理中的相关内容。</p>
<h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><p>CAP定理基本描述：</p>
<p>给定”一致性Consistency“、”可用性Availability“、”分区耐受性Partition tolerance”这三个属性，我们只能同时满足其中两个属性。</p>
<ul>
<li><p>分区耐受性：如果发生通信故障，导致整个集群被分隔成多个无法互相通信的分区时（这种情况也叫“脑裂” split brain），集群依然可用。</p>
<p>  在RedisCluster中有个参数cluster-require-full-coverage<br>  该参数取值为yes时，出现分区时则不可用；反之则不可用</p>
<p>  <img src="/images/redis_cluster/脑裂.png" alt="脑裂"></p>
</li>
<li><p><code>一致性</code>：在各个节点上数据一样。<br>  一致性的关键在于：将请求序列化，使之成为原子的（atomic）、相互隔离的（Isolated）”工作单元“（work unit）。</p>
</li>
<li><p><code>可用性</code>：如果客户可以同集群中的某个节点通信，那么该节点就必须能够处理读取及写入操作。<br>CAP定理中将可用性定义为：系统中某个无故障节点所接受的每一条请求，无论成功或失败，都必将得到响应。所以按照这个定义，发生故障且无法响应客户请求的节点，并不会导致系统失去“CAP定理”所定义的那种“可用性”。</p>
</li>
</ul>
<p>这意味着你可以构建一个CA集群，如果出现“分区”现象，那么所有节点必须全部停止工作。</p>
<p>尽管CAP定理经常表述为“三个属性中只能保有两个”，但实际上是在讲：当系统可能遭遇“分区”状况时，我们需要在“一致性”与“可用性”之间进行权衡。通常我们会略微舍弃“一致性”，以获取某种程度的“可用性”。这样产生的系统，既不具备完美的“一致性”，也不具备完美的“可用性”，但是这两种不完美的特性结合起来却能够满足特定需求。</p>
<h3 id="RedisCluster满足了AP，最终一致性"><a href="#RedisCluster满足了AP，最终一致性" class="headerlink" title="RedisCluster满足了AP，最终一致性"></a>RedisCluster满足了AP，最终一致性</h3><ol>
<li>分区耐受性：大多数节点可用时，RedisCluster可以分区可用。当出现分区时，连接到多数节点分区和连接到少数节点分区有很大不同。</li>
<li>可用性：通过复制转移（replicas migration），没有从节点的主节点会获得一个从节点，从而提供可用性。</li>
<li>高性能并且能够线性扩展到1000个节点。</li>
<li><p>最终一致性，异步复制，存在写入安全问题。</p>
<p> 最终一致性：eventually consistent：也就是说在任意时刻，节点中都可能存在“复制不一致”问题，然而只要不再继续执行其他更新操作，那么上一次更新操作的结果最终将会反映到全部节点中去。</p>
</li>
</ol>
<h3 id="RedisCluster写入的流程"><a href="#RedisCluster写入的流程" class="headerlink" title="RedisCluster写入的流程"></a>RedisCluster写入的流程</h3><p>RedisCluster的写入是异步复制。</p>
<ul>
<li>client先写入主，主回复<code>+OK</code>，此时client认为写入成功</li>
<li>主节点开始异步复制，将写入同步到从节点</li>
</ul>
<h3 id="RedisCluster写入安全"><a href="#RedisCluster写入安全" class="headerlink" title="RedisCluster写入安全"></a>RedisCluster写入安全</h3><ul>
<li>写入安全情况1:<br>  先写入主<br>  再由主传播到从。<br>  主从式分布模型，存在主写入成功，主挂没有传播<br>  从升为主，数据丢失。</li>
</ul>
<ul>
<li><p>写入安全情况2: 发生分区时写丢失</p>
<p>  举例：6节点集群，3主3从，节点是A,B,C, A1,B1,C1。还有一个客户端Z1。发生分区时，一个分区是A,C,A1,B1,C1，另外一个分区是B和Z1.此时Z1还可以向B写入，B也可以接收写操作。<br>  如果在很短时间内，B恢复了那么集群正常；<br>  如果分区持续太久，那么B1就被推举为新主，此时过了NODE_TIMEOUT时间，节点B也不写，那么分区后写入B的数据就丢失了。<br>  写操作丢失的最大持续时间是NODE_TIMEOUT+从推举时间</p>
<p>  NoSQL倡导者经常说，与关系型数据库所支持的ACID事务不同，NoSQL系统具备“BASE属性“（基本可用，柔性状态，最终一致性）英文是 Basically Available, Soft state, Eventual consistency.</p>
</li>
</ul>
<h2 id="2-容错-Fault-Tolerance"><a href="#2-容错-Fault-Tolerance" class="headerlink" title="2. 容错 Fault Tolerance"></a>2. 容错 Fault Tolerance</h2><h3 id="心跳包和流言消息"><a href="#心跳包和流言消息" class="headerlink" title="心跳包和流言消息"></a>心跳包和流言消息</h3><p>心跳包的目的：RedisCluster集群中各个节点会通过发送心跳包（ping包和pong包）来进行通信，更新集群的配置信息。通常节点发送ping包以后，期待对方回复pong包。</p>
<p>RedisCluster一个节点一次只向集群中某些节点发送心跳包（目前一次发送的节点数量是总节点个数的十分之一）。同时考虑到RedisCluster发送对象节点是随机的，所以存在两个节点很久都没有交换消息，为了保证集群状态能够在很多时间内达到一致性，RedisCluster规定当两个节点超过<code>NODE_TIMEOUT一半</code>的时间没有交换消息时，下次发心跳包交换消息。</p>
<p>比如，对于100个节点的集群，NODE_TIMEOUT设置为60秒，那么根据上面的理论，一个节点在30s内要向99个节点发送ping，对于100各节点则每秒发送330个pings。<a href="https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653547585&amp;idx=1&amp;sn=9a664b16f656f757632cd4eb29f9a5dc&amp;scene=0&amp;key=8dcebf9e179c9f3a346c582e0a5712dda1ec87878842175cce35a5ea1cd92ee99c770c79d2f99f97dcb43597000373f8&amp;ascene=0&amp;uin=NTE5MDc2ODU1&amp;devicetype=iMac+MacBookPro11%2C1+OSX+OSX+10.11.3+build(15D21" target="_blank" rel="noopener">近千节点的Redis Cluster高可用集群案例</a>&amp;version=11020201&amp;pass_ticket=4CBC9RgbSswvChRwX4aHuDwbNTxwAjmPNbOVneP4ac8%2BaS%2BQ8YWN5LJF3ipxB8fR)</p>
<p>通过这一点可以看出，集群间通信占用大量带宽资源。</p>
<h3 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h3><p>目的：当大多数节点不能访问某个主或从节点时，其从节点就会被推举为主节点。当从推举失败后，集群是error state, 将会停止接收来自客户端的请求。</p>
<p>实现：</p>
<ol>
<li>PFAIL状态：<br>集群中有n个节点，当节点A自己认为节点B不可用了，并不能认为节点B不可用，</li>
<li>FAIL状态：<br>必须集群中大多数节点认为节点B不可用了，节点B才是真的不可用。<br>当在<code>NODE_TIME * FAIL_REPORT_VALIDITY_MULT</code>时间内超过一半的节点认为B不可达时，节点B才真的是不可达<br>（当前实现中该validity参数是2）。<br> 节点不可达的概念：节点发送的ping包超过NODE_TIMEOUT时间依然收不到pong包。<br> 工作原理：当发送的ping包，在<code>NODE_TIMEOUT/2</code>时间后依然收不到pong包时，节点会去重连集群中的其他节点。</li>
<li>广播：<br>此时节点A会广播一条FAIL消息，告知大家节点B不可达。所有收到FAIL消息的节点，都被强制设定节点B不可达。<br> FAIL标志只是为了安全的触发从推举的算法。</li>
</ol>
<h3 id="故障转移-failover"><a href="#故障转移-failover" class="headerlink" title="故障转移 failover"></a>故障转移 failover</h3><ol>
<li><p>从节点选举</p>
<p> 从已经下线的主节点的所有从节点里面，选中一个从节点。从节点的选举需要得到大多数主节点的授权</p>
</li>
<li><p>成为主节点</p>
<p> 被选中的从节点会执行SLAVEOF no one命令，成为新的主节点并且负责旧主节点的槽位</p>
</li>
<li><p>广播</p>
<p> 广播一条pong消息，通知其他节点更新节点映射信息</p>
</li>
</ol>
<h3 id="复制转移-replicas-migration"><a href="#复制转移-replicas-migration" class="headerlink" title="复制转移 replicas migration"></a>复制转移 replicas migration</h3><p>复制转移的定义：如果一个主节点A没有从节点，而集群中有的主节点B有多个从节点s1,s2,s3；那么RedisCluster会从多个从节点中选择一个从节点作为主节点A的从节点。<br>复制转移的目的：为了提高系统的可用性。</p>
<p>比如一个集群中A,B,C 3个主节点，其从节点分别是A1,B1,C1,C2，其中C的从节点有两个。<br>当B挂了以后，B1升为主节点，此时B1节点没有从节点。</p>
<p>a. 如果没有复制转移的话，那么B1再挂了的话，这个节点上的槽位都不可用了。<br>b. 如果有复制转移的话，那么会从C的两个从节点C1和C2中选择一个作为B1的从节点，我们假设选择的是C2。那么现在集群的情况是A-A1，B1-C2，C-C1。如果这时候B节点又可用了，那么他将会作为某个主节点的从节点。</p>
<h2 id="4-配置操作、传播、故障转移"><a href="#4-配置操作、传播、故障转移" class="headerlink" title="4. 配置操作、传播、故障转移"></a>4. 配置操作、传播、故障转移</h2><h3 id="Cluster-currentEpoch"><a href="#Cluster-currentEpoch" class="headerlink" title="Cluster currentEpoch"></a>Cluster currentEpoch</h3><p>其目的是为了当节点信息发生冲突的时候来解决冲突。解决冲突的方法很简单，epoch高的配置覆盖epoch低的配置，即以epoch高的配置为准。</p>
<h3 id="configuration-epoch"><a href="#configuration-epoch" class="headerlink" title="configuration epoch"></a>configuration epoch</h3><ol>
<li>新节点创建时，configEpoch是0</li>
<li>从节点推举后，生成新的configEpoch，从节点尝试取代失败主节点的epoch，并且获得大多数主节点的授权，那么configEpoch会加1. </li>
<li>configEpoch帮助解决的是当不同节点声明不同配置配置时，用于解决冲突。</li>
</ol>
<p>RedisCluster配置参数：</p>
<pre><code>cluster-enabled 
cluster-config-file &lt;filename&gt;
cluster-node-timeout &lt;milliseconds&gt;
cluster-slave-validity-factor &lt;factor&gt;
cluster-migration-barrier &lt;count&gt;
cluster-require-full-coverage &lt;yes/no&gt;
</code></pre><h1 id="三、期间出现问题"><a href="#三、期间出现问题" class="headerlink" title="三、期间出现问题"></a>三、期间出现问题</h1><ol>
<li><p>客户端cluster slots没有缓存，造成RedisCluster节点cpu过高。</p>
<p> phpredis虽然是智能客户端，<br> 但对于每个RedisCluster类都需要发送<code>cluster slots</code>命令获取节点和slot的对应关系，从而造成节点CPU过高。<br> 因为<code>cluster slots</code>命令需要执行两层主循环，分别是循环nodes和slot。对于master节点还需要扫描slave，cpu的计算开销就出来了</p>
</li>
<li><p>timewait过高</p>
<p> 由于我们代码中设置100ms超时，当RedisCluster服务器返回过慢时，客户端会主动断开连接，因此出现大量timewait</p>
</li>
<li><p>为何不使用长连接。</p>
<p> a. 因为云盘前端机非常多，300台前端机，每台前端机128个进程，那么对于cluster节点而言是38400个长连接，cluster节点所占用的内存和fd开销非常大。<br> b. 长连接：cpu明显下降，但是连接数暴涨<br> c. 短连接：通过客户端缓存节点信息能够降低部分cpu，但cpu依然偏高</p>
</li>
<li><p>del返回warning</p>
<p>原因是del对返回值校验严格，要求必须是整形（即<code>:1</code>)这种格式，当出现<code>-MOVED</code>错误或者超时没有读取到数据时，则会报warning<br>出现时机：当RedisCluster的CPU过高时，del在100ms（设定的读超时是100ms）内没有响应，那么返回<code>?</code>的值，不是整形，因此会报warning</p>
</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="http://itindex.net/detail/52699-redis-cluster-failover" target="_blank" rel="noopener">Redis Cluster的FailOver失败案例分析</a></li>
<li><a href="http://itindex.net/detail/54098-redis-cluster-%E7%99%BE%E4%B8%87" target="_blank" rel="noopener">Redis 百万QPS挑战</a></li>
<li><a href="http://redis.io/topics/cluster-spec" target="_blank" rel="noopener">Redis Cluster Specification</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/08/10/RedisCluster总结/" data-id="ckw5yql47000zp8nuu8caeomp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nosql/">nosql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mysql锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/28/mysql锁/" class="article-date">
  <time datetime="2016-07-28T00:52:01.000Z" itemprop="datePublished">2016-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/28/mysql锁/">chapter6:mysql锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="6-1-什么是锁"><a href="#6-1-什么是锁" class="headerlink" title="6.1 什么是锁"></a>6.1 什么是锁</h2><p>锁机制用于管理对共享资源的并发访问</p>
<p>MyISAM引擎的锁是表锁。</p>
<p>InnoDB提供一致性的非锁定读、行级锁支持。行级锁没有相关额外开销，并可以同时得到并发性和一致性</p>
<h2 id="6-2-lock与latch"><a href="#6-2-lock与latch" class="headerlink" title="6.2 lock与latch"></a>6.2 lock与latch</h2><p>一般我们提到的是lock。lock的对象是事务，用来锁定的是数据库中的对象，如表，页，行。并且一般lock的对象只在事务commit和rollback后进行释放（不同隔离级别有所不同）。</p>
<p>latch的目的是用来保证并发线程操作临界资源的正确性，并且没有死锁检测的机制。</p>
<h2 id="6-3-InnoDB存储引擎中的锁"><a href="#6-3-InnoDB存储引擎中的锁" class="headerlink" title="6.3 InnoDB存储引擎中的锁"></a>6.3 InnoDB存储引擎中的锁</h2><h3 id="6-3-1-锁的类型"><a href="#6-3-1-锁的类型" class="headerlink" title="6.3.1 锁的类型"></a>6.3.1 锁的类型</h3><p>InnoDB实现了如下两种标准的行级锁：</p>
<pre><code>1. 共享锁（S Lock）允许事务读一行数据
2. 排他锁（X Lock）允许事务删除或更新一行数据
</code></pre><p>InnoDB支持意向锁，其意向锁即为表级别的锁。</p>
<h3 id="6-3-2-一致性非锁定读-consistent-nonlocking-read"><a href="#6-3-2-一致性非锁定读-consistent-nonlocking-read" class="headerlink" title="6.3.2 一致性非锁定读 consistent nonlocking read"></a>6.3.2 一致性非锁定读 consistent nonlocking read</h3><p>一致性非锁定读指InnoDB存储引擎通过行多版本控制的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此等待行上锁的释放，而是会读取行的一个快照数据。</p>
<p>快照数据是指该行的之前版本的数据，该实现是通过undo段来完成，undo段是用来在事务中回滚数据因此没有额外的开销。</p>
<p>在不同事务隔离级别下，读取方式的不同，并不是在每个事务隔离级别下都是采用非锁定的一致性读。此外，即使都是使用非锁定的一致性读，但是对于快照数据的定义也不相同。</p>
<p>在事务隔离级别READ COMMITTED和REPEATABLE READ下，InnoDB存储引擎使用非锁定的一致性读，但是快照数据定义不相同。在REPEATABLE READ隔离级别下，非一致性锁定读总是读取事务开始时的行数据版本。在READ COMMITTED下，总是读取被锁定行的最新一份快照数据。</p>
<h3 id="6-3-3-锁定读-locking-reads"><a href="#6-3-3-锁定读-locking-reads" class="headerlink" title="6.3.3 锁定读 locking reads"></a>6.3.3 锁定读 <a href="http://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html" target="_blank" rel="noopener">locking reads</a></h3><p>在某些情况下用户需要显式对数据库读取操作进行加锁以保障数据逻辑的一致性。即使对于SELECT的只读操作，也要支持加锁语句。</p>
<p>支持两种一致性的锁定读（locking read)操作：</p>
<pre><code>SELECT .. FOR UPDATE
SELECT .. LOCK IN SHARE MODE
</code></pre><h2 id="6-4-锁的算法"><a href="#6-4-锁的算法" class="headerlink" title="6.4 锁的算法"></a>6.4 锁的算法</h2><h3 id="6-4-1-行锁的3种算法"><a href="#6-4-1-行锁的3种算法" class="headerlink" title="6.4.1 行锁的3种算法"></a>6.4.1 行锁的3种算法</h3><p>InnoDB有3种行锁算法，其分别是：</p>
<pre><code>Record Lock：单个行记录上的锁
Gap Lock：间隙锁，锁定一个范围，但不包含记录本身
Next-Key Lock: Gap Lock + Record Lock 锁定一个范围并且锁定记录本身。
</code></pre><p>在默认隔离级别REPEATABLE READ下，使用的是Next-Key Lock。对于查询的索引含有唯一属性时，InnoDB会将Next-KeyLock进行优化，降级为RecordLock，即仅锁住索引本身，而不是范围。</p>
<p>而对于辅助索引，其加上Next-KeyLock InnoDB存储引擎还会辅助索引下一个键值加上gapLock，即会锁住这个辅助索引附近的两个范围。</p>
<h3 id="6-4-2-解决幻象问题"><a href="#6-4-2-解决幻象问题" class="headerlink" title="6.4.2 解决幻象问题"></a>6.4.2 解决幻象问题</h3><p>幻象是指在同一个事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次SQL可能会返回之前不存在的行。</p>
<p>在REPEATABLE READ下采用Next-key Lock加锁</p>
<p>在READ COMMITTED下 只是采用RecordLock。</p>
<h4 id="通过InnoDB存储引擎的Next-Key-Locking-机制在应用层面实现唯一性检查。"><a href="#通过InnoDB存储引擎的Next-Key-Locking-机制在应用层面实现唯一性检查。" class="headerlink" title="通过InnoDB存储引擎的Next-Key Locking 机制在应用层面实现唯一性检查。"></a>通过InnoDB存储引擎的Next-Key Locking 机制在应用层面实现唯一性检查。</h4><p>一个场景：想查询一下某个id是否存在，如果不存在则插入，如果存在则不插入。两种做法：外部加锁或者通过数据库。</p>
<p>数据库方式：</p>
<pre><code>select * from table where col = xx LOCK IN SHARE MODE;
if not found any row:
    # unique for insert value 需要是唯一索引，不然也存在多条插入的情况
    INSERT INTO table VALUES (...);
</code></pre><h2 id="6-5-锁问题"><a href="#6-5-锁问题" class="headerlink" title="6.5 锁问题"></a>6.5 <a href="http://keything.github.io/2016/01/09/mysql-%E9%94%81%E7%9A%84%E9%97%AE%E9%A2%98/">锁问题</a></h2><h3 id="6-5-1-脏读"><a href="#6-5-1-脏读" class="headerlink" title="6.5.1 脏读"></a>6.5.1 脏读</h3><p>脏读：指的是在不同事务下，当前事务可以读到另外事务未提交的数据</p>
<h3 id="6-5-2-不可重复读"><a href="#6-5-2-不可重复读" class="headerlink" title="6.5.2 不可重复读"></a>6.5.2 不可重复读</h3><p>不可重复读：指的是在一个事务内两次读到的数据不一样，多了或者少了数据。</p>
<h3 id="6-5-3-丢失更新"><a href="#6-5-3-丢失更新" class="headerlink" title="6.5.3 丢失更新"></a>6.5.3 丢失更新</h3><p>丢失更新：简单来说，就是一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据的不一致。<br>解决方法：让事务在这种情况下的操作变成串行化。比如使用select … FOR UPDATE.</p>
<h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><p>多版本技术：一个行记录可能有不止一个快照数据，称之为行多版本技术。</p>
<p>由此带来的并发控制，称之为多版本并发控制 multi version concurrency controll mvcc。</p>
<h2 id="6-6-参考文章"><a href="#6-6-参考文章" class="headerlink" title="6.6 参考文章"></a>6.6 参考文章</h2><ol>
<li><a href="http://dev.mysql.com/doc/refman/5.7/en/innodb-locking-transaction-model.html" target="_blank" rel="noopener">15.5 InnoDBlocking and Transaction Model</a></li>
<li>姜承尧 InnoDB存储引擎第二版 6.锁</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/07/28/mysql锁/" data-id="ckw5yql5c003pp8nu79t854di" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis与Memcache作为缓存时的比较" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/16/Redis与Memcache作为缓存时的比较/" class="article-date">
  <time datetime="2016-07-16T10:16:56.000Z" itemprop="datePublished">2016-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/16/Redis与Memcache作为缓存时的比较/">Redis与memcache作为缓存时的比较</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【说明一个大前提】我觉得拿Redis跟Memcache比较时，是把Redis当做缓存来用。不然一个是缓存一个是持久化，那么比较就失去意义了。</p>
<p>【本文目的】这篇文章是总结了大牛们关于Redis和Memcache的论断，加上部分自己的理解。</p>
<h3 id="1-Redis的性能比Memcache好。"><a href="#1-Redis的性能比Memcache好。" class="headerlink" title="1. Redis的性能比Memcache好。"></a>1. Redis的性能比Memcache好。</h3><p>Redis的QPS能够达到10w [数据来源]</p>
<p>Memcache的QPS在6w [数据来源 </p>
<h4 id="数据来源："><a href="#数据来源：" class="headerlink" title="数据来源："></a>数据来源：</h4><p><a href="http://antirez.com/news/94" target="_blank" rel="noopener">redis作者的声明</a></p>
<p><a href="http://timyang.net/data/mcdb-tt-redis" target="_blank" rel="noopener">memcache,redis性能测试</a></p>
<p>自己测试的话Redis选择<a href="http://redis.io/topics/benchmarks" target="_blank" rel="noopener">RedisBenchmark</a>，Memcache可以使用<a href="https://github.com/twitter/twemperf" target="_blank" rel="noopener">mcperf</a></p>
<h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><ol>
<li>Redis没有使用libevent作为事件处理函数库，而是自己造轮子。libevent因为通用牺牲了不少性能，没有epoll性能好<a href="http://rdc.gleasy.com/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%89%E5%9E%8B%E6%AF%94%E8%BE%83epolllibeventjava-mina2.html" target="_blank" rel="noopener">参考</a></li>
</ol>
<ol start="2">
<li>cas问题：CAS是Memcached中比较方便的一种防止竞争修改资源的方法。CAS实现需要为每个cache key设置一个隐藏的cas token，cas相当value版本号，每次set会token需要递增，因此带来CPU和内存的双重开销，虽然这些开销很小，但是到单机10G+ cache以及QPS上万之后这些开销就会给双方相对带来一些细微性能差别。</li>
</ol>
<h3 id="2-更多元化的方式使用Redis"><a href="#2-更多元化的方式使用Redis" class="headerlink" title="2. 更多元化的方式使用Redis"></a>2. 更多元化的方式使用Redis</h3><p>除了key/value的形式来使用Redis，还可以使用hash等数据形式。使用Hash更加节约空间。<a href="http://blog.nosqlfan.com/html/3379.html" target="_blank" rel="noopener">实践</a> <a href="http://redis.io/topics/memory-optimization" target="_blank" rel="noopener">理论</a></p>
<h3 id="3-Redis的内存效率更高"><a href="#3-Redis的内存效率更高" class="headerlink" title="3. Redis的内存效率更高"></a>3. Redis的内存效率更高</h3><p>   Redis中特殊编码的小型聚合值内存效率非常高<a href="http://redis.io/topics/memory-optimization" target="_blank" rel="noopener">内存优化</a></p>
<p>   真正的内存效率必须基于手头的应用案例来评估</p>
<h3 id="4-Redis禁用磁盘IO，纯内存操作"><a href="#4-Redis禁用磁盘IO，纯内存操作" class="headerlink" title="4. Redis禁用磁盘IO，纯内存操作"></a>4. Redis禁用磁盘IO，纯内存操作</h3><p>有一种论断是说 Memcached根本没有磁盘IO操作。实际上Redis禁用磁盘IO操作以后，也是纯内存操作。</p>
<h3 id="5-作为缓存时，redis-LRU-vs-Slab内存分配器"><a href="#5-作为缓存时，redis-LRU-vs-Slab内存分配器" class="headerlink" title="5. 作为缓存时，redis LRU vs Slab内存分配器"></a>5. 作为缓存时，redis LRU vs Slab内存分配器</h3><p>redis的LRU最近优化了很多，现在非常接近真正的LRU。进一步的信息可阅读： <a href="http://redis.io/topics/lru-cache" target="_blank" rel="noopener">lru-cache</a> 。如果我没理解错的话，Memcached的LRU依旧是根据它的slab分配器来判断数据过期的，因此有时其行为与真正的LRU相差甚远，但我希望这方面的专家能够针对这个问题说点什么。如果你想测试Redis的LRU，在最近几个版本的Redis中可以使用redis-cli的LRU测试模式</p>
<h3 id="6-Memcache的多线程对比Redis的单线程"><a href="#6-Memcache的多线程对比Redis的单线程" class="headerlink" title="6. Memcache的多线程对比Redis的单线程"></a>6. Memcache的多线程对比Redis的单线程</h3><p>Memcache是多线程的，在多核上能线性扩展到每秒处理100,000个请求。</p>
<p>如果我们将特殊用例下的Redis看做是Memcached的替代品，执行多个Redis进程也能反驳“Memcached多线程更好”这个观点，或者简单地执行一个Redis进程也行。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://timyang.net/data/redis-misunderstanding/" target="_blank" rel="noopener">Redis几点认识误区</a></p>
<p><a href="http://www.tuicool.com/wx/bmQFNjm" target="_blank" rel="noopener">关于Redis和Memcache的几点澄清</a></p>
<p><a href="http://redis.io/topics/memory-optimization" target="_blank" rel="noopener">redis内存优化</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/07/16/Redis与Memcache作为缓存时的比较/" data-id="ckw5yql480011p8nujmyd8idm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nosql/">nosql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-缓存替换" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/12/缓存替换/" class="article-date">
  <time datetime="2016-07-12T01:39:14.000Z" itemprop="datePublished">2016-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/12/缓存替换/">缓存替换</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="零-概述"><a href="#零-概述" class="headerlink" title="零 概述"></a>零 概述</h1><p>在业务中不可避免的需要使用缓存，当缓存数据很少时，只需要几台缓存服务器即可满足需求。 但是当业务增多时，就需要N个业务M个缓存服务器。缓存服务器不管使用memcache还是redis，都是需要业务方来管理缓存服务器的host和port。</p>
<p>我们业务中使用的memcache服务器接近千台，还需要业务方告知相关人员来处理memcache的问题（memcache机器宕机或者连接数打满）。而实际上，对于我们业务方而言，只需要使用缓存服务器即可，业务方不需要关注缓存服务器的重启和健康检查。当然了，业务方还是需要关注访问缓存服务器的访问时间。</p>
<h2 id="一-我们对缓存服务的要求"><a href="#一-我们对缓存服务的要求" class="headerlink" title="一 我们对缓存服务的要求"></a>一 我们对缓存服务的要求</h2><ol>
<li>单个请求耗时在2ms以内</li>
<li>能够抗住30w qps的压力</li>
</ol>
<h2 id="二-我们的尝试"><a href="#二-我们的尝试" class="headerlink" title="二 我们的尝试"></a>二 我们的尝试</h2><h3 id="I-首先尝试twitter的twemproxy"><a href="#I-首先尝试twitter的twemproxy" class="headerlink" title="I. 首先尝试twitter的twemproxy"></a>I. 首先尝试twitter的twemproxy</h3><ol>
<li><p>Twemproxy介绍</p>
<p> Twemproxy是一个使用C语言编写、以代理的方式实现的、轻量级的代理服务器，通过引入一个代理层，将应用程序后端的多台Redis实例进行统一管理，使应用程序只需要在Twemproxy上进行操作，而不用关心后面具体有多少个真实的Redis或Memcached实例，从而实现了基于Redis和Memcached的集群服务。当某个节点宕掉时，Twemproxy可以自动将它从集群中剔除，而当它恢复服务时，Twemproxy也会自动连接。<br> Twemproxy的缺点：1. 无法平滑地扩容/缩容， 2. 运维不友好，没有控制面板（对于业务方而言，这个不是问题）3. 经过一层代理，对性能有损耗。</p>
</li>
</ol>
<ol start="2">
<li><p>我们测试的结果</p>
<p> a. 压测方式一：</p>
<p> 使用twitter自家的<a href="https://github.com/twitter/twemperf" target="_blank" rel="noopener">mcperf</a>压测工具来压测twemproxy。</p>
<p> 压测命令：</p>
<pre><code>/bin/mcperf --timeout=0.2 --conn-rate=1000 --call-rate=5000000 --num-calls=1000 --num-conns=100 --sizes=u32,1024 -s 10.10.10.10 -p 11211
</code></pre><p> 压测结果：</p>
<p> |case| 直连memcache|连接twemproxy|<br> |—|—|—|<br> |数据在32字节和1k字节之间|57750 qps, 耗时100ms以内|25589 qps，耗时100ms以上非常多|<br> |数据在4k和8k字节之间|18156 qps | 12376 qps|</p>
<p> b. 压测方式二：使用n个php进程压测，这种压测方法并不能够得到一个<code>mcperf</code>的准确的qps，但是更接近我们的应用场景，也能够看出一些问题。这种方式压测中发现的问题：</p>
<p> 1) twemproxy所在机器TIME_WAIT和CLOSE_WAIT非常高<br> 2) 单次请求耗时增加，连接twemproxy的qps小于直连memcache</p>
<p> <code>TIME_WAIT</code>及<code>CLOSE_WAIT</code>非常高的原因：</p>
<p>  php端设置超时时间是100ms，即server端100ms内没有响应时，php端就会主动断开连接。上面提到mcperf压测时超过100ms的请求非常多，那么100ms没有收到响应时php段就会主动断开连接。由于twemproxy服务器过于繁忙，没有调用close从而导致twemproxy处于<code>CLOSE_WAIT</code>状态。</p>
<p> 对于<code>TIME_WAIT</code>而言，则是twemproxy向memcache服务器发送请求，等待某个时间（twemproxy中设置），如果没有响应，twemproxy就会主动断开连接；当大量从twemproxy到达memcache的请求超时时，就会出现<code>TIME_WAIT</code>过多。</p>
</li>
</ol>
<h3 id="II-可以考虑方案"><a href="#II-可以考虑方案" class="headerlink" title="II 可以考虑方案"></a>II 可以考虑方案</h3><p>我们将可以考虑的方案列一下，360的bada，360的<a href="https://github.com/Qihoo360/pika" target="_blank" rel="noopener">pika</a>，豌豆荚的<a href="https://github.com/CodisLabs/codis" target="_blank" rel="noopener">codis</a>。 </p>
<p>先来说一下豌豆荚的codis，它跟twemproxy一样都是经过一层代理，首先经过一层代理必然会造成一定的性能损耗，其次在内存拷贝上codis并没有进行优化，官方开发者spinlock在<a href="https://github.com/CodisLabs/codis/issues/309" target="_blank" rel="noopener">答疑</a>中提到:a. <code>twemproxy只有redis性能一半</code>, b. <code>codis比twemproxy慢</code>。</p>
<p>也就是说，不管是twemproxy还是codis，这种经过一层代理的方式都会造成一定的性能损耗；并且在高并发的情况下，代理会带来更多的问题；综合考虑，我们不使用这种代理的方式</p>
<p>再来说一下公司的pika，数据存在硬盘并且底层是rocksdb，单个请求和并发都不满足需求。</p>
<p>再来说一下公司的bada，qps在10w以上，但是平均耗时比redis多。</p>
<p>综合考虑，我们决定测试一下RedisCluster，看是否满足我们的需求。</p>
<h3 id="III-RedisCluster"><a href="#III-RedisCluster" class="headerlink" title="III RedisCluster"></a>III RedisCluster</h3><ol>
<li>压测环境<br>Redis3.0.5版的<a href="https://github.com/antirez/redis/issues/2191" target="_blank" rel="noopener">Redis-benchmark并不支持对RedisCluster的压力测试</a>。看了一下常见的压测工具都没有直接对RedisCluster进行压测的工具。没有办法，只好使用25台测试机，单机进程总数，每个进程请求数量10w个，通过日志记录每个请求的耗时时间，对日志进行分析。</li>
<li><p>qps粗略计算</p>
<p> 采用php直接压测，qps的粗略计算：</p>
<pre><code>机器数*每台机器的php进程数*1000（1s=1000ms)/ 单个请求耗时（单位ms）
</code></pre><p> 如果单次请求是5ms，则预计是<code>25*5*1000/5=2.5w</code></p>
<p> 当然还可以通过redis-trib.rb得到，将数字部分累加即可。</p>
<pre><code>$./redis-trib.rb call 10.138.113.202:16001 info | grep -iE &quot;instantaneous_ops_per_sec&quot;

instantaneous_ops_per_sec:3963
instantaneous_ops_per_sec:3842
instantaneous_ops_per_sec:4219
instantaneous_ops_per_sec:3590 
</code></pre><p> 对RedisCluster，Memcache，Redis进行压力测试，主要是测试在高并发情况下三者的耗时。耗时位于0-5ms的比例Redis好于Memcache好于Cluster。解释：</p>
<p> 因为RedisCluster在创建对象的时候需要发送<code>cluster slots</code>命令获取一次集群的节点信息，导致耗时比redis和memcache要久。当然这也是其比memcache明智的地方， 因为memcache需要业务方维护一份节点信息，一旦需要更换节点，则需要业务方进行更改；而cluster的节点信息是由cluster的管理员维护。</p>
<p> 对于单个http请求而言，与memcache和Redis相比，只是多了获取节点信息的操作</p>
</li>
<li><p>压测中发现<a href="https://github.com/phpredis/phpredis" target="_blank" rel="noopener">phpredis驱动</a>的一个问题：</p>
<p> 压测过程中发现单个redis-cluster节点接受cluster-slots命令是4000qps.（该命令获取集群节点映射信息），当大于4000qps时，耗时就会急剧增加。</p>
<p> 对于这个问题，可以通过增加cluster节点来解决。</p>
<p> 当然最好的方法是修改phpredis的cluster驱动，能够缓存cluster节点信息，不用每次创建对象的时候都发送clusterslots命令</p>
</li>
</ol>
<h2 id="我们最后的选择"><a href="#我们最后的选择" class="headerlink" title="我们最后的选择"></a>我们最后的选择</h2><ol>
<li><p>基于上面的压测，我们决定使用RedisCluster，原因有二：</p>
<p> a. 对于单个http请求（里面可能有多个缓存操作）而言，相比直连memcache或者redis，只是多了一步获取节点信息的耗时，耗时在2ms左右，这点性能损耗我们是可以忍受的。</p>
<p> b. 对于DBA而言，维护简单，扩容方便；对于业务方而言，我只需要获取RedisCluster的一个节点进行连接即可，跟使用普通Redis差别不大。 </p>
</li>
<li><p>使用RedisCluster中存在的问题</p>
<p> 前端机连接RedisCluster使用短连接，因此造成前端机TIMEWAIT过高，从而导致大量的连接超时。这儿要说明两个问题，第一个是为何使用短连接，因为使用长连接的话就不会存在TIMEWAIT过高的问题。第二个是TIMEWAIT过高的解决方式。</p>
<p> 问题1：使用短连接而不使用长连接</p>
<p> 原因是：使用长连接可能造成前端机或cluster机器端口不够用</p>
<p> 先确定采用长连接时Cluster服务器连接数的计算方式：<code>前端机数量*每台前端机fpm进程数量</code>。如果前端机数量非常多，比如300台，每台前端机fpm128个，那么与某台cluster建立的长连接数量是38400，会造成cluster上连接数过多。<br> 而对于前端机而言，则可能会造成端口不够用。端口范围由net.ipv4.ip_local_port_range决定）。<br> 为了避免出现这个问题，我们使用短连接而不是长连接</p>
<p> 问题2：TIMEWAIT</p>
<p> TIMEWAIT出现原因：发送方主动断开连接时，收到接收方发来的FIN以后处于的状态，这是TCP四次挥手的正常状态。但是由于TIMEWAIT状态时，连接依然占有端口和fd，因此可能会出现端口不够用或套接字不够用的情况，从而导致连接失败。<br> TIMEWAIT解决方法：我们采用的是修改net.ipv4.tcp_max_tw_buckets = 5000。</p>
</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/CodisLabs/codis/issues/309" target="_blank" rel="noopener">codis, redis, twemproxy对比</a></p>
<p><a href="http://chuansong.me/n/1271889" target="_blank" rel="noopener">redis cluster浅析与bada对比</a></p>
<p><a href="http://www.infoq.com/cn/articles/effective-ops-part-03" target="_blank" rel="noopener">Redis集群技术及Codis实践</a></p>
<p><a href="https://github.com/phpredis/phpredis/blob/develop/README.markdown" target="_blank" rel="noopener">PhpRedis集群介绍</a></p>
<p><a href="https://github.com/antirez/redis/issues/2191" target="_blank" rel="noopener">redis-benchmark cannot work on Redis Cluster</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/07/12/缓存替换/" data-id="ckw5yql66005gp8nu87ny2yvn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nosql/">nosql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-内核参数-tcp-syncookies" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/09/内核参数-tcp-syncookies/" class="article-date">
  <time datetime="2016-07-09T13:05:09.000Z" itemprop="datePublished">2016-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/09/内核参数-tcp-syncookies/">内核参数 tcp_syncookies-- 默认开启tcp_syncookies</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>提问：<br>基于下面的信息，是否可以默认开启<code>/proc/sys/net/ipv4/tcp_syncookies</code>。缺点呢？</p>
<p>一种流行的服务攻击是给你的服务器发送许多（可能伪造的）的SYN包，但从不通过三次握手完成TCP请求。这样很快用尽内核中半打开队列（unp中叫 incompelete connection queue), 阻止了合法连接的完成。因为一个连接不需要完成，那么被攻击机器上就不需要资源，那么这就很容易处理和维护了。</p>
<p>如果设置了<code>tcp_syncookies</code>变量（需要内核使用<code>CONFIG_SYNCOOKIES</code>编译），那么在队列满的时候，内核也能够处理TCP SYN包了，这就是SYN cookie功能的关键所在。</p>
<p>SYN cookie完全不使用SYN队列就能工作。正常的情况，内核会发送SYN|ACK作为对SYN包的响应，但是，SYN cookie是发送一个特定的TCP 序号，这个序号是对<code>源地址</code>，<code>目的地址</code>，<code>源端口</code>，<code>目的端口</code>和<code>发送包的时间</code>的编码。一个执行SYN 洪水的攻击者拿不到这个包，也就没法响应。一个合法的连接将会包含这个序号来发送三次握手中的第三个包，服务器将会确认这个包是对合法SYN cookie的响应，并允许建立连接，即使在SYN队列中没有对应的位置了。</p>
<p>开启SYN cookie是一种抵御SYN洪水攻击的简单方式，只是多了一点建立cookie和确认cookie的CPU时间。相比拒绝所有到来的连接，开始SYNcookie是一种明智的选择。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.redhat.com/archives/rhl-devel-list/2005-January/msg00447.html" target="_blank" rel="noopener">https://www.redhat.com/archives/rhl-devel-list/2005-January/msg00447.html</a><br><a href="https://ckdake.com/content/2007/disadvantages-of-tcp-syn-cookies.html" target="_blank" rel="noopener">https://ckdake.com/content/2007/disadvantages-of-tcp-syn-cookies.html</a><br><a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">http://coolshell.cn/articles/11564.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/07/09/内核参数-tcp-syncookies/" data-id="ckw5yql610054p8nuew8lbcxr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tcp/">tcp</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-php的memcache客户端的几点说明" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/03/php的memcache客户端的几点说明/" class="article-date">
  <time datetime="2016-07-03T12:55:17.000Z" itemprop="datePublished">2016-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/03/php的memcache客户端的几点说明/">php的memcache客户端的几点说明</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一-超时时间"><a href="#一-超时时间" class="headerlink" title="一. 超时时间"></a>一. 超时时间</h2><ol>
<li><p>对于php的memcache客户端，当客户端认为memcached服务器端超时的时候，客户端会主动断开与memcached服务器之间的连接。</p>
</li>
<li><p>对于php的mecache客户端，这个超时时间并不是最低只能是1秒。<a href="http://php.net/manual/zh/memcache.addserver.php" target="_blank" rel="noopener">http://php.net/manual/zh/memcache.addserver.php</a> 中写到timeout的单位是秒，默认是1秒。可是我们可以通过修改变量来调整超时时间。 【<a href="http://tech.uc.cn/?p=326" target="_blank" rel="noopener">http://tech.uc.cn/?p=326</a> 文章中的关于超时时间的论断是错误的】</p>
<pre><code>ini_set(&quot;memcache.default_timeout_ms&quot;, 1000);
</code></pre></li>
</ol>
<h2 id="二-失败重连机制"><a href="#二-失败重连机制" class="headerlink" title="二. 失败重连机制"></a>二. 失败重连机制</h2><p>先提出两个问题，第一个问题：</p>
<pre><code>有n个memcache服务器的时候，某一个server失败了，
那么还会重试下一个server么？
哪些操作会重试下一个server？
</code></pre><p>第二个问题：</p>
<pre><code>当n个server都失败的时候，
会影响到之后的其他操作么？
</code></pre><p>这两个问题，稍后会给出详细的解释。</p>
<h2 id="三-实践前基础知识"><a href="#三-实践前基础知识" class="headerlink" title="三. 实践前基础知识"></a>三. 实践前基础知识</h2><ol>
<li>tc命令控制网络延时</li>
</ol>
<pre><code> tc qdisc add dev eth0 root netem delay 100ms 所有请求都延时100ms

tc qdisc del dev eth0 root netem delay 100ms 删除所有请求都延时100ms的限制
</code></pre><ol start="2">
<li><p>实践的php代码</p>
<p> 有两台memcache服务器，分别是10.16.57.128和10.16.57.191. </p>
<pre><code>// test_mc.php
&lt;?php
function catchErrHandler($level, $msg, $file, $line)
{
    switch ($level)
    {
    case E_NOTICE:
        $hhh = __METHOD__.__LINE__.&apos;|pid=&apos;.getmypid().&apos;notice&apos;.&apos;|msg=&apos;.$msg.microtime(true).&quot;\n&quot;;
        echo $hhh;
        error_log($hhh,3,&apos;/tmp/yk.log&apos;);
        //exit;
        break;
    default:
        error_log(&apos;default&apos;.__METHOD__.__LINE__.&apos;|pid=&apos;.getmypid().&apos;notice&apos;.&apos;|msg=&apos;.$msg.microtime(true).&quot;\n&quot;,3,&apos;/tmp/yk.log&apos;);
        break;
    }
}
ini_set(&quot;memcache.default_timeout_ms&quot;, 99);
ini_set(&apos;memcache.allow_failover&apos;, 1);
set_error_handler(&apos;catchErrHandler&apos;);
$mcobj = new Memcache();
$mcobj-&gt;addServer(&apos;10.16.57.191&apos;, 11211);
$mcobj-&gt;addServer(&apos;10.16.57.128&apos;, 11211);
$pid = getmypid();
$max_qid = 1;
for ($qid = 0; $qid &lt; $max_qid; $qid++)
{
    $start = microtime(true);
    $key = &apos;task_lock&apos; . $qid;
    echo $key . &quot;\n&quot;;
    $value = $mcobj-&gt;set($key, 1, 300);
    $end = microtime(true);
    $consume = $end - $start;
}
</code></pre></li>
</ol>
<h2 id="四-实践"><a href="#四-实践" class="headerlink" title="四. 实践"></a>四. 实践</h2><ol>
<li><p>当一个server失败了，会尝试下一个server么？</p>
<p> memcache客户端关于重试failover有两个设置：</p>
<pre><code>memcache.allow_failover boolean 是否在发生错误时（对用户）透明的转移到其他服务器。
memcache.max_failover_attempts integer 定义在写入和获取数据时最多尝试的服务器次数（即：故障转移最大尝试数），仅和 memcache.allow_failover结合使用。
</code></pre><p> 如果设置 <code>ini_set(&#39;memcache.allow_failover&#39;, 1);</code>那么会重试下一个server。</p>
</li>
<li><p>哪些操作会去重试下一个呢？</p>
<p> 从源码来看，php的memcache客户端发送<code>set/add/replace</code>指令的时候会先判断server可用不，如果不可用则走failover，如果只有一台memcache服务器，那么这个逻辑就忽略。<br>因为server不可用，那么在之后的逻辑就不会发送请求。</p>
<p> 从实践来看，<code>get</code>操作也会走failover，这也就是 <a href="http://tech.uc.cn/?p=326" target="_blank" rel="noopener">http://tech.uc.cn/?p=326</a> 文章中提到的memcache的分布式问题。</p>
<p> 实践步骤：</p>
<p> a. 两台memcache机器，10.16.57.128，10.16.57.191。<br> 10.16.57.191这台机器延时100ms 命令：<code>sudo tc qdisc add dev eth0 root netem delay 100ms</code>。</p>
<p> b. 执行test_mc.php代码</p>
<p> 通过wireshark抓包可以看到，10.16.57.191在三次握手的时候，客户端直接发了RST。然后failover，跟10.16.57.128进行三次握手，之后发送set请求，memcache服务器对其进行处理并返回STORED。add, replace, get操作也是一样的会进行failover。</p>
<p> <img src="/images/php_memcache/set.png" alt="set"><br> <img src="/images/php_memcache/replace.png" alt="replace"><br> <img src="/images/php_memcache/get.png" alt="get"></p>
</li>
</ol>
<ol start="3">
<li><p>当两个memcache服务器都失败的时候呢？？</p>
<p> retry_interval是服务器连接失败时重试的间隔时间，默认值15秒。一旦一个连接失败，他将会被成功重新连接，或者被标记为失败连接并等待retry_interval秒后再践行一次重连。即，当memcache客户端将server的连接标识为失败以后，在retry_interval时间内都不会再次建立连接，而是直接返回false。</p>
<p> 实践步骤：</p>
<p> a. 两台memcache机器， 10.16.57.128，10.16.57.191。<br> 10.16.57.191和10.16.57.128两台机器延时100ms 命令：<code>sudo tc qdisc add dev eth0 root netem delay 100ms</code>。</p>
<p> b. 执行test_mc.php代码</p>
<p> 通过wireshark抓包可以看到，客户端分别对两个memcache服务器发送RST，之后并没有请求再发出，而是直接返回了false</p>
<p> <img src="/images/php_memcache/all_failed.png" alt="不会进行重试"></p>
</li>
</ol>
<h2 id="五-连接twemproxy和连接memcache"><a href="#五-连接twemproxy和连接memcache" class="headerlink" title="五. 连接twemproxy和连接memcache"></a>五. 连接twemproxy和连接memcache</h2><p>连接twemproxy和直接连接memcache时的failover情况：</p>
<ol>
<li><p>php直连memcache时</p>
<p> 三次握手时间超过设置的超时时间，使用pconnect、addserver和connect三种方式都能准确failover</p>
<p> 即直连memcache时，长短连接都能够准确failover。</p>
</li>
<li><p>php连接twemproxy时，</p>
</li>
</ol>
<p>如果只有一台twemproxy（或者通过lvs连接twemproxy集群），即addServer的时候只有一个ip:port，那么不会走failover。</p>
<p>a. PHP设定的timeout 大于 twemproxy的timeout，memcache故障实体机可以及时剔除，connect不出现false，但是pconnect和addserver进程队列里的将继续false很久后才恢复到true；原因：</p>
<pre><code>虽然twemproxy已经剔除故障机，但是只有一个ip:port, 对于php的memcache客户端而言，他就认为这个ip:port的连接不可用，那么需要在retry_interval时间以后才会发送请求。

对于短连接connect而言，则是新建连接，则不存在这个问题。
</code></pre><p>b. PHP设定的timeout &lt; twemproxy的timeout，mc故障实体机不一定及时剔除，pconnect、addserver和connect都将继续false很久后才恢复到true。</p>
<h2 id="六-出现问题"><a href="#六-出现问题" class="headerlink" title="六. 出现问题"></a>六. 出现问题</h2><ol>
<li><p>当切换到twemproxy的时候，发现大量的key写入失败，原因是前端机（跑着php的memcache客户端的机器）的TIME_WAIT非常高，twemproxy机器的TIME_WAIT和CLOSE_WAIT都非常高。</p>
</li>
<li><p>twemproxy机器的TIME_WAIT达到18W， CLOSE_WAIT（被动关闭）也非常高。</p>
<p> TIME_WAIT高的原因是，twemproxy没有收到memcache服务器的响应，主动断开连接。<br>CLOSE_WAIT高的原因是，php的memcache客户端没有收到twemproxy服务器的响应，断开连接，造成twemproxy服务器的CLOSE_WAIT过高， 就是客户端主动关闭，服务器端没有快速响应，因此处于CLOSE_WAIT。</p>
</li>
</ol>
<h2 id="七-解决方案"><a href="#七-解决方案" class="headerlink" title="七. 解决方案"></a>七. 解决方案</h2><ol>
<li><p>调整内核参数解决TIME_WAIT过高的问题</p>
<pre><code>net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_tw_recycle = 0
net.ipv4.tcp_max_tw_buckets = 5000
</code></pre></li>
<li><p>CLOSE_WAIT过高的问题，没有解决</p>
</li>
<li><p>对于twemproxy，可能是我们的使用方式有问题，在使用的过程中出现了twemproxy机器的TIME_WAIT和CLOSE_WAIT都过高，影响服务，因此我们没有使用twemproxy。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/07/03/php的memcache客户端的几点说明/" data-id="ckw5yql5q004fp8nuf6gdddl8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nosql/">nosql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Index-Condition-Pushdown-优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/26/Index-Condition-Pushdown-优化/" class="article-date">
  <time datetime="2016-06-26T00:24:56.000Z" itemprop="datePublished">2016-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/26/Index-Condition-Pushdown-优化/">Index Condition Pushdown 优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Index Condition Pushdown是一种优化，针对的是使用索引去表中获取记录rows的优化。没有ICP的话，存储引擎遍历索引来定位数据表中的记录（rows），并将其返回给Mysql的server层，在server层对所获取的记录进行WHERE条件的过滤。<br>开启ICP后，如果WHERE条件中的某些字段刚好是索引中的字段，那么Mysql的server层会将这些字段下放到存储引擎，存储引擎会使用这些WHERE条件进行过滤，只有满足这些字段的条件，存储引擎才会去数据表中读取整行记录。</p>
<p>ICP的优点就是：减少了存储引擎到达数据表的次数，以及MySQL server层到达存储引擎的次数。</p>
<p>能够使用ICP优化的索引：range，ref， eq_ref和ref_or_null。这些索引都需要获取全表的记录。<br>能够使用ICP优化的引擎：InnoDB和MyISAM。注意 在MySQL5.6的分区表中不支持，MySQL5.7中支持。<br>注意：只支持辅助索引。因为ICP优化的目标：减少读取整行的次数，从而降低了IO操作。对于InnoDB的聚簇索引，已经读取了整行记录，因此使用ICP并不会降低IO。</p>
<p>优化器没有使用ICP时，数据访问和提取的过程如下：</p>
<pre><code>1) 当storage engine读取下一行时，首先读取一个索引，然后使用索引在数据表中定位和读取整行数据。
2) sever层评估where条件，如果该行数据满足where条件则使用，否则丢弃。
3) 执行1），直到最后一行数据。
</code></pre><p><img src="/images/no_icp.png" alt="no-icp"></p>
<p>优化器使用ICP时，server层会将WHERE条件中某些字段（这些字段在索引中）下推到storage engine层。数据访问和提取过程如下：</p>
<pre><code>1) storage engine从索引中读取下一条索引。
2) storage engine使用索引评估下推的索引条件。如果没有满足wehere条件，则回到1）。只有当索引满足下推的索引条件的时候，才会继续去数据表中读取数据。
3) 如果满足WHERE的索引条件，storage engine通过索引定位数据表的行和读取整行数据并返回给server层。
4) server层评估没有被下推到storage engine层的where条件，如果该行数据满足where条件则使用，否则丢弃。
</code></pre><p><img src="/images/icp.png" alt="icp"></p>
<p>举例来说明：一个表中包含一个人和其地址信息，表中有一个索引(zipcode, lastname, firstname)。如果我们知道一个人的zipcode，但不确定其lastname，因此可以像下面一样进行查询</p>
<pre><code>SELECT * FROM peope WHERE zipcode = &apos;95054&apos; 
AND lastname LIKE &apos;%etrunica%&apos;
AND address LIKE &apos;%Main Street%&apos;;
</code></pre><p>zipcode = ‘95054’可以使用索引，但是第二部分lastname LIKE ‘%etrunica%’，不使用ICP时不能限制需要扫描的记录的行数，需要获取所有满足zipcode = ‘95054’的所有用户记录。</p>
<p>如果使用ICP，在去数据表读取整行记录之前，MYSQL会检查lastname LIKE ‘%etrunica%’部分。这样避免了去读取不满足lastname 这个条件的数据记录。</p>
<p>默认ICP是开启的。可以通过index_condition_pushdown来设置。</p>
<pre><code>set optimizer_switch=&apos;index_condition_pushdown=off&apos;;
</code></pre><p>特别注意：</p>
<ol>
<li>ICP只能用于二级索引，不能用于主索引</li>
<li>也不是全部where条件都可以用ICP筛选，如果某where条件的字段不在索引中，当然还是要读取整条记录做筛选，在这种情况下，仍然要到server端做where筛选。</li>
<li>ICP的加速效果取决于在存储引擎内通过ICP筛选掉的数据的比例</li>
<li>概括之：对于完全命中索引的查询，不需要ICP。比如索引是idx_abc(a,b,c)。查询是where a = 1 and b = 2 则不需要ICP。如果查询是 where a = 1 and b &gt; 3 则会使用ICP.</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="http://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html</a></li>
<li><a href="http://ourmysql.com/archives/1351" target="_blank" rel="noopener">http://ourmysql.com/archives/1351</a></li>
<li><a href="http://mdba.cn/?p=315" target="_blank" rel="noopener">http://mdba.cn/?p=315</a></li>
<li><a href="https://mariadb.com/kb/en/mariadb/index-condition-pushdown/" target="_blank" rel="noopener">https://mariadb.com/kb/en/mariadb/index-condition-pushdown/</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/06/26/Index-Condition-Pushdown-优化/" data-id="ckw5yql3v000cp8nuuftk9bdy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis内存优化-聚合数据类型的特殊编码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/10/Redis内存优化-聚合数据类型的特殊编码/" class="article-date">
  <time datetime="2016-06-10T00:24:56.000Z" itemprop="datePublished">2016-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/10/Redis内存优化-聚合数据类型的特殊编码/">Redis内存优化之小的聚合数据类型的特殊编码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Redis内存优化之小的聚合数据类型的特殊编码"><a href="#Redis内存优化之小的聚合数据类型的特殊编码" class="headerlink" title="Redis内存优化之小的聚合数据类型的特殊编码"></a>Redis内存优化之小的聚合数据类型的特殊编码</h2><p>从Redis2.2开始，很多数据类型被优化为使用更小的空间。对于由数字组成的Hashes，Lists， Sets，Sorted Sets 在某些情况下可以使用使用更加有效的内存方式来进行编码，这种更有效的内存方式可以节约最少5倍最大10倍的内存。那么在什么情况这些数字组成的类型可以使用这种更有效的内存方式呢?</p>
<pre><code>当元素个数小于给定的数量时，
当到了一个最大的元素大小时，
</code></pre><p>从用户和API角度来看，这完全是透明的。因为这是一种CPU/内存的平衡。可以使用redis.conf中的指令来调整元素的最大个数和最大的元素大小。</p>
<pre><code>hash-max-zipmap-entries 512 (hash-max-ziplist-entries for Redis &gt;= 2.6)
hash-max-zipmap-value 64  (hash-max-ziplist-value for Redis &gt;= 2.6)
list-max-ziplist-entries 512
list-max-ziplist-value 64
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
set-max-intset-entries 512
</code></pre><p>如果一个特定编码值超过了设置的最大值，Redis被自动将其转为普通编码。这个转换过程，对于小的取值非常快，但如果你为了使用特殊编码值而改变了配置，那么就需要允许压力测试来测试这个转换时间了。 </p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>进行三个实践。</p>
<p>第一个使用key/value的形式存储1w个数据，占用空间608175字节。</p>
<p>第二个使用hash的形式存储1w个数据，占用空间79424字节</p>
<ol>
<li>采用k/v形式</li>
</ol>
<pre><code>#! /bin/bash

redis-cli info|grep used_memory:

for (( start = 10000; start &lt;20000 ; start++ ))
do
    redis-cli set $start 100 &gt; /dev/null
done

redis-cli info|grep used_memory:
</code></pre><ol start="2">
<li>采用hash形式</li>
</ol>
<pre><code>#! /bin/bash

redis-cli info|grep used_memory:

for (( start = 10000; start &lt; 20000 ; start++ ))
do
    hash=$((start % 100))
    redis-cli hset $hash $start 100 &gt; /dev/null
done

redis-cli info|grep used_memory:
</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://redis.io/topics/memory-optimization" target="_blank" rel="noopener">redis内存优化</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/06/10/Redis内存优化-聚合数据类型的特殊编码/" data-id="ckw5yql490014p8nui6arzvzw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nosql/">nosql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-php发送邮件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/25/php发送邮件/" class="article-date">
  <time datetime="2016-05-25T08:31:31.000Z" itemprop="datePublished">2016-05-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/25/php发送邮件/">php发送邮件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="0-概述"><a href="#0-概述" class="headerlink" title="0. 概述"></a>0. 概述</h2><p>php manual中关于mail的介绍很简单，</p>
<pre><code>@param to 电子邮件收件人或收件人列表
@param subjct 电子邮件的主题 也就是收件人或收件人列表
@param message 所要发送的消息 
@return true if the mail was successfully accepted fro delivery, FALSE otherwise
bool mail ( string $to , string $subject , string $message [, string $additional_headers [, string $additional_parameters ]] )
</code></pre><h2 id="0-我的代码"><a href="#0-我的代码" class="headerlink" title="0. 我的代码"></a>0. 我的代码</h2><p>根据邮件协议，使用基本的php代码进行编写，直接包含这个类即可使用</p>
<h2 id="1-发送html"><a href="#1-发送html" class="headerlink" title="1. 发送html"></a>1. 发送html</h2><ol>
<li>发送html就是将正文的message以文本格式发送<h2 id="2-发送附件"><a href="#2-发送附件" class="headerlink" title="2. 发送附件"></a>2. 发送附件</h2></li>
<li><p>附件需要以multipart/form-data的格式进行组装，这儿与web上传form表单的格式一样。例子如下</p>
<pre><code>--==Mime_Multipart_Boundary_x69c8f8864502559be8e17a0cb379ff0cx
Content-Transfer-Encoding: base64

54eV5YevQm9keQoKCgo=

--==Mime_Multipart_Boundary_x69c8f8864502559be8e17a0cb379ff0cx
X-Attachment-Id: 15259
Content-Transfer-Encoding: base64
Content-Type: application/octet-stream; name=&quot;keything.txt&quot;
Content-Disposition: attachment; filename=&quot;keything.txt&quot;

54eV5Yev

--==Mime_Multipart_Boundary_x69c8f8864502559be8e17a0cb379ff0cx--
</code></pre></li>
<li>我们所发出的数据就如上面文本所示，因此要将其组装</li>
</ol>
<ol start="3">
<li><p>class KTMail</p>
<pre><code>&lt;?php
class KTMail
{
    const UTF8_PREFIX  = &apos;=?UTF-8?B?&apos;;
    const UTF8_POSTFIX = &apos;?=&apos;;
    const RN = &quot;\r\n&quot;;
    /**
     * @param from: who send this mail
     * @param to: who receive this mail
     * @param subject: the title of mail
     * @param body: the content of mail
     * @param attachment_fname: the file name of attachement
     * @param attachment_fdata: the file content of attachment
     * @return true if send succeed, FALSE otherwise
     * TODO if attachment_fname is chinese, it will be messay code.
     */
    public static function sendWithAttach($from, $to, $subject, $body, $attachment_fname, $attachment_fdata)
    {
        // a random string 
        $semi_rand = md5(time()); 
        $mime_boundary = &apos;==Mime_Multipart_Boundary_x&apos; . $semi_rand . &apos;x&apos;;
        $part_boundary = &apos;==Part_Multipart_Boundary_x&apos; . $semi_rand . &apos;x&apos;;

        // header 
        $headers = [];
        $headers[] = &apos;MIME-Version: 1.0&apos;;
        $headers[] = &apos;Content-Type: multipart/mixed; boundary=&apos; . $mime_boundary;
        $headers[] = &apos;From: &apos; . $from;
        $headers_raw = implode(self::RN, $headers);

        // Message Body
        $msg = [];
        $msg[] = &apos;--&apos; . $mime_boundary;
        $msg[] = &apos;Content-Transfer-Encoding: base64&apos; . self::RN;
        $msg[] =  chunk_split(base64_encode($body));

        // Attachment
        $msg[] = &apos;--&apos; . $mime_boundary;
        $msg[] = &apos;X-Attachment-Id: &apos; . rand(1000, 99999);
        $msg[] = &apos;Content-Transfer-Encoding: base64&apos;;
        $msg[] = &apos;Content-Type: application/octet-stream;&apos; . &apos; name=&quot;&apos; . $attachment_fname . &apos;&quot;&apos;;
        $msg[] = &apos;Content-Disposition: attachment; filename=&quot;&apos;. $attachment_fname . &apos;&quot;&apos; . self::RN;
        $msg[] = chunk_split(base64_encode($attachment_fdata));
        $msg[] = &apos;--&apos; . $mime_boundary . &apos;--&apos;;

        $msg_raw = implode(self::RN, $msg);
        error_log($msg_raw, 3, &apos;/tmp/sendmail.log&apos;);

        $real_subject = self::UTF8_PREFIX . base64_encode($subject) . self::UTF8_POSTFIX;

        return mail($to, $real_subject, $msg_raw, $headers_raw);
    }
    public static function sendWithHtml($from, $to, $subject, $body)
    {
        // header 
        $headers = array();
        $headers[] = &apos;MIME-Version: 1.0&apos;;
        $headers[] = &apos;Content-type: text/html; charset=utf-8&apos;;
        $headers[] = &apos;From: &apos; . $from;
        $headers_raw = implode(self::RN, $headers);

        // Message Body
        $real_subject = self::UTF8_PREFIX . base64_encode($subject) . self::UTF8_POSTFIX;
        $msg_raw = $body;

        return mail($to, $real_subject, $msg_raw, $headers_raw);
    }
}
</code></pre></li>
<li><p>测试用例</p>
<pre><code>&lt;?php
include (&apos;ktmail.php&apos;);
$from = &apos;local@a.cn&apos;;
$to = &apos;your-email&apos;;
$subject = &apos;keything.net&apos;;
$body = &apos;keything.net&apos;;
$attachment_fname = &apos;keything.txt&apos;;
$attachment_fdata = &apos;keything&apos;;
$attach_res = KTMail::sendWithAttach($from, $to, $subject, $body, $attachment_fname, $attachment_fdata);
echo &apos;attach_res = &apos; . var_export($attach_res, true).&quot;\n&quot;;

$html_body = &apos;
    &lt;html&gt;
        &lt;head&gt; keything &lt;/head&gt;
        &lt;body&gt; 
            keything body 
            &lt;table border=&quot;1&quot;&gt;
                &lt;tr&gt;
                    &lt;td&gt;row 1, cell 1&lt;/td&gt;
                    &lt;td&gt;row 1, cell 2&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td&gt;row 2, cell 1&lt;/td&gt;
                    &lt;td&gt;row 2, cell 2&lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/body&gt;
        &lt;/head&gt;
    &lt;/html&gt;
    &apos;;
$html_res = KTMail::sendWithHtml($from, $to, $subject, $html_body);
echo &apos;html_res = &apos; . var_export($html_res, true).&quot;\n&quot;;
</code></pre></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/05/25/php发送邮件/" data-id="ckw5yql5o004ap8nu9d6zomg9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/8/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Laravel/">Laravel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/composer/">composer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/">cpp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp-lib/">cpp-lib</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/faiss/">faiss</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-source-code/">go.source.code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/laravel/">laravel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/">mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/machine-learning/">machine-learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memcache/">memcache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nosql/">nosql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/octave/">octave</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php源码学习/">php源码学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/">spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tcp/">tcp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thrift/">thrift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础知识/">基础知识</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Laravel/" style="font-size: 10px;">Laravel</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/composer/" style="font-size: 10px;">composer</a> <a href="/tags/cpp/" style="font-size: 12.22px;">cpp</a> <a href="/tags/cpp-lib/" style="font-size: 10px;">cpp-lib</a> <a href="/tags/elasticsearch/" style="font-size: 11.11px;">elasticsearch</a> <a href="/tags/faiss/" style="font-size: 10px;">faiss</a> <a href="/tags/git/" style="font-size: 12.22px;">git</a> <a href="/tags/go-source-code/" style="font-size: 10px;">go.source.code</a> <a href="/tags/golang/" style="font-size: 16.67px;">golang</a> <a href="/tags/laravel/" style="font-size: 11.11px;">laravel</a> <a href="/tags/linux/" style="font-size: 14.44px;">linux</a> <a href="/tags/mac/" style="font-size: 13.33px;">mac</a> <a href="/tags/machine-learning/" style="font-size: 10px;">machine-learning</a> <a href="/tags/memcache/" style="font-size: 15.56px;">memcache</a> <a href="/tags/mysql/" style="font-size: 13.33px;">mysql</a> <a href="/tags/nginx/" style="font-size: 13.33px;">nginx</a> <a href="/tags/nosql/" style="font-size: 18.89px;">nosql</a> <a href="/tags/octave/" style="font-size: 10px;">octave</a> <a href="/tags/php/" style="font-size: 20px;">php</a> <a href="/tags/php源码学习/" style="font-size: 17.78px;">php源码学习</a> <a href="/tags/redis/" style="font-size: 12.22px;">redis</a> <a href="/tags/spark/" style="font-size: 12.22px;">spark</a> <a href="/tags/tcp/" style="font-size: 10px;">tcp</a> <a href="/tags/thrift/" style="font-size: 13.33px;">thrift</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/基础知识/" style="font-size: 15.56px;">基础知识</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/11/19/分布式-CAP理论/">分布式-CAP理论</a>
          </li>
        
          <li>
            <a href="/2021/11/17/分布式-全序广播/">分布式-全序广播</a>
          </li>
        
          <li>
            <a href="/2021/11/16/Spark-DataSource-Hive Tables/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/11/14/分布式-事务/">分布式-事务</a>
          </li>
        
          <li>
            <a href="/2019/04/29/golang继承/">golang继承</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Keything<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>