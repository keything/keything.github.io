<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Keything的日志</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Keything的日志">
<meta property="og:url" content="http://keything.github.io/page/6/index.html">
<meta property="og:site_name" content="Keything的日志">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Keything的日志">
  
    <link rel="alternate" href="/atom.xml" title="Keything的日志" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Keything的日志</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://keything.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-1PHP变量之存储结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/19/1PHP变量之存储结构/" class="article-date">
  <time datetime="2016-09-19T11:52:36.000Z" itemprop="datePublished">2016-09-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/19/1PHP变量之存储结构/">1. PHP变量的存储结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>变量具有三个基本组成部分：</p>
<ul>
<li>名称</li>
<li>类型</li>
<li>值内容</li>
</ul>
<p>数据类型：<br>从类型的维度来看，编程语言可以分为三大类：</p>
<ul>
<li>静态类型语言：比如C/Java等，类型的检查是在编译期（compile-time）确定的。</li>
<li>动态语言类型：比如PHP，pythone等各种脚本语言，这类语言的类型在运行时确定的。</li>
<li>无类型语言：比如汇编语言，汇编语言操作的是底层存储。</li>
</ul>
<h2 id="变量的结构"><a href="#变量的结构" class="headerlink" title="变量的结构"></a>变量的结构</h2><p>在官方的PHP实现内部，所有变量使用同一种数据结构zval来保存，而这个结构同时表示PHP中各种数据类型。它不仅仅包含变量的值，也包含变量的类型。这就是PHP弱类型的核心。</p>
<h3 id="php变量类型及存储结构"><a href="#php变量类型及存储结构" class="headerlink" title="php变量类型及存储结构"></a>php变量类型及存储结构</h3><p>PHP是弱类型语言，但这并不表示PHP没有类型，在PHP中，存在8种变量类型，可以分为三类：<br>标量类型: boolean, integer, float(double), string<br>复合类型: array, object,<br>特殊类型: resource, NULL</p>
<h3 id="变量存储结构"><a href="#变量存储结构" class="headerlink" title="变量存储结构"></a>变量存储结构</h3><pre><code>// Zend/zend.h
typedef struct _zval_struct zval;
...
struct _zval_struct {
    /* Variable information */
    zvalue_value value;     /* value */
    zend_uint refcount__gc;
    zend_uchar type;    /* active type */
    zend_uchar is_ref__gc;
};
</code></pre><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>type的值可以是IS_NULL, IS_BOOL, iS_LONG, IS_DOUBLE, IS_STRING, IS_ARRAY, IS_OBJECT, IS_RESOURCE之一。</p>
<h3 id="变量的值存储"><a href="#变量的值存储" class="headerlink" title="变量的值存储"></a>变量的值存储</h3><p>前面提到变量的值存储在zvalue_value结构体中，结构体定义如下：之所以是联合体是因为一个变量同时只能属于一种类型。</p>
<pre><code>typedef union _zvalue_value {
    long lval;                  /* long value */
    double dval;                /* double value */
    struct {
        char *val;
        int len;
    } str;
    HashTable *ht;              /* hash table value */
    zend_object_value obj;
} zvalue_value;
</code></pre><h4 id="字符串string"><a href="#字符串string" class="headerlink" title="字符串string"></a>字符串string</h4><p>字符串的类型标示和其他数据类型一样，不过在存储字符串时多了一个字符串长度的字段。</p>
<pre><code>struct {
    char *val;
    int len;
}str;
</code></pre><h4 id="数组Array"><a href="#数组Array" class="headerlink" title="数组Array"></a>数组Array</h4><p>数组是PHP中最常用的，也是最强大的变量类型，可以存储其他类型的数据，而且提供各种内置操作函数。数组的值存储在zvalue_value.ht字段中，是一个HashTable类型的数据。</p>
<h4 id="对象object"><a href="#对象object" class="headerlink" title="对象object"></a>对象object</h4><p>在面向对象语言中，我们能自己定义自己需要的数据类型，包括类的属性，方法等数据。而对象则是类的一个具体实现。对象有自身的状态和所能完成的操作。<br>PHP的对象是一种复合型的数据，使用一种zend_object_value的结构体来存放。其定义如下：</p>
<pre><code>typedef struct _zend_object_value {
    zend_object_handle handle;  //  unsigned int类型，EG(objects_store).object_buckets的索引
    zend_object_handlers *handlers;
} zend_object_value;
</code></pre><p>PHP的对象只有在运行时才会被创建，前面的章节介绍了EG宏，这是一个全局结构体用于保存在运行时的数据。 其中就包括了用来保存所有被创建的对象的对象池，EG(objects_store)即全局变量executor_globals.objects_store，而object对象值内容的zend_object_handle域就是当前 对象在对象池中所在的索引，handlers字段则是将对象进行操作时的处理函数保存起来。 这个结构体及对象相关的类的结构_zend_class_entry，将在第五章作详细介绍。</p>
<pre><code>#define EG(v) (executor_globals.v)
extern ZEND_API zend_executor_globals executor_globals;
</code></pre><p>参考文章：</p>
<ol>
<li><a href="http://www.php-internals.com/book/?p=chapt03/03-01-00-variables-structure" target="_blank" rel="noopener">变量的结构和类型</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/09/19/1PHP变量之存储结构/" data-id="ckw1x5qa200013mnu6hoz2jpx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php源码学习/">php源码学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-PHP源码之用户代码的执行" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/18/PHP源码之用户代码的执行/" class="article-date">
  <time datetime="2016-09-18T05:45:57.000Z" itemprop="datePublished">2016-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/18/PHP源码之用户代码的执行/">PHP源码之用户代码的执行</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="二-用户代码的执行"><a href="#二-用户代码的执行" class="headerlink" title="二.用户代码的执行"></a>二.用户代码的执行</h1><h2 id="一切的开始：SAPI接口"><a href="#一切的开始：SAPI接口" class="headerlink" title="一切的开始：SAPI接口"></a>一切的开始：SAPI接口</h2><p>SAPI（Server Application Programming Interface) 指的是PHP具体应用的编程接口。<br>脚本执行的开始都是以SAPI接口实现开始的。只是不同的SAPI接口实现会完成他们特定的工作。</p>
<h2 id="开始和结束"><a href="#开始和结束" class="headerlink" title="开始和结束"></a>开始和结束</h2><h3 id="PHP开始执行以后会经过两个主要阶段："><a href="#PHP开始执行以后会经过两个主要阶段：" class="headerlink" title="PHP开始执行以后会经过两个主要阶段："></a>PHP开始执行以后会经过两个主要阶段：</h3><ul>
<li>处理请求之前的开始阶段：又分为两个过程<ul>
<li>第一个过程：模块初始化阶段（MINIT），在整个SAPI生命周期内只进行一次。比如<code>sudo /etc/init.d/php-fpm start</code>时。例如PHP在MINIT阶段会回调所有模块的MINIT函数，进行一些初始化工作，如注册常量，定义模块使用的类等等</li>
<li>第二个过程：模块激活阶段(RINIT)，该过程发生在请求阶段，在每个请求到来之前都会进行模块激活。其目的是请求到达以后PHP初始化执行脚本的基本环境，例如创建一个执行环境，包含保存PHP允许过程中变量名称和值内容的符号表，以及当前所有的函数和类的符号表。然后PHP调用所有模块的RINIT函数。</li>
</ul>
</li>
<li><p>处理请求之后的结束阶段</p>
<ul>
<li>第一个过程：请求结束后停用模块（RSHUTDOWN，对应RINIT）</li>
<li>第二个过程：关闭模块，在SAPI生命周期结束（WEB服务器退出或者命令行脚本执行完毕退出）MSHUTDOWN，对应MINIT。</li>
</ul>
</li>
<li><p>处理流程图（引用TIPI图）<br>  <img src="http://www.php-internals.com/images/book/chapt02/02-01-01-cgi-lift-cycle.png" alt="图片"> </p>
</li>
</ul>
<h2 id="fastcgi详细执行流程"><a href="#fastcgi详细执行流程" class="headerlink" title="fastcgi详细执行流程"></a>fastcgi详细执行流程</h2><h3 id="初始化：即-etc-init-d-php-fpm-start"><a href="#初始化：即-etc-init-d-php-fpm-start" class="headerlink" title="初始化：即 /etc/init.d/php-fpm start"></a>初始化：即 /etc/init.d/php-fpm start</h3><ol>
<li>入口函数：在<code>sapi/fpm/fpm/fpm_main.c</code>中的main函数</li>
<li><p>调用<code>cgi_sapi_module.startup</code>(函数指针startup的取值是<code>php_cgi_startup</code>），<code>php_cgi_startup</code>做了以下几件事情：</p>
<ul>
<li>初始化若干全局变量。如<code>zuf.printf_function = php_printf</code>，<code>PHP_VERSION</code>等</li>
<li>初始化zend引擎和核心组件。php_module_startup会调用<code>zend_startup</code>(zend/zend.c)函数。<code>zend_startup</code>函数的作用就是初始化zend引擎。这里的初始化操作包括内存管理初始化、 全局使用的函数指针初始化（如前面所说的<code>zend_printf</code>等），对PHP源文件进行词法分析、语法分析、 中间代码执行的函数指针的赋值，初始化若干HashTable（比如函数表，常量表等等），为ini文件解析做准备， 为PHP源文件解析做准备，注册内置函数（如strlen、define等），注册标准常量（如<code>E_ALL</code>、TRUE、NULL等）、注册GLOBALS全局变量(<code>zend_register_auto_global(&quot;GLOBALS&quot;,..., php_auto_globals_create_globals)</code>)等。<ul>
<li><code>zend_startup</code>-&gt;<code>zend_startup_builtin_functions</code>-&gt;<code>zend_register_module_ex</code>注册core模块，core模块的<code>module_number</code>是0。core模块中的函数分别是<code>zend_version</code>, <code>func_num_args</code>…<code>gc_disable</code>。</li>
<li>注册<code>E_ERROR</code>，<code>E_WARNING</code>这些常量。<code>zend_startup-&gt;zend_register_standard_constants</code></li>
</ul>
</li>
<li>解析php.ini：<code>php_init_config</code>函数的作用就是读取php.ini文件，设置配置参数，加载zend扩展并注册php扩展函数。</li>
<li>全局操作函数的初始化：<ul>
<li><code>php_startup_auto_globals</code>(<code>main/php_variables.c</code>)函数会初始化在用户空间使用频率很高的一些全局变量，如<code>$_GET,$_POST,$_FILES等</code>。其调用的<code>zend_register_auto_global</code>函数会将这些变量名添加到<code>CG(auto_globals)</code>这个变量表。</li>
<li><code>php_startup_sapi_content_types</code>函数用来初始化SAPI对于不同类型内容的处理函数。这里的处理函数包括POST数据默认处理函数</li>
</ul>
</li>
<li>初始化静态构建的模块和共享模块MINIT<ul>
<li><code>php_register_internal_extensions_func</code>函数用来注册静态构建的模块，也就是默认加载的模块。</li>
<li>模块初始化会执行两个操作：1. 将这些模块注册到已注册的模块列表(<code>module_registry</code>) 2. 将每个模块中包含的注册到函数表CG(<code>function_table</code>).可以看到各个模块是按照首字母排序的（date模块的<code>module_number</code>是2， ereg模块是3，libxml是4，xsl是46，zip是47。特别是cgi-fcgi是48）</li>
<li>在所有的模块都注册有，PHP会马上执行模块初始化操作（<code>zend_startup_modules</code>）。它的整个过程就是依次遍历每个模块，调用每个模块的模块初始化函数（<code>PHP_MINIT_FUNCTION</code>)。</li>
</ul>
</li>
<li>禁用函数和类 <code>php_disable_functions</code>和<code>php_disable_classes</code></li>
</ul>
</li>
<li><p>补充一段 进程初始化部分</p>
<ul>
<li>fpm_init</li>
<li>fpm_run中会调用fpm_children_create_initial(wp)进行worker进程（子进程）的初始化，<ul>
<li>fpm_children_create_initial函数返回：0表示是子进程、1表示父进程、2表示错误。</li>
<li>fpm_run函数对于父进程不返回，执行fpm_event_loop(0); 永远进行事件循环</li>
<li>fpm_run函数对于子进程返回listen_fd</li>
</ul>
</li>
</ul>
</li>
<li><p>此时调用<code>fcgi_accept_request</code>(fpm/fpm/fastcgi.c)。因为没有请求，因此listen_socket加锁，卡在accept处，等待请求的到来</p>
</li>
<li><p>当有请求到来时，会从accept后续开始执行。</p>
</li>
</ol>
<h3 id="接受请求"><a href="#接受请求" class="headerlink" title="接受请求"></a>接受请求</h3><p>在处理了文件相关的内容，PHP会调用<code>php_request_startup</code>做请求初始化操作。 请求初始化操作，除了图中显示的调用每个模块的请求初始化函数外，还做了较多的其它工作，其主要内容如下</p>
<ol>
<li><p>用户空间中需要用到的一些环境变化的初始化，包括服务器环境、请求数据环境等。实际用到的就是<code>$_POST, $_GET, $_COOKIE, $_SERVER, $_ENV, $_FILES</code>。</p>
<ul>
<li>在 <code>php_request_startup</code>-&gt;<code>php_hash_environment</code>，调用<code>CG(auto_globals)</code>中的回调来处理。到了这里说个题外话， 就是在php.ini中， 可以使用variables_order来控制PHP是否生成某个大变量，已经大变量的生成顺序。关于顺序，就是说， 如果打开了auto_register_globals的情况下， 如果先处理p，后处理g，那么$_GET[‘a’],就会覆盖$_POST[‘a’];</li>
<li><p>php.ini设置中variables_order string<br>设置了EGPCS(Environment, Get, Post, Cookie and Server)变量的解析顺序。比如，variables_order顺序设置为SP，那么PHP将会创建超级全局变量$_SERVER和$_POST，而不会创建$_ENV, $_GET, $_COOKIE。</p>
</li>
<li><p>和<code>sapi_module.default_post_reader</code>一样，<code>sapi_module.treat_data</code>的值也是在模块初始化时， 通过<code>php_startup_sapi_content_types</code>函数注册了默认数据处理函数为<code>main/php_variables.c</code>文件中<code>php_default_treat_data</code>函数。</p>
</li>
<li>以$_COOKIE为例，<code>php_default_treat_data</code>函数会对依据分隔符，将所有的cookie拆分并赋值给对应的变量。</li>
</ul>
</li>
<li><p>模块请求的初始化。PHP通过zend_activate_modules函数实现模块请求的初始化。会调用各个模块的RINIT函数。这儿的调用并没有按照字母排序的顺序调用模块。比如libxml,zlib,intl,mbstring…</p>
</li>
<li>运行。<ul>
<li>php_execute_script函数包含了运行php脚本的全部过程。当一个php文件需要解析执行时，它可能会需要执行三个文件，其中包括一个前置执行文件、当前需要执行文件和一个后置文件。非当前的两个文件可以在php.ini文件通过auto_prepend_file参数和auto_append_file参数设置。如果这两个参数设置为空，则禁用对应执行文件。</li>
<li>对于需要解析执行的文件，通过zend_compile_file（compile_file函数）做词法分析、语法分析和中间代码生成操作，返回此文件的所有中间代码。 如果解析的文件有生成有效的中间代码，则调用zend_execute（execute函数）执行中间代码。 如果在执行过程中出现异常并且用户有定义对这些异常的处理，则调用这些异常处理函数。 在所有的操作都处理完后，PHP通过EG(return_value_ptr_ptr)返回结果</li>
</ul>
</li>
</ol>
<h3 id="PHP关闭请求"><a href="#PHP关闭请求" class="headerlink" title="PHP关闭请求"></a>PHP关闭请求</h3><p>PHP关闭请求的过程是一个若干个关闭操作的集合，这个集合存在于php_request_shutdown函数中。 这个集合包括如下内容：</p>
<ul>
<li>调用所有通过register_shutdown_function()注册的函数。这些在关闭时调用的函数是在用户空间添加加来的。我们可以在脚本出错时调用一个统一的函数，给用户一个友好一些的页面，这个有点类似于网页中的404页面。</li>
<li>执行所有可用的__destruct函数。 这里的析构函数包括在对象池（EG(objects_store）中的所有对象的析构函数以及EG(symbol_table)中各个元素的析构方法。</li>
<li>将所有的输出刷出去</li>
<li>发送HTTP应答头。也是一个输出字符串的过程，只是这个字符串可能符合某些规范</li>
<li>遍历每个模块的关闭请求方法，执行模块的请求关闭操作，即RSHUTDOWN</li>
<li>销毁全局变量表（PG(http_globals)）的变量。</li>
<li>通过zend_deactivate函数，关闭词法分析器、语法分析器和中间代码执行器</li>
<li>调用每个扩展的post-RSHUTDOWN函数。只是基本每个扩展的post_deactivate_func函数指针都是NULL</li>
<li>关闭SAPI，通过sapi_deactivate销毁SG(sapi_headers)、SG(request_info)等的内容。</li>
<li>关闭流的包装器、关闭流的过滤器</li>
<li>关闭内存管理</li>
<li>重新设置最大执行时间</li>
</ul>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><ol>
<li><p>flush</p>
<p> sapi_flush将最后的内容刷回去。调用的是sapi_module.flush。</p>
</li>
<li><p>关闭zend引擎</p>
<p> 此时对应图中的流程，我们应该是执行每个模块的关闭模块操作。 在这里只有一个zend_hash_graceful_reverse_destroy函数将module_registry销毁了。 当然，它最终也是调用了关闭模块的方法的，其根源在于在初始化module_registry时就设置了这个hash表析构时调用ZEND_MODULE_DTOR宏。 而ZEND_MODULE_DTOR宏对应的是module_destructor函数。 在此函数中会调用模块的module_shutdown_func方法，即PHP_RSHUTDOWN_FUNCTION宏产生的那个函数。</p>
<p> 在关闭所有的模块后，PHP继续销毁全局函数表，销毁全局类表、销售全局变量表等。 通过zend_shutdown_extensions遍历zend_extensions所有元素，调用每个扩展的shutdown函数。</p>
</li>
</ol>
<p>【todo】目前需要看的地方有： </p>
<ol>
<li>redismemcache的持久化连接是如何处理的 </li>
<li>全局变量表这些如何做的呢 </li>
<li>最后关闭这儿是如何处理的呢，还没有详细看代码</li>
<li>opcode：一个代码构造出来的完整opcode是什么样子呢<br>【todo】opcode这部分还是没有理解请求</li>
</ol>
<h1 id="2-深入理解PHP内核之SAPI概述（讲述FASTCGI）"><a href="#2-深入理解PHP内核之SAPI概述（讲述FASTCGI）" class="headerlink" title="2. 深入理解PHP内核之SAPI概述（讲述FASTCGI）"></a>2. 深入理解PHP内核之SAPI概述（讲述FASTCGI）</h1><p>在各个服务器抽象层之间遵守着相同的约定，这里我们称之为SAPI接口。 每个SAPI实现都是一个_sapi_module_struct结构体变量。（SAPI接口）。 在PHP的源码中，当需要调用服务器相关信息时，全部通过SAPI接口中对应方法调用实现， 而这对应的方法在各个服务器抽象层实现时都会有各自的实现。如下图所示，为SAPI的简单示意图（引用TIPI图）</p>
<p><img src="http://www.php-internals.com/images/book/chapt02/02-02-01-sapi.png" alt="SAPI简单示意图"></p>
<p>因为平时使用fastcgi，因此这儿参考TIPI中讲述apache2的方式来讲讲<code>fastcgi</code>。<br>它的启动方法如下：</p>
<pre><code>cgi_sapi_module.startup(&amp;cgi_sapi_module) // fastcgi模式 sapi/fpm/fpm/fpm_main.c
</code></pre><p>这儿的cgi_sapi_module.startup是sapi_module_struct结构体的静态变量。静态变量的详细解释如下（引用TIPI内容）：</p>
<pre><code>struct _sapi_module_struct {
char *name;         //  名字（标识用）
char *pretty_name;  //  更好理解的名字（自己翻译的）

int (*startup)(struct _sapi_module_struct *sapi_module);    //  启动函数
int (*shutdown)(struct _sapi_module_struct *sapi_module);   //  关闭方法

int (*activate)(TSRMLS_D);  // 激活
int (*deactivate)(TSRMLS_D);    //  停用

int (*ub_write)(const char *str, unsigned int str_length TSRMLS_DC);
 //  不缓存的写操作(unbuffered write)
void (*flush)(void *server_context);    //  flush
struct stat *(*get_stat)(TSRMLS_D);     //  get uid
char *(*getenv)(char *name, size_t name_len TSRMLS_DC); //  getenv

void (*sapi_error)(int type, const char *error_msg, ...);   /* error handler */

int (*header_handler)(sapi_header_struct *sapi_header, sapi_header_op_enum op,
    sapi_headers_struct *sapi_headers TSRMLS_DC);   /* header handler */

 /* send headers handler */
int (*send_headers)(sapi_headers_struct *sapi_headers TSRMLS_DC);

void (*send_header)(sapi_header_struct *sapi_header,
        void *server_context TSRMLS_DC);   /* send header handler */

int (*read_post)(char *buffer, uint count_bytes TSRMLS_DC); /* read POST data */
char *(*read_cookies)(TSRMLS_D);    /* read Cookies */

/* register server variables */
void (*register_server_variables)(zval *track_vars_array TSRMLS_DC);

void (*log_message)(char *message);     /* Log message */
time_t (*get_request_time)(TSRMLS_D);   /* Request Time */
void (*terminate_process)(TSRMLS_D);    /* Child Terminate */

char *php_ini_path_override;    //  覆盖的ini路径

...
...
};
</code></pre><p>其中一些函数指针的说明如下：</p>
<ul>
<li>startup：当sapi初始化时，首先会调用该函数。 startup函数只在父进程中创建一次，在其fork的子进程中不会调用。在fastcgi的</li>
<li>activate：在每个请求开始时调用，他会再次初始化每个请求前的数据结构。</li>
</ul>
<p>其中fastcgi的sapi_module_struct的定义在fpm/fpm/fpm_main.c中，定义如下：</p>
<pre><code>static sapi_module_struct cgi_sapi_module = {
&quot;fpm-fcgi&quot;,                        /* name */
&quot;FPM/FastCGI&quot;,                    /* pretty name */

php_cgi_startup,                /* startup */
php_module_shutdown_wrapper,    /* shutdown */

sapi_cgi_activate,                /* activate */
sapi_cgi_deactivate,            /* deactivate */

sapi_cgibin_ub_write,            /* unbuffered write */
sapi_cgibin_flush,                /* flush */
NULL,                            /* get uid */
sapi_cgibin_getenv,                /* getenv */

php_error,                        /* error handler */

NULL,                            /* header handler */
sapi_cgi_send_headers,            /* send headers handler */
NULL,                            /* send header handler */

sapi_cgi_read_post,                /* read POST data */
sapi_cgi_read_cookies,            /* read Cookies */

sapi_cgi_register_variables,    /* register server variables */
sapi_cgi_log_message,            /* Log message */
NULL,                            /* Get request time */
NULL,                            /* Child terminate */

STANDARD_SAPI_MODULE_PROPERTIES
};
</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.php-internals.com/book/?p=chapt02/02-02-00-overview" target="_blank" rel="noopener">SAPI概述</a></p>
<p><a href="https://mengkang.net/668.html" target="_blank" rel="noopener">fastcgi概述</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/09/18/PHP源码之用户代码的执行/" data-id="ckw1x5qao000s3mnucp7t163t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php源码学习/">php源码学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-PHP源码之准备工作和背景知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/18/PHP源码之准备工作和背景知识/" class="article-date">
  <time datetime="2016-09-18T05:37:16.000Z" itemprop="datePublished">2016-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/18/PHP源码之准备工作和背景知识/">PHP源码之准备工作和背景知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>深入理解PHP内核–学习版<br>说明：<a href="http://www.php-internals.com/" target="_blank" rel="noopener">深入理解PHP内核</a>是非常非常好的书，当然书中内容只有你详细尝试过，走一遍代码才能理解的更深刻，这几篇文章，当做自己的一个学习笔记。</p>
<h2 id="一、学习环境搭建"><a href="#一、学习环境搭建" class="headerlink" title="一、学习环境搭建"></a>一、学习环境搭建</h2><ol>
<li>php源代码： 我下载的是php5.6.25。</li>
<li>编译环境：由于会涉及到nginx，php，mysql等等，为了快速搭建lnmp的环境，建议使用<a href="http://lnmp.org/" target="_blank" rel="noopener">lnmp</a>先安装所需要的各种软件包。</li>
<li><p>编译语句：<br> 因为我是在一个全新的centos虚拟机上进行学习，因此安装目录是/usr/local/php。</p>
<p> <code>&#39;./configure&#39;  &#39;--prefix=/usr/local/php&#39; &#39;--with-config-file-path=/usr/local/php/etc&#39; &#39;--enable-fpm&#39; &#39;--with-fpm-user=www&#39; &#39;--with-fpm-group=www&#39; &#39;--with-mysql=mysqlnd&#39; &#39;--with-mysqli=mysqlnd&#39; &#39;--with-pdo-mysql=mysqlnd&#39; &#39;--with-iconv-dir=libiconv&#39; &#39;--with-freetype-dir=/usr/local/freetype&#39; &#39;--with-jpeg-dir&#39; &#39;--with-png-dir&#39; &#39;--with-zlib&#39; &#39;--with-libxml-dir=/usr&#39; &#39;--enable-xml&#39; &#39;--disable-rpath&#39; &#39;--enable-bcmath&#39; &#39;--enable-shmop&#39; &#39;--enable-sysvsem&#39; &#39;--enable-inline-optimization&#39; &#39;--with-curl&#39; &#39;--enable-mbregex&#39; &#39;--enable-mbstring&#39; &#39;--with-mcrypt&#39; &#39;--enable-ftp&#39; &#39;--with-openssl&#39; &#39;--with-mhash&#39; &#39;--enable-pcntl&#39; &#39;--enable-sockets&#39; &#39;--enable-zip&#39; &#39;--enable-soap&#39; &#39;--with-gettext&#39; &#39;--disable-fileinfo&#39; &#39;--enable-opcache&#39; &#39;--enable-intl&#39; &#39;--with-xsl&#39;</code></p>
<p> 此时试一下php是否可以运行</p>
</li>
<li><p>php的源码目录结构</p>
<ul>
<li>build：放置一些和源码编译相关的一些文件。比如开始构建之前的buildconf脚本等文件</li>
<li>ext 官方扩展目录，包括了绝大多数PHP的函数定义和实现，如array系列，pdo系列，spl系列等函数实现</li>
<li>main：这里存放的是PHP最为核心的文件了，主要实现php的基本设施。</li>
<li>zend：zend引擎的实现目录，比如脚本的词法语法解析，opcode的执行和扩展机制的实现等等</li>
<li>pear：php扩展与应用仓库</li>
<li>sapi：包含了各种服务器抽象层的代码，如apache的mod_php，cgi，fastcgi以及fpm等接口</li>
<li>TSRM：</li>
<li>tests</li>
<li>win32</li>
</ul>
</li>
</ol>
<ol start="5">
<li><p>php源码阅读工具</p>
<p> 使用vim+ctags阅读</p>
<ul>
<li>安装ctags: <code>yum install ctags</code></li>
<li>生成tags: <code>cd /your/php/source/directory  &amp;&amp; ctags -R</code></li>
<li>在.vimrc中添加ctags路径：<code>set tags+=/your/php/source/directory/tags</code></li>
<li>使用：“使用 Ctrl+] 就可以自动跳转至定义，Ctrl+t 可以返回上一次查看位置。这样就可以快速的在代码之间“游动”了。</li>
</ul>
</li>
</ol>
<ol start="6">
<li><p>PHP源码中的常用代码</p>
<ul>
<li>双井号(##)：”##”被称为 连接符（concatenator），它是一种预处理运算符， 用来把两个语言符号(Token)组合成单个语言符号。 这里的语言符号不一定是宏的变量。并且双井号不能作为第一个或最后一个元素存在</li>
<li>单井号(#):”#”是一种预处理运算符，它的功能是将其后面的宏参数进行 字符串化操作 ， 简单说就是在对它所引用的宏变量通过替换后在其左右各加上一个双引号， 用比较官方的话说就是将语言符号(Token)转化为字符串</li>
<li>宏定义中的do-while循环</li>
<li><code>#line</code>预处理:用于改变当前的行号（<strong>LINE</strong>）和文件名（<strong>FILE</strong>）</li>
<li>PHP中的全局变量宏，如PG()， EG()之类的函数，他们都是PHP中定义的宏，这系列宏主要的作用是解决线程安全所写的全局变量包裹宏。在PHP代码的其他地方也存在很多类似的宏，这些宏和PG宏一样，都是为了将线程安全进行封装，同时通过约定的 G 命名来表明这是全局的， 一般都是个缩写，因为这些全局变量在代码的各处都会使用到，这也算是减少了键盘输入。</li>
</ul>
</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.php-internals.com/book/?p=chapt01/01-00-prepare-and-background" target="_blank" rel="noopener">第一章 准备工作和背景知识</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/09/18/PHP源码之准备工作和背景知识/" data-id="ckw1x5qan000p3mnu031bo4ms" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php源码学习/">php源码学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-php原理好文章列表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/10/php原理好文章列表/" class="article-date">
  <time datetime="2016-09-10T00:24:56.000Z" itemprop="datePublished">2016-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/10/php原理好文章列表/">php原理-鸟哥的文章列表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol start="0">
<li><p>概述</p>
<p> <a href="http://www.laruence.com/2008/08/11/147.html" target="_blank" rel="noopener">深入浅出PHP</a></p>
</li>
<li><p>变量</p>
<p> <a href="http://www.laruence.com/2008/08/22/412.html" target="_blank" rel="noopener">深入理解PHP原理之变量</a><br> <a href="http://www.laruence.com/2008/08/26/463.html" target="_blank" rel="noopener">深入理解PHP原理之变量作用域(Scope in PHP) </a><br> <a href="http://www.laruence.com/2008/09/19/520.html" target="_blank" rel="noopener">深入理解PHP原理之变量分离/引用</a><br> <a href="http://www.php-internals.com/book/?p=chapt06/06-06-copy-on-write" target="_blank" rel="noopener">深入理解php内核之写时复制</a><br> 到了引用这儿还是有点懵逼<br> <a href="http://www.laruence.com/2008/11/07/581.html" target="_blank" rel="noopener">PHP的GET/POST等大变量生成过程</a><br> <a href="http://www.laruence.com/2009/12/26/1198.html" target="_blank" rel="noopener">深入理解PHP原理之变量生命期(一)</a><br> <a href="http://www.laruence.com/2011/10/10/2212.html" target="_blank" rel="noopener">Array dereferencing</a><br> <a href="http://www.laruence.com/2010/12/08/1716.html" target="_blank" rel="noopener">如何获取一个变量的名字</a><br> 如何获取一个变量的名字中提到了<code>活动符号表</code><br> 而在PHP中, 所有的变量都存储在称为”符号表”的HastTable结构中. 在解析执行的过程中, 依旧保留着着”符号”信息, 所以, 肯定是可以获取到的.</p>
<p> <a href="http://php.net/manual/zh/internals2.variables.php" target="_blank" rel="noopener">变量的使用</a></p>
<p> 而在PHP中, 符号的作用域是和活动符号表相关联的. 同一时间, 只有一个活动符号表.</p>
<p> 那么怎么理解活动符号表和符号表呢?</p>
<p> 对于PHP来说, 当前活动的符号表是保存在全局变量EG(active_symbol_table)中的, 而于此同时, 还有个全局符号表保存在EG(symbol_table)中, 在进入一个函数调用的执行体之前, 会生成一个新的active_symbol_table, 并且会保持一个调用栈式样的符号表栈:EG(symtable_cache), 以便在退出函数调用的时候, 恢复之前的活动符号表(作用域).</p>
<p> 同时在PHP中, 不能实现作用域继承, 也就是不能直接访问作用域外层的符号(需要加上golbal声明), 而如果加上global的声明的话, 也会在当前的活动作用域生成一个copy, 也就是说, 不存在在当前作用域可见的符号是保存在全局符号表的</p>
</li>
<li><p>函数</p>
<p> <a href="http://www.laruence.com/2008/08/12/164.html" target="_blank" rel="noopener">深入理解PHP原理之函数(Introspecting PHP Function)</a><br> 函数分为两种zend_internal_function(对应结构体_zend_internal_function)和用户自定义函数(对应结构体_zend_op_array)。还有一个结构体zend_function.<br> 首先你要理解他的设计目标： zend_internal_function, zend_function,zend_op_array可以安全的互相转换(The are not identical structs, but all the elements that are in “common” they hold in common, thus the can safely be casted to each other);<br> 具体来说，当在op code中通过ZEND_DO_FCALL调用一个函数的时候，ZE会在函数表中，根据名字（其实是lowercase的函数名字，这也就是为什么PHP的函数名是大小写不敏感的)查找函数， 如果找到，返回一个zend_function结构的指针(仔细看这个上面的zend_function结构), 然后判断type,如果是ZEND_INTERNAL_FUNCTION， 那么ZE就调用zend_execute_internal,通过zend_internal_function.handler来执行这个函数， 如果不是，就调用zend_execute来执行这个函数包含的zend_op_array.</p>
<p> 【todo】现在不明白的是zend_op_array里面到底存的是什么?<br> <a href="http://www.laruence.com/2011/10/10/2229.html" target="_blank" rel="noopener">函数类型提示(Callable typehint) </a><br> <a href="http://www.laruence.com/2010/06/20/1602.html" target="_blank" rel="noopener">深入理解PHP之匿名函数</a></p>
</li>
<li><p>opcode</p>
<p> <a href="http://www.laruence.com/2008/06/18/221.html" target="_blank" rel="noopener">深入理解PHP原理之opcodes</a><br> <a href="http://www.laruence.com/2008/09/23/539.html" target="_blank" rel="noopener">使用PHP embed sapi实现opcodes查看器</a><br> <a href="http://www.laruence.com/2012/08/16/2701.html" target="_blank" rel="noopener">关于PHP的编译和执行分离</a><br> <a href="http://www.laruence.com/2010/08/03/1697.html" target="_blank" rel="noopener">深入理解PHP原理之异常机制</a><br> <a href="http://www.laruence.com/2008/08/24/377.html" target="_blank" rel="noopener">PHP源码分析之Global关键字</a><br> 也就是说， 如果你global了一个变量，那么Zend就会去全局symbol_table去寻找，如果找不到，就会在全局symbol_table中分配相应的变量。通过这样的机制，实现了全局变量</p>
</li>
<li><p>对象</p>
<p> <a href="http://www.laruence.com/2010/05/18/1482.html" target="_blank" rel="noopener">深入理解PHP原理之对象(一)</a><br> <a href="http://www.laruence.com/2008/08/24/427.html" target="_blank" rel="noopener">PHP5多重继承顺序的bug</a></p>
</li>
<li><p>数组</p>
<p> <a href="http://www.laruence.com/2008/10/31/574.html" target="_blank" rel="noopener">关于一笔试题(Iterator模式)</a><br> <a href="http://www.laruence.com/2008/11/20/630.html" target="_blank" rel="noopener">深入理解PHP原理之foreach</a><br> <a href="http://www.laruence.com/2009/07/23/994.html" target="_blank" rel="noopener">PHP中的Hash算法</a><br> <a href="http://www.laruence.com/2009/08/23/1065.html" target="_blank" rel="noopener">深入理解PHP之数组（遍历顺序)</a></p>
</li>
<li><p>扩展</p>
<p> <a href="http://www.laruence.com/2008/08/16/301.html" target="_blank" rel="noopener">扩展PHP(一)</a><br> <a href="http://www.laruence.com/2011/09/13/2139.html" target="_blank" rel="noopener">关于PHP扩展开发的一些资源</a><br> <a href="http://www.laruence.com/2009/04/28/719.html" target="_blank" rel="noopener">用C/C++扩展你的PHP</a><br> <a href="http://www.laruence.com/2009/08/18/1042.html" target="_blank" rel="noopener">保证PHP扩展的依赖关系</a><br> <a href="http://www.laruence.com/2009/06/14/945.html" target="_blank" rel="noopener">深入理解PHP原理之扩展载入过程</a></p>
</li>
<li><p>内存管理</p>
<p> <a href="http://www.laruence.com/2011/11/09/2277.html" target="_blank" rel="noopener">PHP原理之内存管理中难懂的几个点</a><br> <a href="http://www.laruence.com/2011/03/04/1894.html" target="_blank" rel="noopener">深入理解PHP内存管理之谁动了我的内存</a></p>
</li>
<li><p>SAPI<br> <a href="http://www.laruence.com/2008/08/12/180.html" target="_blank" rel="noopener">深入理解ZendSAPIs</a><br> <a href="http://docs.php.net/manual/zh/features.gc.php" target="_blank" rel="noopener">垃圾回收机制</a><br> <a href="http://www.php-internals.com/book/?p=chapt02/02-02-00-overview" target="_blank" rel="noopener">第二节 SAPI概述</a><br> <a href="http://www.php-internals.com/book/?p=chapt02/02-02-03-fastcgi" target="_blank" rel="noopener">fastcgi</a><br> <a href="http://www.php-internals.com/book/?p=chapt02/02-02-02-embedding-php" target="_blank" rel="noopener">嵌入式sapi</a></p>
</li>
<li><p>其他<br> <a href="http://www.laruence.com/2009/07/27/1020.html" target="_blank" rel="noopener">深入理解PHP原理之错误抑制与内嵌HTML</a><br> <a href="http://www.laruence.com/2011/05/31/2018.html" target="_blank" rel="noopener">PHP Performance Optimization</a><br> <a href="http://www.laruence.com/2011/12/19/2399.html" target="_blank" rel="noopener">关于PHP浮点数你应该知道的</a><br> <a href="http://www.laruence.com/2013/03/26/2884.html" target="_blank" rel="noopener">PHP浮点数的一个场景问题的解答</a><br> <a href="http://www.laruence.com/2008/11/07/586.html" target="_blank" rel="noopener">深入理解PHP原理之文件上传</a><br> <a href="http://www.laruence.com/2009/05/31/889.html" target="_blank" rel="noopener">PHP受locale影响的函数</a><br> <a href="http://www.laruence.com/2009/08/22/1059.html" target="_blank" rel="noopener">字符编码详解</a><br> <a href="http://www.laruence.com/2009/12/09/1180.html" target="_blank" rel="noopener">isset与is_null的不同</a><br> isset是语句 is_null是函数，判断是否为null时可以使用===<br> <a href="http://www.laruence.com/2010/04/15/1414.html" target="_blank" rel="noopener">深入理解ob_flush和flush的区别</a><br> <a href="http://www.laruence.com/2015/05/28/3038.html" target="_blank" rel="noopener">在php中使用协程实现多任务调度</a><br> <a href="http://www.laruence.com/2008/04/16/98.html" target="_blank" rel="noopener">使用fsock实现异步调用php</a><br> <a href="http://www.laruence.com/2011/12/06/2381.html" target="_blank" rel="noopener">更简单的重现PHP core调用栈</a><br> <a href="http://www.laruence.com/2011/10/19/2247.html" target="_blank" rel="noopener">Zend Signal in PHP5.4</a><br> <a href="http://www.laruence.com/2011/03/24/858.html" target="_blank" rel="noopener">一些PHP Coding Tips</a></p>
</li>
<li><p>Dtrace<br><a href="http://php.net/manual/zh/features.dtrace.php" target="_blank" rel="noopener">Dtrace</a><br><a href="http://php.net/manual/zh/internals2.preface.php" target="_blank" rel="noopener">php骇客指南</a></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/09/10/php原理好文章列表/" data-id="ckw1x5qc000463mnuduci4nzt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-php一些bug列表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/07/php一些bug列表/" class="article-date">
  <time datetime="2016-09-07T11:46:33.000Z" itemprop="datePublished">2016-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/07/php一些bug列表/">php一些bug列表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在读<a href="http://www.laruence.com/" target="_blank" rel="noopener">Laruence</a>的文章时，有很多好的文章。<br>有一些不会出现或者出现概率很低的文章，现在将读过的文章，自己记录一下，方便查阅</p>
<ol>
<li><p><a href="http://www.laruence.com/2009/12/05/1172.html" target="_blank" rel="noopener">PHP5.2x + APC的一个bug定位</a> </p>
<p> 出现原因是：session模块和apc模块加载顺序和模块关闭顺序导致。<br> 模块载入顺序和模块关闭函数很有关系了. 总体来说, 就是PHP会根据模块载入的顺序的反序来在每次请求处理结束后依次调用各个扩展的请求关闭函数.</p>
<p> 因为我们环境的Session是静态编译进PHP的, 所以Session模块一定先于动态编译进PHP的APC被载入, 也就是说, 在请求关闭时期, APC的请求关闭函数, 一定会先于Session的请求关闭函数被调用.</p>
<p> APC在模块请求关闭函数时期, 清空了执行全局标量中的类定义表EG(classs_table)，当Session的请求关闭函数调用的时候, 执行环境的Class Table已经为空, 当然也就会抛出类找不到的fatalerror了。</p>
</li>
<li><p><a href="http://www.laruence.com/2008/12/31/647.html" target="_blank" rel="noopener">一个低概率的PHP CoreDump</a></p>
<p> 出现原因：php正在出错处理函数中，这个时候php execute limit time信号到来被响应，再次载入php_error_cb函数，就会出现。</p>
<p> 自己尝试：在php5.5环境下复现</p>
</li>
<li><a href="http://www.laruence.com/2010/09/27/1754.html" target="_blank" rel="noopener">PHP stream未能及时清理现场导致Core的bug</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/09/07/php一些bug列表/" data-id="ckw1x5qby00413mnufw1o4kfc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-php中程序加载一个不停变化的文件出现bus-error" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/07/php中程序加载一个不停变化的文件出现bus-error/" class="article-date">
  <time datetime="2016-09-07T11:28:35.000Z" itemprop="datePublished">2016-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/07/php中程序加载一个不停变化的文件出现bus-error/">php中程序加载一个不停变化的文件出现bus error</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h3><p>程序加载一个不停在变化的文件，会出现bus error</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>通过gdb发现在进行语法解析时，内存越界</p>
<h3 id="php环境"><a href="#php环境" class="headerlink" title="php环境"></a>php环境</h3><p>Configure Command =&gt;  ‘./configure’  ‘–prefix=/tmp/php56’ ‘–enable-fpm’ ‘-enable-debug’<br>没有opcache，apc等缓存。即bus error的出现于opcode缓存没有关系</p>
<h3 id="出现bus-error的代码"><a href="#出现bus-error的代码" class="headerlink" title="出现bus error的代码"></a>出现bus error的代码</h3><pre><code>//文件名 parse.php
&lt;?php

if ($argv[1] &gt; 0) {
    while ($argv[1]--) {
        file_put_contents(&apos;test.tpl&apos;, &quot;&lt;?php #&quot;.str_repeat(&apos;A&apos;, mt_rand(4000, 5000)).&quot; ?&gt;\n&quot;, LOCK_EX);
    }
} else {
    $p2 = popen(&quot;php parse.php 100&quot;, &quot;r&quot;);
    while (1) {
        include &apos;test.tpl&apos;;
    }
}
</code></pre><p>执行 <code>$php parse.php</code> 会出现：</p>
<pre><code>[1]    17776 bus error (core dumped)  php parse.php
</code></pre><h3 id="coredump调试"><a href="#coredump调试" class="headerlink" title="coredump调试"></a>coredump调试</h3><p>命令：<code>gdb php core-php.15285</code><br>现象：</p>
<pre><code>balabala...

Core was generated by `php parse.php&apos;.
Program terminated with signal 7, Bus error
</code></pre><p>(gdb) bt</p>
<pre><code>#0  0x00000000007f39a7 in lex_scan (zendlval=0x7fffc794b888) at Zend/zend_language_scanner.l:1863
#1  0x00000000008309a7 in zendlex (zendlval=0x7fffc794b880) at /home/yankai-c/php-5.6.25/Zend/zend_compile.c:6913
#2  0x00000000007e45ce in zendparse () at /home/yankai-c/php-5.6.25/Zend/zend_language_parser.c:3732
#3  0x00000000007ed208 in compile_file (file_handle=0x7fffc794bca0, type=2) at Zend/zend_language_scanner.l:586
#4  0x000000000067f21c in phar_compile_file (file_handle=0x7fffc794bca0, type=2)
    at /home/yankai-c/php-5.6.25/ext/phar/phar.c:3371
#5  0x00000000007ed3bb in compile_filename (type=2, filename=0x7f3ea56146a8) at Zend/zend_language_scanner.l:629
#6  0x000000000089a120 in ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER (execute_data=0x7f3ea55db330)
    at /home/yankai-c/php-5.6.25/Zend/zend_vm_execute.h:2988
#7  0x0000000000893367 in execute_ex (execute_data=0x7f3ea55db330)
    at /home/yankai-c/php-5.6.25/Zend/zend_vm_execute.h:363
#8  0x00000000008933ea in zend_execute (op_array=0x7f3ea5611d88)
    at /home/yankai-c/php-5.6.25/Zend/zend_vm_execute.h:388
#9  0x000000000084d76c in zend_execute_scripts (type=8, retval=0x0, file_count=3)
    at /home/yankai-c/php-5.6.25/Zend/zend.c:1341
#10 0x00000000007b2a02 in php_execute_script (primary_file=0x7fffc794f3d0)
    at /home/yankai-c/php-5.6.25/main/main.c:2613
#11 0x0000000000904f71 in do_cli (argc=2, argv=0x2d9ecf0) at /home/yankai-c/php-5.6.25/sapi/cli/php_cli.c:994
#12 0x000000000090602e in main (argc=2, argv=0x2d9ecf0) at /home/yankai-c/php-5.6.25/sapi/cli/php_cli.c:1378
</code></pre><p>(gdb) p <code>(*(struct _zval_struct*)0x7fffc794b888)</code></p>
<pre><code>$1 = {value = {lval = 139907039412224, dval = 6.9123261784937185e-310, str = {
      val = 0x7f3ea562c000 &lt;Address 0x7f3ea562c000 out of bounds&gt;, len = 6}, ht = 0x7f3ea562c000, obj = {
      handle = 2774712320, handlers = 0x6}, ast = 0x7f3ea562c000}, refcount__gc = 2673624600, type = 1 &apos;\001&apos;,
  is_ref__gc = 127 &apos;\177&apos;}
</code></pre><p>(gdb) p <code>(*(znode*)0x7fffc794b880).u.constant.value.str.val</code> </p>
<pre><code>$26 = 0x7f3ea562c000 &lt;Address 0x7f3ea562c000 out of bounds&gt;
</code></pre><p>说明：最后对zendlex的参数进行打印，可以看到提示内存越界。</p>
<p>在<a href="https://bugs.php.net/bug.php?id=52752" target="_blank" rel="noopener">bus error</a>文章中提到，出现<code>bus error</code>的原因是加载了损坏的文件（broken file）。对于平时编程而言，加载损坏的文件是不能接受的。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://bugs.php.net/bug.php?id=52752" target="_blank" rel="noopener">bus error</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/09/07/php中程序加载一个不停变化的文件出现bus-error/" data-id="ckw1x5qbz00433mnu675wv4w1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-php如何生成coredump" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/07/php如何生成coredump/" class="article-date">
  <time datetime="2016-09-07T07:33:49.000Z" itemprop="datePublished">2016-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/07/php如何生成coredump/">php如何生成coredump</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="PHP如何生成GDB的backtrace"><a href="#PHP如何生成GDB的backtrace" class="headerlink" title="PHP如何生成GDB的backtrace"></a>PHP如何生成GDB的backtrace</h2><p>使用lnmp环境时，可能会出现502。502的原因很多，其中一种是php-fpm出现了段错误，可以通过fpm日志（在php-fpm.conf中的error_log设置）查看。</p>
<h3 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h3><p>要想使用backtrace获得正确消息，编译php的时候使用参数 <code>--enable-debug</code></p>
<h3 id="如何设置，才能生成coredump文件"><a href="#如何设置，才能生成coredump文件" class="headerlink" title="如何设置，才能生成coredump文件"></a>如何设置，才能生成coredump文件</h3><ol>
<li><p>第一步设置linux，使linux能够生成core</p>
<pre><code>$ su -
$ echo &apos;/tmp/core-%e.%p&apos; &gt; /proc/sys/kernel/core_pattern
$ echo 0 &gt; /proc/sys/kernel/core_uses_pid
$ ulimit -c unlimited
</code></pre></li>
<li><p>第二步设置php-fpm，使php-fpm生成core</p>
<pre><code>$ vim /usr/local/php/etc/php-fpm.conf
</code></pre><p> 修改配置</p>
<pre><code>``rlimit_core = unlimited```
</code></pre><p> 重启php-fpm <code>sudo /etc/init.d/php-fpm restart</code></p>
</li>
<li><p>确认coredump</p>
<p> 如果在php-fpm的error_log日志中看到类似下面的日志就代表生成了coredump，那么在/tmp/目录下就会有coredump文件<br> <code>[05-Jun-2014 06:21:12] WARNING: [pool www] child 631273 exited on signal 11 (SIGSEGV - core dumped) after 20.263546 seconds from start</code></p>
</li>
<li><p>读取backtrace</p>
<p> 使用下面语法来运行gdb</p>
<pre><code>``gdb /usr/local/php/sbin/php-fpm /tmp/core-php-fpm.1230``
</code></pre><p> 可以运行<code>bt</code>命令获得更加详细的输出</p>
<pre><code>``(gdb) bt``
</code></pre></li>
</ol>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://bugs.php.net/bugs-generating-backtrace.php" target="_blank" rel="noopener">Generating a gdb backtrace</a><br><a href="https://easyengine.io/tutorials/php/core-dump-php5-fpm/" target="_blank" rel="noopener">geberating core-dump for php5-fpm</a><br><a href="http://www.laruence.com/2011/06/23/2057.html" target="_blank" rel="noopener">如何调试PHP的Core之获取基本信息</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/09/07/php如何生成coredump/" data-id="ckw1x5qc1004a3mnudf33chcm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Prepared-Statement防止sql注入原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/18/Prepared-Statement防止sql注入原理/" class="article-date">
  <time datetime="2016-08-18T09:54:54.000Z" itemprop="datePublished">2016-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/18/Prepared-Statement防止sql注入原理/">为什么使用Prepared Statement?</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>查询执行的基础<br>MySQL发送一个请求的时候，MySQL到底做了什么：</p>
<p> a. 客户端发送一条查询给服务器<br> b. 服务器先检查<code>查询缓存</code>，如果命中了缓存，则like返回存储在缓存中的结果。否则进入下一阶段<br> c. 服务器端进行SQL解析，预处理，再由优化器生成对应的执行计划<br> d. MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询<br> e. 将结果返回给客户端。</p>
<p> 即：SQL执行过程包括以下阶段：查询缓存是否命中-&gt;词法解析-&gt;语法分析-&gt;语义分析-&gt;查询优化-&gt;执行。</p>
</li>
<li><p>硬解析</p>
<p> <code>词法分析</code>-&gt;<code>语法分析</code>这两个阶段我们称之为硬解析。词法分析识别SQL中每个词，语法分析解析SQL是否符合SQL语法（如关键字顺序是否正确），并得到一颗语法树。对于只是参数不同，其他均相同的SQL，他们执行时间不同但是硬解析时间是相同的。</p>
</li>
<li><p>查询优化器<br> 现在语法树被认为是合法了，并且由优化器将其转化成执行计划。一条查询可以有很多种执行方式，最后返回相同的结果。<br>优化器的作用：就是找到这其中最好的执行计划</p>
</li>
<li><p>Prepare的目的<br> Prepare的出现就是为了优化硬解析的问题。Prepare在服务器端执行过程如下：</p>
<p> a. Prepare接受客户端带<code>?</code>的SQL，硬解析得到语法树stmt-&gt;lex， 缓存在线程所在的preparestatement cache中。此cache是一个HASH MAP. Key为stmt-&gt;id. 然后返回客户端stmt-&gt;id等信息。<br> b. Execute 接收客户端stmt-&gt;id和参数等信息。注意这里客户端不需要再发sql过来。服务器根据stmt-&gt;id在preparestatement cache中查找得到硬解析后的stmt, 并设置参数，就可以继续后面的优化和执行了</p>
</li>
<li><p>Prepared Statements的好处：<br> a. 安全<br> Prepared Statements通过sql逻辑与数据分离来增加安全，sql逻辑与数据的分离能够防止普通类型的SQL注入攻击（sql injection attck)。<br> b. 性能<br> prepare经过语法解析器和预处理生成了解析树。通过prepare方式，当执行多次时，就不会有额外的负担了。</p>
</li>
<li><p>Prepared 实例</p>
</li>
</ol>
<p>表结构</p>
<pre><code>CREATE TABLE `z` (
    `a` int(11) NOT NULL,
    `b` int(11) DEFAULT NULL,
    PRIMARY KEY (`a`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
</code></pre><p>Prepare</p>
<pre><code>prepare stmt1 from &apos;select * from z where a = ?&apos;;
set @a = 20;
execute stmt1 using @a;
</code></pre><p><a href="http://www.cnblogs.com/justfortaste/p/3920140.html" target="_blank" rel="noopener">MySQL prepare原理</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/08/18/Prepared-Statement防止sql注入原理/" data-id="ckw1x5qap000u3mnuoldnclgd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux定时任务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/17/linux定时任务/" class="article-date">
  <time datetime="2016-08-17T08:11:49.000Z" itemprop="datePublished">2016-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/17/linux定时任务/">linux定时任务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="34-1-Cron"><a href="#34-1-Cron" class="headerlink" title="34.1. Cron"></a>34.1. Cron</h2><p>Cron是一个守护进程，根据分时日月周的组合来执行任务。<br>Cron假设系统是可用的。如果系统不可用，那么定时任务不会执行。为了安排one-time tasks，可以参考 at and batch.</p>
<p>为了执行Cron服务，<code>crond</code>服务必须执行。<br>可以使用命令<code>rpm -q vixie-cron</code>命令查看是否安装。可以使用命令 <code>service crond status</code>查看状态</p>
<h3 id="34-1-1-配置定时任务"><a href="#34-1-1-配置定时任务" class="headerlink" title="34.1.1 配置定时任务"></a>34.1.1 配置定时任务</h3><pre><code>SHELL=/bin/bash 
PATH=/sbin:/bin:/usr/sbin:/usr/bin 
MAILTO=root HOME=/  
# run-parts 
01 * * * * root run-parts /etc/cron.hourly 
02 4 * * * root run-parts /etc/cron.daily 
22 4 * * 0 root run-parts /etc/cron.weekly 
42 4 1 * * root run-parts /etc/cron.monthly
</code></pre><p>前四行用于配置定时任务执行时的环境变量。<code>SHELL</code>变量告诉系统使用哪个shell，<code>PATH</code>变量定义了执行命令的路径。<code>MAILTO</code>定义了定时任务的输出结果被email给谁，如果MAILTO=””，则不发送邮件。<code>HOME</code>变量用于home目录。</p>
<p>在<code>/etc/crontab/</code>文件中任务的格式如下：<br>    <code>minute hour day month dayofweek command</code></p>
<ul>
<li>minute – 从0到59的任何数字</li>
<li>hour   – 从0到23的任何数字</li>
<li>day    – 从0到31的任何一天</li>
<li>month  – 从1到12的任何数字（或者月份的缩写，如jan或feb）</li>
<li>dayofweek – 从0到7的数字，其中0或7代表星期天（或者缩写，如mon或sun）</li>
<li>command – 要执行的命令</li>
</ul>
<p>几种取值情况</p>
<ul>
<li><code>*</code>：代表任何有效值</li>
<li><code>-</code>：指定一个数字的范围，如1-3代表整数1，2，3。</li>
<li><code>,</code>: 一个以逗号分隔的列表，如3,4,5,8代表四个特定的数字。</li>
<li><code>/</code>: 用于指定步进的值（step value）。 The value of an integer can be skipped within a range by following the range with /<integer>. For example, 0-59/2 can be used to define every other minute in the minute field. Step values can also be used with an asterisk. For instance, the value */3 can be used in the month field to run the task every third month.</integer></li>
</ul>
<p>正如在/etc/crontab文件中，run-parts脚本执行/etc/cron.hourly/，/etc/cron.daily/, /etc/cron.weekly/, and /etc/cron.monthly/目录下的文件。在这些目录下面必须是shell脚本。</p>
<p>如果定时任务不是每小时，每天，每周，每月，那么定时任务可以加到/ect/cron.d/目录下，这个目录下文件的格式与/etc/crontab是一样的。</p>
<p>除了root以外的用户，可以使用crontab工具配置定时任务。所有用户定义的crontab都存在/var/spool/cron/目录下，并且使用创建他们的用户名来执行。使用crontab -e可以编辑。</p>
<p>cron守护进程每分钟会检查/etc/crontab文件，/ect/cron.d/目录的变化，如果有变化则加载到内存。因此如果crontab文件改变了不需要重启守护进程。</p>
<h3 id="34-1-2-控制访问cron权限"><a href="#34-1-2-控制访问cron权限" class="headerlink" title="34.1.2 控制访问cron权限"></a>34.1.2 控制访问cron权限</h3><p>/etc/cron.allow和/etc/cron.deny文件用于严格控制cron进程的访问。文件格式：一行一个用户名，不需要出现空格。如果访问控制文件修改了，crond不需要重启。</p>
<p>root用户什么时候都可以使用cron，而不用考虑访问控制文件中的用户名<br>如果cron.allow文件存在，只有users列表中的用户允许访问；忽略cron.deny文件<br>如果cron.allow文件不存在，只有cron.deny中用户不允许访问。</p>
<h3 id="34-1-3-开始和停止服务"><a href="#34-1-3-开始和停止服务" class="headerlink" title="34.1.3 开始和停止服务"></a>34.1.3 开始和停止服务</h3><p>使用service crond start 开启。<br>使用service crond stop 关闭。</p>
<h2 id="34-2-At和Batch"><a href="#34-2-At和Batch" class="headerlink" title="34.2 At和Batch"></a>34.2 At和Batch</h2><p>cron用于规划重复的任务，at命令用于规划一次性任务（one-time task)，batch用于在系统负载小于0.8的时候执行一次性任务。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://www.centos.org/docs/5/html/Deployment_Guide-en-US/s1-autotasks-at-batch.html" target="_blank" rel="noopener">cron</a></li>
<li><a href="https://www.centos.org/docs/5/html/Deployment_Guide-en-US/s1-autotasks-at-batch.html" target="_blank" rel="noopener">at and batch</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/08/17/linux定时任务/" data-id="ckw1x5qbh002u3mnuwrhdyzcp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础知识/">基础知识</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-RedisCluster总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/10/RedisCluster总结/" class="article-date">
  <time datetime="2016-08-10T13:39:06.000Z" itemprop="datePublished">2016-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/10/RedisCluster总结/">RedisCluster总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、RedisCluster基本内容"><a href="#一、RedisCluster基本内容" class="headerlink" title="一、RedisCluster基本内容"></a>一、RedisCluster基本内容</h1><h2 id="1-项目背景"><a href="#1-项目背景" class="headerlink" title="1. 项目背景"></a>1. 项目背景</h2><h3 id="a-整个项目背景"><a href="#a-整个项目背景" class="headerlink" title="a. 整个项目背景"></a>a. 整个项目背景</h3><ul>
<li><p>云盘memcache服务器分散，监控和替换麻烦</p>
<p>  云盘100多个集群，每个集群4个memcache，需要业务方配置和监控这些memcache。一旦memcache超时或者不可用，需要业务方和ops共同操作才能解决memcache的问题。</p>
</li>
<li><p>云盘缓存并发高、空间大</p>
<p>  云盘缓存有36亿，400G空间，每秒钟25万的请求量，因此需要高并发的缓存集群才能满足需求。</p>
</li>
</ul>
<h3 id="b-现在的替代方案"><a href="#b-现在的替代方案" class="headerlink" title="b. 现在的替代方案"></a>b. 现在的替代方案</h3><p>使用RedisCluster作为缓存集群。其特点（也是其设计目标）是：</p>
<ul>
<li>水平扩展：最大可以扩展到1000个节点</li>
<li>可以接受的写安全：当出现网络分区（即脑裂）的时候能保证连接到大多数节点分区的写是安全的。</li>
<li>高可用性：当出现网络分区时，大多数节点所在的分区是可用的；并且通过复制转移（replicas migration）保证没有从节点的主节点获得一个从节点。<br>  （所谓的复制转移：当一个主节点A有多个从节点A1,A2,A3，而另外一个主节点B没有从节点时，RedisCluster集群会从多个从节点A1,A2,A3中选择一个从节点A2作为主节点B的从节点）</li>
</ul>
<p>目前RedisCluster 目前集群大小是：</p>
<ul>
<li>一个机房一个大集群</li>
<li>bjdt：集群中有24个节点，每个节点一主一从。每个节点18.63G</li>
<li>bjcc：集群内有16个节点，每个节点一主一从。每个节点18.63G。</li>
</ul>
<h2 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2. 使用方法"></a>2. 使用方法</h2><h3 id="a-业务方使用："><a href="#a-业务方使用：" class="headerlink" title="a. 业务方使用："></a>a. 业务方使用：</h3><p>有两种客户端，一种是笨蛋客户端，一种是智能客户端。</p>
<p><code>笨蛋客户端</code>：本地不缓存节点信息，请求达到任意一个RedisCluster节点后，被告知真正的节点，然后再次请求。比如：redis-cli，telnet</p>
<pre><code>redis-cli -c -h 10.10.10.10 -p 6666
10.10.10.10:6666&gt; get ab
-&gt; Redirected to slot [13567] located at 11.11.11.11:6666
&quot;1&quot;
</code></pre><p><code>智能客户端</code>：本地缓存节点信息，通过本地计算出槽位，直接发一次请求即可。</p>
<h3 id="b-phpredis"><a href="#b-phpredis" class="headerlink" title="b. phpredis"></a>b. phpredis</h3><p>目前<a href="https://github.com/phpredis/phpredis" target="_blank" rel="noopener">phpredis</a>是智能客户端。</p>
<p>不过在最开始的版本中，phpredis每次new RedisCluster都会发送cluster slots来获取节点信息，其实对于一个业务而言是没有必要的。原因是因为RedisCluster一旦稳定后一般不会调整，那么其节点信息就维持不变，因此没有必要每次都去获取。并且cluster slots非常消耗cluster节点的cpu。这一点<a href="https://github.com/JacketWoo" target="_blank" rel="noopener">吴晓飞</a>同学已经给phpredis提了<a href="https://github.com/phpredis/phpredis/pull/826" target="_blank" rel="noopener">pullrequest</a></p>
<h2 id="3-RedisCluster基本概念"><a href="#3-RedisCluster基本概念" class="headerlink" title="3. RedisCluster基本概念"></a>3. RedisCluster基本概念</h2><h3 id="a-集群创建"><a href="#a-集群创建" class="headerlink" title="a. 集群创建"></a>a. 集群创建</h3><ol>
<li>Redis实例启动，redis.conf中多了一个配置项<code>cluster-enabled yes</code></li>
<li>Redis节点通过<code>cluster meet</code>形成一个集群，但是集群不可用</li>
<li>分配槽位：需要将16384个槽位分配到集群中各个节点。如果有的槽位没有分配成功，那么集群就可能不可用（跟<code>cluster-require-full-coverage</code>参数有关系）</li>
</ol>
<h3 id="b-RedisCluster-keys分布模型"><a href="#b-RedisCluster-keys分布模型" class="headerlink" title="b. RedisCluster keys分布模型"></a>b. RedisCluster keys分布模型</h3><p>一共有16384个hash槽位。集群中每个主节点负责16384个槽位中的一部分。如果没有正在进行中的集群重新配置，那么槽位的分布是稳定的。</p>
<p>key与槽位的映射关系计算算法（如果有hash tags则不使用该计算算法）</p>
<pre><code>HASH_SLOT=CRC(key) mod 16384
</code></pre><h3 id="c-RedisCluster与Memcache比较"><a href="#c-RedisCluster与Memcache比较" class="headerlink" title="c. RedisCluster与Memcache比较"></a>c. RedisCluster与Memcache比较</h3><p>我们知道Memcached是“分布式”缓存服务器，但是服务器端没有分布式功能，需要客户端来实现分布式，也就是需要客户端配置好几台memcached服务器，根据分布式算法（一般采用一致性hash算法）计算哪个key位于哪台memcached机器上。</p>
<p>而RedisCluster没有采用一致性hash算法，而是采用了一种<code>hash 槽位</code>的概念。与Memcached相比，业务方不需要维护memcached服务器的列表。使用智能客户端，可以先获取一份节点信息，然后在本地进行计算hash槽位。</p>
<h3 id="d-RedisCluster-HashTags"><a href="#d-RedisCluster-HashTags" class="headerlink" title="d. RedisCluster HashTags"></a>d. RedisCluster HashTags</h3><p>所谓的<code>hash tags</code>是指key中出现了<code>{&quot;字符串&quot;}</code>或者空的符合<code>{}</code>。 当出现<code>HashTags</code>时，key的<code>hash 槽位</code>不是计算整个key所在的槽位，而是计算<code>{}</code>中间字符串的槽位。<br>举例：<code>{user1000}.following</code> 与 <code>{user1000}.followers</code> 这两个key在同一个slot里面。因为其<code>hash tags</code>中的字符串是 <code>user1000</code></p>
<h3 id="e-RedisCluster和Redis比较"><a href="#e-RedisCluster和Redis比较" class="headerlink" title="e. RedisCluster和Redis比较"></a>e. RedisCluster和Redis比较</h3><ul>
<li>RedisCluster实现了所有单key的命令，比如get,set</li>
<li>RedisCluster中多key操作的命令要求多key必须在同一个节点上，可以通过<code>hash tags</code>强迫这些key存在相同节点上。</li>
</ul>
<h3 id="f-RedisCluster重定向"><a href="#f-RedisCluster重定向" class="headerlink" title="f. RedisCluster重定向"></a>f. RedisCluster重定向</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>RedisCluster有两种重定向错误：<code>-MOVED</code>和<code>-ASK</code>两种重定向错误</p>
<p>刚刚在<code>RedisCluster keys</code>分布模型中提到如果没有进行中的集群重新配置，那么槽位分布是稳定的。<br>如果集群正在发生调整呢，那么集群会返回给客户端<code>-MOVED 8 127.0.0.1:8080</code>错误或者 <code>-ASK 8 127.0.0.1:8080</code>这两个重定向错误。 </p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>举例：假设集群中节点A(<code>127.0.0.1:8080</code>)负责hash槽位13565,13566,13567。 节点B(<code>127.0.0.2:8080</code>)负责hash槽位100，101，102。</p>
<p><code>根据crc(ab) mod 16384计算得到ab这个key的slot是13567</code></p>
<p>a. 如果集群没有调整，那么 向节点B请求get ab ，那么节点B会返回<code>-MOVED 127.0.0.1:8080</code>。 </p>
<p>b. 如果集群有所调整，将hash槽位13567从节点A迁移到节点B。</p>
<p>在迁移过程中，节点A处于<code>MIGRATING</code>状态，节点B处于<code>IMPORTING</code>状态。</p>
<p>此时向节点A请求get ab， </p>
<p>1) 如果ab这个位于13567的key已经迁移到节点B了，那么将会受到<code>-ASK 127.0.0.2:8080</code>，此时客户端先向节点B发送一个ASKING的命令，然后再get ab就可以获得数据。如果客户端不向节点B发送一个ASKING命令，而是直接向节点B发送get ab则会返回<code>-MOVED</code>错误。<br>2) 如果ab这个位于13567的key没有迁移到节点B，即依然在节点A上，那么直接返回数据。</p>
<p>c. 如果集群已经调整完毕，即hash槽位13567位于节点B，那么向节点A请求 get ab就会返回<code>-MOVED 127.0.0.2:8080</code></p>
<h4 id="MOVED和-ASK两个重定向区别："><a href="#MOVED和-ASK两个重定向区别：" class="headerlink" title="-MOVED和-ASK两个重定向区别："></a><code>-MOVED</code>和<code>-ASK</code>两个重定向区别：</h4><ol>
<li>MOVED代表槽已经完全从一个节点迁移到另外一个节点</li>
<li>ASK是槽位迁移的中间态，代表这个槽位的节点正在迁移。只针对这个槽位的这个key进行重定向，该槽位上其他key依然先到原来的节点</li>
</ol>
<h3 id="f-RedisCluster节点属性"><a href="#f-RedisCluster节点属性" class="headerlink" title="f. RedisCluster节点属性"></a>f. RedisCluster节点属性</h3><pre><code>redis-cli cluster nodes
d1861060fe6a534d42d8a19aeb36600e18785e04 127.0.0.1:6379 myself - 0 1318428930 1 connected 0-1364
3886e65cc906bfd9b1f7e7bde468726a052d1dae 127.0.0.1:6380 master - 1318428930 1318428931 2 connected 1365-2729
d289c575dcbc4bdd2931585fd4339089e461a27d 127.0.0.1:6381 master - 1318428931 1318428931 3 connected 2730-4095
</code></pre><p>通过<a href="http://redis.io/commands/cluster-nodes" target="_blank" rel="noopener">cluster nodes</a>命令可以知道RedisCluster集群的很多信息，比如当前槽位分布，当前节点个数及其ip:port等等</p>
<h1 id="二、RedisCluster的高可用原理"><a href="#二、RedisCluster的高可用原理" class="headerlink" title="二、RedisCluster的高可用原理"></a>二、RedisCluster的高可用原理</h1><h2 id="1-RedisCluster的CAP"><a href="#1-RedisCluster的CAP" class="headerlink" title="1. RedisCluster的CAP"></a>1. RedisCluster的CAP</h2><p>RedisCluster本身是一个分布式NoSQL，因此必然符合CAP定理中的相关内容。</p>
<h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><p>CAP定理基本描述：</p>
<p>给定”一致性Consistency“、”可用性Availability“、”分区耐受性Partition tolerance”这三个属性，我们只能同时满足其中两个属性。</p>
<ul>
<li><p>分区耐受性：如果发生通信故障，导致整个集群被分隔成多个无法互相通信的分区时（这种情况也叫“脑裂” split brain），集群依然可用。</p>
<p>  在RedisCluster中有个参数cluster-require-full-coverage<br>  该参数取值为yes时，出现分区时则不可用；反之则不可用</p>
<p>  <img src="/images/redis_cluster/脑裂.png" alt="脑裂"></p>
</li>
<li><p><code>一致性</code>：在各个节点上数据一样。<br>  一致性的关键在于：将请求序列化，使之成为原子的（atomic）、相互隔离的（Isolated）”工作单元“（work unit）。</p>
</li>
<li><p><code>可用性</code>：如果客户可以同集群中的某个节点通信，那么该节点就必须能够处理读取及写入操作。<br>CAP定理中将可用性定义为：系统中某个无故障节点所接受的每一条请求，无论成功或失败，都必将得到响应。所以按照这个定义，发生故障且无法响应客户请求的节点，并不会导致系统失去“CAP定理”所定义的那种“可用性”。</p>
</li>
</ul>
<p>这意味着你可以构建一个CA集群，如果出现“分区”现象，那么所有节点必须全部停止工作。</p>
<p>尽管CAP定理经常表述为“三个属性中只能保有两个”，但实际上是在讲：当系统可能遭遇“分区”状况时，我们需要在“一致性”与“可用性”之间进行权衡。通常我们会略微舍弃“一致性”，以获取某种程度的“可用性”。这样产生的系统，既不具备完美的“一致性”，也不具备完美的“可用性”，但是这两种不完美的特性结合起来却能够满足特定需求。</p>
<h3 id="RedisCluster满足了AP，最终一致性"><a href="#RedisCluster满足了AP，最终一致性" class="headerlink" title="RedisCluster满足了AP，最终一致性"></a>RedisCluster满足了AP，最终一致性</h3><ol>
<li>分区耐受性：大多数节点可用时，RedisCluster可以分区可用。当出现分区时，连接到多数节点分区和连接到少数节点分区有很大不同。</li>
<li>可用性：通过复制转移（replicas migration），没有从节点的主节点会获得一个从节点，从而提供可用性。</li>
<li>高性能并且能够线性扩展到1000个节点。</li>
<li><p>最终一致性，异步复制，存在写入安全问题。</p>
<p> 最终一致性：eventually consistent：也就是说在任意时刻，节点中都可能存在“复制不一致”问题，然而只要不再继续执行其他更新操作，那么上一次更新操作的结果最终将会反映到全部节点中去。</p>
</li>
</ol>
<h3 id="RedisCluster写入的流程"><a href="#RedisCluster写入的流程" class="headerlink" title="RedisCluster写入的流程"></a>RedisCluster写入的流程</h3><p>RedisCluster的写入是异步复制。</p>
<ul>
<li>client先写入主，主回复<code>+OK</code>，此时client认为写入成功</li>
<li>主节点开始异步复制，将写入同步到从节点</li>
</ul>
<h3 id="RedisCluster写入安全"><a href="#RedisCluster写入安全" class="headerlink" title="RedisCluster写入安全"></a>RedisCluster写入安全</h3><ul>
<li>写入安全情况1:<br>  先写入主<br>  再由主传播到从。<br>  主从式分布模型，存在主写入成功，主挂没有传播<br>  从升为主，数据丢失。</li>
</ul>
<ul>
<li><p>写入安全情况2: 发生分区时写丢失</p>
<p>  举例：6节点集群，3主3从，节点是A,B,C, A1,B1,C1。还有一个客户端Z1。发生分区时，一个分区是A,C,A1,B1,C1，另外一个分区是B和Z1.此时Z1还可以向B写入，B也可以接收写操作。<br>  如果在很短时间内，B恢复了那么集群正常；<br>  如果分区持续太久，那么B1就被推举为新主，此时过了NODE_TIMEOUT时间，节点B也不写，那么分区后写入B的数据就丢失了。<br>  写操作丢失的最大持续时间是NODE_TIMEOUT+从推举时间</p>
<p>  NoSQL倡导者经常说，与关系型数据库所支持的ACID事务不同，NoSQL系统具备“BASE属性“（基本可用，柔性状态，最终一致性）英文是 Basically Available, Soft state, Eventual consistency.</p>
</li>
</ul>
<h2 id="2-容错-Fault-Tolerance"><a href="#2-容错-Fault-Tolerance" class="headerlink" title="2. 容错 Fault Tolerance"></a>2. 容错 Fault Tolerance</h2><h3 id="心跳包和流言消息"><a href="#心跳包和流言消息" class="headerlink" title="心跳包和流言消息"></a>心跳包和流言消息</h3><p>心跳包的目的：RedisCluster集群中各个节点会通过发送心跳包（ping包和pong包）来进行通信，更新集群的配置信息。通常节点发送ping包以后，期待对方回复pong包。</p>
<p>RedisCluster一个节点一次只向集群中某些节点发送心跳包（目前一次发送的节点数量是总节点个数的十分之一）。同时考虑到RedisCluster发送对象节点是随机的，所以存在两个节点很久都没有交换消息，为了保证集群状态能够在很多时间内达到一致性，RedisCluster规定当两个节点超过<code>NODE_TIMEOUT一半</code>的时间没有交换消息时，下次发心跳包交换消息。</p>
<p>比如，对于100个节点的集群，NODE_TIMEOUT设置为60秒，那么根据上面的理论，一个节点在30s内要向99个节点发送ping，对于100各节点则每秒发送330个pings。<a href="https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653547585&amp;idx=1&amp;sn=9a664b16f656f757632cd4eb29f9a5dc&amp;scene=0&amp;key=8dcebf9e179c9f3a346c582e0a5712dda1ec87878842175cce35a5ea1cd92ee99c770c79d2f99f97dcb43597000373f8&amp;ascene=0&amp;uin=NTE5MDc2ODU1&amp;devicetype=iMac+MacBookPro11%2C1+OSX+OSX+10.11.3+build(15D21" target="_blank" rel="noopener">近千节点的Redis Cluster高可用集群案例</a>&amp;version=11020201&amp;pass_ticket=4CBC9RgbSswvChRwX4aHuDwbNTxwAjmPNbOVneP4ac8%2BaS%2BQ8YWN5LJF3ipxB8fR)</p>
<p>通过这一点可以看出，集群间通信占用大量带宽资源。</p>
<h3 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h3><p>目的：当大多数节点不能访问某个主或从节点时，其从节点就会被推举为主节点。当从推举失败后，集群是error state, 将会停止接收来自客户端的请求。</p>
<p>实现：</p>
<ol>
<li>PFAIL状态：<br>集群中有n个节点，当节点A自己认为节点B不可用了，并不能认为节点B不可用，</li>
<li>FAIL状态：<br>必须集群中大多数节点认为节点B不可用了，节点B才是真的不可用。<br>当在<code>NODE_TIME * FAIL_REPORT_VALIDITY_MULT</code>时间内超过一半的节点认为B不可达时，节点B才真的是不可达<br>（当前实现中该validity参数是2）。<br> 节点不可达的概念：节点发送的ping包超过NODE_TIMEOUT时间依然收不到pong包。<br> 工作原理：当发送的ping包，在<code>NODE_TIMEOUT/2</code>时间后依然收不到pong包时，节点会去重连集群中的其他节点。</li>
<li>广播：<br>此时节点A会广播一条FAIL消息，告知大家节点B不可达。所有收到FAIL消息的节点，都被强制设定节点B不可达。<br> FAIL标志只是为了安全的触发从推举的算法。</li>
</ol>
<h3 id="故障转移-failover"><a href="#故障转移-failover" class="headerlink" title="故障转移 failover"></a>故障转移 failover</h3><ol>
<li><p>从节点选举</p>
<p> 从已经下线的主节点的所有从节点里面，选中一个从节点。从节点的选举需要得到大多数主节点的授权</p>
</li>
<li><p>成为主节点</p>
<p> 被选中的从节点会执行SLAVEOF no one命令，成为新的主节点并且负责旧主节点的槽位</p>
</li>
<li><p>广播</p>
<p> 广播一条pong消息，通知其他节点更新节点映射信息</p>
</li>
</ol>
<h3 id="复制转移-replicas-migration"><a href="#复制转移-replicas-migration" class="headerlink" title="复制转移 replicas migration"></a>复制转移 replicas migration</h3><p>复制转移的定义：如果一个主节点A没有从节点，而集群中有的主节点B有多个从节点s1,s2,s3；那么RedisCluster会从多个从节点中选择一个从节点作为主节点A的从节点。<br>复制转移的目的：为了提高系统的可用性。</p>
<p>比如一个集群中A,B,C 3个主节点，其从节点分别是A1,B1,C1,C2，其中C的从节点有两个。<br>当B挂了以后，B1升为主节点，此时B1节点没有从节点。</p>
<p>a. 如果没有复制转移的话，那么B1再挂了的话，这个节点上的槽位都不可用了。<br>b. 如果有复制转移的话，那么会从C的两个从节点C1和C2中选择一个作为B1的从节点，我们假设选择的是C2。那么现在集群的情况是A-A1，B1-C2，C-C1。如果这时候B节点又可用了，那么他将会作为某个主节点的从节点。</p>
<h2 id="4-配置操作、传播、故障转移"><a href="#4-配置操作、传播、故障转移" class="headerlink" title="4. 配置操作、传播、故障转移"></a>4. 配置操作、传播、故障转移</h2><h3 id="Cluster-currentEpoch"><a href="#Cluster-currentEpoch" class="headerlink" title="Cluster currentEpoch"></a>Cluster currentEpoch</h3><p>其目的是为了当节点信息发生冲突的时候来解决冲突。解决冲突的方法很简单，epoch高的配置覆盖epoch低的配置，即以epoch高的配置为准。</p>
<h3 id="configuration-epoch"><a href="#configuration-epoch" class="headerlink" title="configuration epoch"></a>configuration epoch</h3><ol>
<li>新节点创建时，configEpoch是0</li>
<li>从节点推举后，生成新的configEpoch，从节点尝试取代失败主节点的epoch，并且获得大多数主节点的授权，那么configEpoch会加1. </li>
<li>configEpoch帮助解决的是当不同节点声明不同配置配置时，用于解决冲突。</li>
</ol>
<p>RedisCluster配置参数：</p>
<pre><code>cluster-enabled 
cluster-config-file &lt;filename&gt;
cluster-node-timeout &lt;milliseconds&gt;
cluster-slave-validity-factor &lt;factor&gt;
cluster-migration-barrier &lt;count&gt;
cluster-require-full-coverage &lt;yes/no&gt;
</code></pre><h1 id="三、期间出现问题"><a href="#三、期间出现问题" class="headerlink" title="三、期间出现问题"></a>三、期间出现问题</h1><ol>
<li><p>客户端cluster slots没有缓存，造成RedisCluster节点cpu过高。</p>
<p> phpredis虽然是智能客户端，<br> 但对于每个RedisCluster类都需要发送<code>cluster slots</code>命令获取节点和slot的对应关系，从而造成节点CPU过高。<br> 因为<code>cluster slots</code>命令需要执行两层主循环，分别是循环nodes和slot。对于master节点还需要扫描slave，cpu的计算开销就出来了</p>
</li>
<li><p>timewait过高</p>
<p> 由于我们代码中设置100ms超时，当RedisCluster服务器返回过慢时，客户端会主动断开连接，因此出现大量timewait</p>
</li>
<li><p>为何不使用长连接。</p>
<p> a. 因为云盘前端机非常多，300台前端机，每台前端机128个进程，那么对于cluster节点而言是38400个长连接，cluster节点所占用的内存和fd开销非常大。<br> b. 长连接：cpu明显下降，但是连接数暴涨<br> c. 短连接：通过客户端缓存节点信息能够降低部分cpu，但cpu依然偏高</p>
</li>
<li><p>del返回warning</p>
<p>原因是del对返回值校验严格，要求必须是整形（即<code>:1</code>)这种格式，当出现<code>-MOVED</code>错误或者超时没有读取到数据时，则会报warning<br>出现时机：当RedisCluster的CPU过高时，del在100ms（设定的读超时是100ms）内没有响应，那么返回<code>?</code>的值，不是整形，因此会报warning</p>
</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="http://itindex.net/detail/52699-redis-cluster-failover" target="_blank" rel="noopener">Redis Cluster的FailOver失败案例分析</a></li>
<li><a href="http://itindex.net/detail/54098-redis-cluster-%E7%99%BE%E4%B8%87" target="_blank" rel="noopener">Redis 百万QPS挑战</a></li>
<li><a href="http://redis.io/topics/cluster-spec" target="_blank" rel="noopener">Redis Cluster Specification</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://keything.github.io/2016/08/10/RedisCluster总结/" data-id="ckw1x5qaq000x3mnul3o0katd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nosql/">nosql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Laravel/">Laravel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/composer/">composer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/">cpp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp-lib/">cpp-lib</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/faiss/">faiss</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-source-code/">go.source.code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/laravel/">laravel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/">mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/machine-learning/">machine-learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memcache/">memcache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nosql/">nosql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/octave/">octave</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php源码学习/">php源码学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/">spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tcp/">tcp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thrift/">thrift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础知识/">基础知识</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Laravel/" style="font-size: 10px;">Laravel</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/composer/" style="font-size: 10px;">composer</a> <a href="/tags/cpp/" style="font-size: 12.22px;">cpp</a> <a href="/tags/cpp-lib/" style="font-size: 10px;">cpp-lib</a> <a href="/tags/elasticsearch/" style="font-size: 11.11px;">elasticsearch</a> <a href="/tags/faiss/" style="font-size: 10px;">faiss</a> <a href="/tags/git/" style="font-size: 12.22px;">git</a> <a href="/tags/go-source-code/" style="font-size: 10px;">go.source.code</a> <a href="/tags/golang/" style="font-size: 16.67px;">golang</a> <a href="/tags/laravel/" style="font-size: 11.11px;">laravel</a> <a href="/tags/linux/" style="font-size: 14.44px;">linux</a> <a href="/tags/mac/" style="font-size: 13.33px;">mac</a> <a href="/tags/machine-learning/" style="font-size: 10px;">machine-learning</a> <a href="/tags/memcache/" style="font-size: 15.56px;">memcache</a> <a href="/tags/mysql/" style="font-size: 13.33px;">mysql</a> <a href="/tags/nginx/" style="font-size: 13.33px;">nginx</a> <a href="/tags/nosql/" style="font-size: 18.89px;">nosql</a> <a href="/tags/octave/" style="font-size: 10px;">octave</a> <a href="/tags/php/" style="font-size: 20px;">php</a> <a href="/tags/php源码学习/" style="font-size: 17.78px;">php源码学习</a> <a href="/tags/redis/" style="font-size: 12.22px;">redis</a> <a href="/tags/spark/" style="font-size: 12.22px;">spark</a> <a href="/tags/tcp/" style="font-size: 10px;">tcp</a> <a href="/tags/thrift/" style="font-size: 13.33px;">thrift</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/基础知识/" style="font-size: 15.56px;">基础知识</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/11/16/Spark-DataSource-Hive Tables/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/11/14/分布式-事务/">分布式-事务</a>
          </li>
        
          <li>
            <a href="/2019/04/29/golang继承/">golang继承</a>
          </li>
        
          <li>
            <a href="/2019/04/28/spark-Quick-Start/">spark quick start</a>
          </li>
        
          <li>
            <a href="/2019/03/20/golang-包导入/">golang包导入</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Keything<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>